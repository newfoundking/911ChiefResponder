<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Chief Responder</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
	<style>
		body { margin: 0; display: flex; height: 100vh; font-family: sans-serif; }
		#sidebar { max-width: 30%; width: 100%; overflow-y: auto; padding: 10px; box-sizing: border-box; }
		#map { flex: 1; }
		.mission { border-bottom: 1px solid #ccc; margin-bottom: 1em; padding-bottom: 0.5em; }
		.tab-button { padding: 0.5em 1em; border: none; background: #ddd; cursor: pointer; }
		.tab-button.active { background: #aaa; font-weight: bold; }
		.tab-content { display: none; }
		.tab-content.active { display: block; }
		#stationDetails { max-width: 30%; overflow-y: auto; }
		.popup { position: fixed; top: 10%; left: 30%; width: 40%; background: white; border: 2px solid black; padding: 20px; z-index: 9999; max-height: 80%; overflow-y: auto; }
		.hidden { display: none; }
		.modal-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; overflow: auto; }
		.modal-content { background: white; padding: 2rem; max-width: 90%; max-height: 90%; overflow-y: auto; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); }
	</style>
</head>
<body>

<div id="sidebar">
	<h2>Mission Chief Clone</h2>
	<div style="display: flex; gap: 1em; margin-bottom: 1em;">
		<button class="tab-button active" data-tab="missions">Missions</button>
		<button class="tab-button" data-tab="stations">Stations</button>
	</div>
	<div id="walletDisplay">Balance: $0</div>
	<script>
	async function refreshWallet(){
	  const w = await fetch('/api/wallet').then(r=>r.json());
	  document.getElementById('walletDisplay').textContent = `Balance: $${w.balance}`;
	}
	setInterval(refreshWallet, 5000);
	refreshWallet();
	</script>
	<div id="tab-missions" class="tab-content active">
		<button id="generateMission">Generate Mission</button>
		<button id="clearMissions" style="background: darkred; color: white; margin-top: 1em;">DEBUG CLEAR ALL CALLS</button>
		<button id="deleteAllStations">DEBUG DELETE ALL STATIONS</button>
		<div id="missionList"></div>
	</div>

	<div id="tab-stations" class="tab-content">
	  <button id="buildStation" style="margin-bottom: 1em;">Build New Station</button>
	  <div id="stationList"></div>
	</div>
</div>

<div id="map"></div>

<!-- Modal for Mission & Station Details -->
<div id="missionDetails" style="
  position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
  background: white; padding: 1em; border: 2px solid #444;
  box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 9999;
  width: 420px; max-height: 80vh; overflow-y: auto; border-radius: 8px;
  display: none;">
        <div style="text-align:right;">
                <button onclick="closeMissionDetails()">Close</button>
        </div>
        <h3>Details</h3>
        <div id="missionDetailsContent">Loading...</div>
</div>

<!-- Station Creation Form -->
<div id="stationForm" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: white; border: 2px solid #444; padding: 1em;
	width: 300px; max-width: 30%; box-shadow: 0 0 10px rgba(0,0,0,0.3);
	display: none; z-index: 10000;">
	<h3>Create Station</h3>

        <label for="stationName">Name:</label>
        <input type="text" id="stationName" style="width: 100%;" />
        <br><br>
        <label for="stationDept">Department:</label>
        <input type="text" id="stationDept" style="width: 100%;" />
        <br><br>
        <label for="stationType">Type:</label>
        <select id="stationType" style="width: 100%;">
                <option value="fire">Fire</option>
		<option value="police">Police</option>
		<option value="ambulance">Ambulance</option>
	</select>
	<br><br>
	<button id="createStation">Create</button>
	<button onclick="document.getElementById('stationForm').style.display = 'none';">Cancel</button>
</div>

<!-- Unit Assignment Modal -->
<div id="assignPersonnelModal" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: white; border: 2px solid #444; padding: 1em;
	width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
	display: none; z-index: 10001;">
	<h3>Assign Personnel to Unit</h3>
	<div id="assignModalContent">Loading...</div>
	<button onclick="document.getElementById('assignPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Personnel Modal -->
<div id="editPersonnelModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001;">
        <h3>Edit Personnel</h3>
        <div id="editPersonnelContent">Loading...</div>
        <button onclick="document.getElementById('editPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Unit Modal -->
<div id="editUnitModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001;">
        <h3>Edit Unit</h3>
        <div id="editUnitContent">Loading...</div>
        <button onclick="document.getElementById('editUnitModal').style.display = 'none';">Close</button>
</div>

<!-- Unit Detail Modal -->
<div id="unitDetailModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001; max-height: 80vh; overflow-y: auto;">
        <h3>Unit Details</h3>
        <div id="unitDetailContent">Loading...</div>
        <button onclick="document.getElementById('unitDetailModal').style.display = 'none';">Close</button>
</div>

<div id="cadPopup" class="popup hidden">
  <h3 id="cadTitle"></h3>
  <p id="cadType"></p>
  <p id="cadRequired"></p>
  <button onclick="dispatchAuto()">Dispatch (Auto)</button>
  <button onclick="dispatchRecommended()">Dispatch (Recommended)</button>
  <button onclick="dispatchRunCard()">Dispatch (Run Card)</button>
  <button onclick="manualDispatch()">Manual Dispatch</button>
  <button onclick="closeCad()">Close</button>
</div>

<div id="stationDetails"></div>
<script src="/config/unitTypes.js"></script>
<script src="/config/trainings.js"></script>
<script src="/config/equipment.js"></script>

<script>
// ========= constants / helpers =========
const TRAVEL_SPEED = { fire: 50, police: 75, ambulance: 60 }; // km/h used across UI

function haversineKm(aLat, aLon, bLat, bLon) {
  const R = 6371;
  const dLat = (bLat - aLat) * Math.PI/180;
  const dLon = (bLon - aLon) * Math.PI/180;
  const la1 = aLat * Math.PI/180, la2 = bLat * Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

// Force-fresh GETs to avoid 304s when we need updated data
function fetchNoCache(url) {
  const sep = url.includes('?') ? '&' : '?';
  return fetch(`${url}${sep}t=${Date.now()}`, { cache: 'no-store' });
}

// Refresh a single station panel with fresh data (no cache)
async function refreshStationPanelNoCache(stationId) {
  const stations = await fetchNoCache('/api/stations').then(r=>r.json());
  cacheStations(stations);
  const st = stations.find(s => s.id === stationId);
  if (st) showStationDetails(st);
}

function makeIcon(url, size) {
  return L.divIcon({
    html: `<img src="${url}" style="width:100%;height:100%;object-fit:contain;object-position:center bottom;">`,
    iconSize: [size, size],
    iconAnchor: [size / 2, size],
    className: ''
  });
}

const missionIcons = {
  none: makeIcon("/warning1.png", 30),
  partial: makeIcon("/warning2.png", 30),
  complete: makeIcon("/warning3.png", 30)
};
const stationIcons = { fire: "/fire.png", police: "/police.png", ambulance: "/star.png", hospital: "/star.png", jail: "/police.png" };

let missionMarkers = [];
let stationMarkers = [];
let buildStationMode = false;
let pendingStationCoords = null;
let openMissionId = null;

const map = L.map("map").setView([47.5646, -52.7002], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "&copy; OpenStreetMap contributors" }).addTo(map);

document.getElementById("deleteAllStations").addEventListener("click", async () => {
  if (!confirm("Are you sure you want to delete ALL stations? This will also orphan units!")) return;
  await fetch("/api/stations", { method: "DELETE" });
  fetchStations();
  alert("All stations deleted.");
});

function getTrainingsForClass(cls) {
  const key = String(cls || '').trim().toLowerCase();
  if (typeof trainingsByClass !== 'undefined' && trainingsByClass && trainingsByClass[key]) {
    return trainingsByClass[key];
  }
  return [];
}

// Tabs
document.querySelectorAll(".tab-button").forEach(button => {
  button.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    button.classList.add("active");
    document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
  });
});

function unitIconFor(unit) {
  const url = unit.icon || stationIcons[unit.class] || stationIcons.fire;
  return makeIcon(url, 24);
}

function chooseMissionIcon(mission, assigned) {
  if (!Array.isArray(assigned) || assigned.length === 0) return missionIcons.none;
  const req = Array.isArray(mission.required_units) ? mission.required_units : [];
  const counts = {};
  for (const u of assigned) {
    counts[u.type] = (counts[u.type] || 0) + 1;
  }
  const allMet = req.every(r => (counts[r.type] || 0) >= (r.quantity ?? r.count ?? 1));
  return allMet ? missionIcons.complete : missionIcons.partial;
}

// caches
window._stationById = new Map();
window._unitById = new Map();

// registries
const unitMarkers = new Map(); // unitId -> { marker, animId }
const unitRoutes  = new Map(); // unitId -> L.Polyline

function clearUnitEta(){ /* hook for later, no-op now */ }

function cacheStations(stations){
  _stationById = new Map(stations.map(s => [s.id, { ...s, department: s.department ?? null }]));
}
function cacheUnits(units){ _unitById = new Map(units.map(u => [u.id, u])); }

function ensureUnitMarker(unit) {
  const st = _stationById.get(unit.station_id);
  if (!st) return null;
  let entry = unitMarkers.get(unit.id);
  if (!entry) {
    const icon = unitIconFor(unit);
    const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 })
      .addTo(map)
      .on('click', () => showUnitDetails(unit.id));
    entry = { marker, animId: null };
    unitMarkers.set(unit.id, entry);
  } else {
    entry.marker.setIcon(unitIconFor(unit));
  }
  return entry.marker;
}

function animateMoveUnit(unitId, from, to, durationMs, onDone) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;
  const start = performance.now();
  function step(now) {
    const t = Math.min(1, (now - start) / durationMs);
    const lat = from[0] + (to[0] - from[0]) * t;
    const lon = from[1] + (to[1] - from[1]) * t;
    marker.setLatLng([lat, lon]);
    if (t < 1) entry.animId = requestAnimationFrame(step);
    else { entry.animId = null; if (onDone) onDone(); }
  }
  entry.animId = requestAnimationFrame(step);
}

// helpers for resume
function cumulative(segDurations){ const out=[0]; for(let i=0;i<segDurations.length;i++) out.push(out[i]+segDurations[i]); return out; }
function segmentAtElapsed(segDurations, elapsedSec){
  const cum = cumulative(segDurations);
  const total = cum[cum.length-1];
  const e = Math.max(0, Math.min(elapsedSec, total));
  let i=0; while(i<segDurations.length && e>cum[i+1]) i++;
  const segElapsed = e - cum[i];
  const segDur = Math.max(0.001, segDurations[i] || 0.001);
  const t = segElapsed / segDur;
  return { index: i, t, total };
}

function animateAlongRouteOffset(unitId, coords, segDurations, onDone, startOffsetSec = 0) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;

  const { index: startIdx, t: t0 } = segmentAtElapsed(segDurations, startOffsetSec);
  let segIdx = startIdx;
  let segRemainingMs = (1 - t0) * Math.max(1, (segDurations[segIdx] || 0.001)) * 1000;

  const placeAt = (idx, t) => {
    const a = coords[idx], b = coords[idx+1] || coords[idx];
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);
  };
  placeAt(segIdx, t0);

  let segStart = performance.now();
  let segEnd   = segStart + segRemainingMs;

  function step(now) {
    if (segIdx >= segDurations.length || segIdx >= coords.length - 1) {
      if (onDone) onDone();
      entry.animId = null;
      return;
    }
    const a = coords[segIdx], b = coords[segIdx+1];
    const t = Math.min(1, (now - segStart) / (segEnd - segStart));
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);

    if (t >= 1) {
      segIdx++;
      if (segIdx < segDurations.length && segIdx < coords.length - 1) {
        segStart = now;
        segEnd   = segStart + Math.max(1, segDurations[segIdx]) * 1000;
      }
    }
    entry.animId = requestAnimationFrame(step);
  }
  entry.animId = requestAnimationFrame(step);
}

// OSRM fetch
async function fetchRouteOSRM(from, to) {
  const url = `https://router.project-osrm.org/route/v1/driving/${from[1]},${from[0]};${to[1]},${to[0]}?overview=full&geometries=geojson&annotations=duration,distance&steps=false`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`OSRM ${res.status}`);
  const json = await res.json();
  if (!json.routes?.length) throw new Error('No route');
  const route = json.routes[0];
  const coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
  const duration = route.duration;
  const annotations = route.legs?.[0]?.annotation || null;
  return { coords, duration, annotations };
}

function drawRoute(unitId, coords) {
  try {
    const existing = unitRoutes.get(unitId);
    if (existing) { map.removeLayer(existing); unitRoutes.delete(unitId); }
    const poly = L.polyline(coords, { weight: 3, opacity: 0.35 });
    poly.addTo(map);
    unitRoutes.set(unitId, poly);
  } catch {}
}

async function routeAndAnimateUnit(unitId, from, to, speedClassKmh, onArrive, resumeOpts) {
  try {
    // Resume with saved travel (from backend)
    if (resumeOpts?.saved) {
      const { coords, seg_durations, started_at } = resumeOpts.saved;
      drawRoute(unitId, coords);
      const u = _unitById.get(unitId) || { id: unitId, class: 'fire', station_id: 0 };
      ensureUnitMarker(u);
      const elapsedSec = Math.max(0, (Date.now() - new Date(started_at).getTime()) / 1000);
      animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, elapsedSec);
      return;
    }

    // Fresh route
    const { coords, duration, annotations } = await fetchRouteOSRM(from, to);
    const seg_durations = (annotations?.duration?.length === coords.length - 1)
      ? annotations.duration
      : Array.from({ length: coords.length - 1 }, () => duration / Math.max(1, coords.length - 1));

    // Light “emergency” multiplier
    const speedMultiplier = { fire: 1.2, police: 1.3, ambulance: 1.25 };
    const u = _unitById.get(unitId);
    const mult = u ? (speedMultiplier[u.class] || 1.0) : 1.0;
    const adjustedTotal = Math.max(5, duration / mult);

    // Persist to backend so we can resume on refresh
    try {
      await fetch('/api/unit-travel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          unit_id: unitId,
          mission_id: resumeOpts?.mission_id,
          phase: resumeOpts?.phase || 'to_scene',
          started_at: new Date().toISOString(),
          from, to,
          coords,
          seg_durations,
          total_duration: adjustedTotal
        })
      });
    } catch (e) { console.warn('Failed to persist travel:', e); }

    drawRoute(unitId, coords);
    ensureUnitMarker(u || { id: unitId, station_id: 0, class: 'fire' });
    animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, 0);
  } catch (err) {
    console.warn('OSRM route failed; straight-line fallback:', err);
    const R = 6371;
    const dLat = (to[0]-from[0]) * Math.PI/180, dLon = (to[1]-to[0]) * Math.PI/180;
    const la1 = from[0] * Math.PI/180, la2 = to[0] * Math.PI/180;
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    const distKm = 2*R*Math.asin(Math.sqrt(h));
    const etaSec = Math.max(5, Math.round((distKm / (speedClassKmh || 45)) * 3600));
    animateMoveUnit(unitId, from, to, etaSec * 1000, onArrive);
  }
}

let missionTemplates = [];
fetch('/api/mission-templates')
  .then(r => r.json())
  .then(data => { missionTemplates = data; })
  .catch(err => console.error('Failed to load mission templates:', err));

// UI helpers
function closeModal(){ const m = document.querySelector(".modal-overlay"); if (m) m.remove(); }

async function fetchMissions() {
  try {
    const res = await fetch("/api/missions");
    let missions = await res.json();

    // Remove resolved missions from display
    missions = missions.filter(m => m.status !== 'resolved');

    missionMarkers.forEach(m => map.removeLayer(m));
    missionMarkers = [];

    const missionList = document.getElementById("missionList");
    missionList.innerHTML = "";

    const valid = missions.filter(m => Number.isFinite(m.lat) && Number.isFinite(m.lon));
    const assignedList = await Promise.all(
      valid.map(m => fetch(`/api/missions/${m.id}/units`).then(r => r.json()).catch(() => []))
    );
    for (let i = 0; i < valid.length; i++) {
      const m = valid[i];
      const assigned = assignedList[i];
      const marker = L.marker([m.lat, m.lon], { icon: chooseMissionIcon(m, assigned) })
        .addTo(map)
        .on("click", () => showMissionDetails(m));

      missionMarkers.push(marker);

      const el = document.createElement("div");
      el.className = "mission";
      el.innerHTML = `
        <strong class="focus-mission" data-lat="${m.lat}" data-lon="${m.lon}" style="cursor:pointer;">${m.type}</strong>
        <button onclick='showMissionDetails(${JSON.stringify(m)})' style="margin-left:8px;">Details</button><br>
        Lat: ${m.lat.toFixed(4)}<br>Lon: ${m.lon.toFixed(4)}<br>`;
      missionList.appendChild(el);
    }
  } catch (err) {
    console.error("Failed to fetch missions:", err);
  }
}

async function generateMissionAtPOI(poi) {
  const res = await fetch('/api/random-mission');
  const mission = await res.json();
  const { name, required_units } = mission;
  document.getElementById("cadTitle").textContent = name;
  document.getElementById("cadType").textContent = `POI: ${poi.tags.amenity || poi.tags.name}`;
  document.getElementById("cadRequired").textContent = required_units.map(r => `${r.count}x ${r.type}`).join(', ');
  document.getElementById("cadPopup").classList.remove('hidden');
  window.currentMission = mission;
}

// ===== Station list / details =====
async function fetchStations() {
  const res = await fetch("/api/stations");
  const stations = await res.json();
  cacheStations(stations);
  stationMarkers.forEach(m => map.removeLayer(m));
  stationMarkers = [];
  const list = document.getElementById("stationList");
  list.innerHTML = "";

  const unitCounts = await Promise.all(
    stations.map(st => {
      if (st.type === 'hospital' || st.type === 'jail') return 0;
      return fetch(`/api/units?station_id=${st.id}`)
        .then(r=>r.json()).then(arr=>arr.length).catch(()=>0);
    })
  );

  stations.forEach((st, idx) => {
    const used = unitCounts[idx];
    const free = (st.bay_count || 0) - used;
    const iconUrl = st.icon || stationIcons[st.type] || stationIcons.fire;
    const icon = makeIcon(iconUrl, 30);
    const marker = L.marker([st.lat, st.lon], { icon }).addTo(map).on("click", () => showStationDetails(st));
    stationMarkers.push(marker);
    const el = document.createElement("div");
    let info = '';
    if (st.type === 'hospital') {
      const occ = Number(st.occupied_beds || 0);
      const cap = Number(st.bed_capacity || 0);
      info = `Beds: ${occ}/${cap} (Free: ${cap - occ})`;
    } else if (st.type === 'jail' || (st.type === 'police' && Number(st.holding_cells) > 0)) {
      const occ = Number(st.occupied_cells || 0);
      const cap = Number(st.holding_cells || 0);
      info = `Cells: ${occ}/${cap} (Free: ${cap - occ})`;
      if (st.type === 'police') {
        info += `<br>Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
      }
    } else {
      info = `Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
    }
    el.innerHTML = `<strong class="focus-station" data-lat="${st.lat}" data-lon="${st.lon}" style="cursor:pointer;">${st.name}</strong><br>Type: ${st.type}<br>Department: ${st.department || ''}<br>${info}<br>
      <button onclick='showStationDetails(${JSON.stringify(st)})'>Details</button>`;
    list.appendChild(el);
  });
}

async function refreshAssignedUnitsUI(missionId) {
  const div = document.getElementById('assignedUnitsArea');
  if (!div) return [];
  try {
    div.innerHTML = 'Loading assigned units…';
    const res = await fetch(`/api/missions/${missionId}/units`);
    const assigned = await res.json();
    (assigned||[]).forEach(u => _unitById.set(u.id, u));
    if (!Array.isArray(assigned) || !assigned.length) {
      div.innerHTML = '<em>No units assigned yet.</em>';
      return [];
    }
    div.innerHTML = `
      <strong>Assigned Units:</strong>
      <ul style="list-style:none; padding-left:0;">
        ${assigned.map(u => `
          <li style="display:flex; align-items:center; gap:6px; margin:4px 0;">
            <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer; color:blue;">${u.name}</span> (${u.type}) — ${u.status || 'enroute'}
            <button data-unitid="${u.id}" data-missionid="${missionId}" class="clear-unit-btn">Clear</button>
          </li>
        `).join('')}
      </ul>`;
    div.querySelectorAll('.unit-link').forEach(span => {
      span.addEventListener('click', () => showUnitDetails(parseInt(span.dataset.unitid,10)));
    });
    div.querySelectorAll('.clear-unit-btn').forEach(btn => {
      btn.onclick = async () => {
        btn.disabled = true;
        try { await clearAssignedUnit(parseInt(btn.dataset.missionid,10), parseInt(btn.dataset.unitid,10)); }
        finally { btn.disabled = false; }
      };
    });
    return assigned;
  } catch (e) {
    console.error(e);
    div.innerHTML = '<span style="color:#b00;">Failed to load assigned units.</span>';
    return [];
  }
}

// ===== Dynamic requirements =====
function renderRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.required_units) ? mission.required_units : [];
  if (!req.length) return '<em>No specific unit requirements.</em>';
  const counts = { enroute: new Map(), onscene: new Map() };
  for (const u of assigned || []) {
    if (u.status === 'onscene') counts.onscene.set(u.type, (counts.onscene.get(u.type)||0)+1);
    else if (u.status === 'enroute') counts.enroute.set(u.type, (counts.enroute.get(u.type)||0)+1);
  }
  const items = req.map(r => {
    const need = r.quantity ?? r.count ?? 1;
    const onscene = counts.onscene.get(r.type) || 0;
    const enroute = counts.enroute.get(r.type) || 0;
    const outstanding = Math.max(0, need - enroute - onscene);
    return `<li>${need} × ${r.type} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onscene})</small></li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderTrainingRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.required_training) ? mission.required_training : [];
  if (!req.length) return '';
  const counts = { enroute: new Map(), onscene: new Map() };
  for (const u of assigned || []) {
    const target = u.status === 'onscene' ? counts.onscene : (u.status === 'enroute' ? counts.enroute : null);
    if (!target) continue;
    for (const p of Array.isArray(u.personnel) ? u.personnel : []) {
      for (const t of Array.isArray(p.training) ? p.training : []) {
        target.set(t, (target.get(t) || 0) + 1);
      }
    }
  }
  const items = req.map(r => {
    const need = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.training || r.name || r;
    const onscene = counts.onscene.get(name) || 0;
    const enroute = counts.enroute.get(name) || 0;
    const outstanding = Math.max(0, need - enroute - onscene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onscene})</small></li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderEquipmentRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.equipment_required) ? mission.equipment_required : [];
  if (!req.length) return '';
  const counts = { enroute: new Map(), onscene: new Map() };
  for (const u of assigned || []) {
    const target = u.status === 'onscene' ? counts.onscene : (u.status === 'enroute' ? counts.enroute : null);
    if (!target) continue;
    for (const e of Array.isArray(u.equipment) ? u.equipment : []) {
      target.set(e, (target.get(e) || 0) + 1);
    }
  }
  const items = req.map(r => {
    const need = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.name || r.type || r;
    const onscene = counts.onscene.get(name) || 0;
    const enroute = counts.enroute.get(name) || 0;
    const outstanding = Math.max(0, need - enroute - onscene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onscene})</small></li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderPatientInfo(mission) {
  const pts = Array.isArray(mission.patients) ? mission.patients : [];
  if (!pts.length) return '';
  const items = pts.map(p => {
    if (typeof p.count === 'number') {
      const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
      const parts = [String(p.count)];
      if (codes) parts.push(`Codes: ${codes}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (codes) parts.push(`Codes: ${codes}`);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderPrisonerInfo(mission) {
  const prs = Array.isArray(mission.prisoners) ? mission.prisoners : [];
  if (!prs.length) return '';
  const items = prs.map(p => {
    if (typeof p.count === 'number') {
      const parts = [String(p.count)];
      if (Number.isFinite(p.transport)) parts.push(`Transport: ${p.transport}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const transport = Number.isFinite(p.transportChance) ? `Transport: ${Math.round(p.transportChance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (transport) parts.push(transport);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

// ===== Mission details =====
function showMissionDetails(mission) {
  openMissionId = mission.id;
  const container = document.getElementById("missionDetailsContent");
  const patientHtml = renderPatientInfo(mission);
  const prisonerHtml = renderPrisonerInfo(mission);
  const hasTraining = Array.isArray(mission.required_training) && mission.required_training.length;
  const hasEquipment = Array.isArray(mission.equipment_required) && mission.equipment_required.length;
  container.innerHTML = `
    <h3>${mission.type}</h3>
    <p><strong>Status:</strong> ${mission.status}</p>
    <p><strong>Unit Requirements:</strong></p>
    <div id="reqDynamic">Loading…</div>
    ${hasTraining ? '<p><strong>Personnel Requirements:</strong></p><div id="reqTrainingDynamic">Loading…</div>' : ''}
    ${hasEquipment ? '<p><strong>Equipment Required:</strong></p><div id="reqEquipmentDynamic">Loading…</div>' : ''}
    ${patientHtml ? '<p><strong>Patients:</strong></p>' + patientHtml : ''}
    ${prisonerHtml ? '<p><strong>Prisoners:</strong></p>' + prisonerHtml : ''}
    <div id="assignedUnitsArea" style="margin-top:8px;"></div>
    <div style="margin-top:10px;"><button id="manualDispatchBtn">Manual Dispatch</button> <button id="autoDispatchBtn">Auto Dispatch</button> <button id="runCardDispatchBtn">Run Card Dispatch</button></div>
    <div id="manualDispatchArea" style="margin-top:8px;"></div>
    <div id="missionTimerArea" style="margin-top:8px;"></div>
  `;
  document.getElementById('manualDispatchBtn').onclick = () => openManualDispatch(mission);
  document.getElementById('autoDispatchBtn').onclick = () => autoDispatch(mission);
  document.getElementById('runCardDispatchBtn').onclick = () => runCardDispatch(mission);
  refreshAssignedUnitsUI(mission.id).then(assigned => {
    const reqDiv = document.getElementById('reqDynamic');
    if (reqDiv) reqDiv.innerHTML = renderRequirementsDynamic(mission, assigned);
    const trainDiv = document.getElementById('reqTrainingDynamic');
    if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(mission, assigned);
    const equipDiv = document.getElementById('reqEquipmentDynamic');
    if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(mission, assigned);
  });
  document.getElementById("missionDetails").style.display = "block";
  const active = activeWorkTimers.get(mission.id);
  if (active && active.endTime) {
    startMissionCountdown(mission.id, active.endTime);
  } else {
    const t = document.getElementById('missionTimerArea');
    if (t) t.textContent = '';
  }
}

function closeMissionDetails() {
  document.getElementById('missionDetails').style.display = 'none';
  openMissionId = null;
}

// ===== Station details =====
async function showStationDetails(station) {
  station = await fetchNoCache(`/api/stations/${station.id}`).then(r=>r.json());
  const detail = document.getElementById('stationDetails');
  window.currentStation = station;
  if (station.type === 'hospital' || station.type === 'jail') {
    const isHospital = station.type === 'hospital';
    const occ = isHospital ? Number(station.occupied_beds || 0) : Number(station.occupied_cells || 0);
    const cap = isHospital ? Number(station.bed_capacity || 0) : Number(station.holding_cells || 0);
    detail.innerHTML = `
      <div style="text-align:right;">
        <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
      </div>
      <h2>${station.name}</h2>
          <button id="change-station-icon">Change Icon</button>
      <p>Type: ${station.type}</p>

      <p>Department: ${station.department || ''}</p>
      <div>${isHospital ? 'Beds' : 'Holding Cells'}: ${occ}/${cap} (Free: ${cap - occ})</div>
    `;
	  const iconBtn = detail.querySelector('#change-station-icon');
      iconBtn?.addEventListener('click', async () => {
      const url = prompt('Enter icon URL:');
      if (!url) return;
      const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
      const data = await res.json();
      if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
      station.icon = url;
      _stationById.set(station.id, station);
      fetchStations();
      showStationDetails(station);
    });
    return;
  }
  const res = await fetchNoCache(`/api/units?station_id=${station.id}`);
  const units = await res.json();
  units.forEach(u => _unitById.set(u.id, u));
  const unitOptions = unitTypes.filter(u=>u.class===station.type).map(u=>`<option value="${u.type}">${u.type}</option>`).join('');
  const usedBays = units.length;
  const freeBays = (station.bay_count || 0) - usedBays;
  const equipOptions = (equipment[station.type] || []).map(e=>{
    const name = typeof e === 'string' ? e : e.name;
    const cost = typeof e === 'object' && e.cost ? e.cost : 0;
    return `<option value="${name}" data-cost="${cost}">${name}${cost?` ($${cost})`:''}</option>`;
  }).join('');
  const stationEquip = Array.isArray(station.equipment) ? station.equipment : [];
  const holdingInfo = (station.type === 'police' && Number(station.holding_cells) > 0)
    ? `<div id="holding-info">Holding Cells: ${Number(station.occupied_cells || 0)}/${Number(station.holding_cells || 0)} (Free: ${Number(station.holding_cells || 0) - Number(station.occupied_cells || 0)})</div>`
    : '';
  detail.innerHTML = `
    <div style="text-align:right;">
      <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
    </div>
    <h2>${station.name}</h2>
        <button id="change-station-icon">Change Icon</button>
    <p>Type: ${station.type}</p>
    <p>Department: ${station.department || ''}</p>
    <h3>Create Unit</h3>
    <select id="unit-type">${unitOptions}</select>
    <input id="unit-name" placeholder="Unit name (e.g., Ladder 1)" />
    <button id="create-unit">Create Unit</button>
    <h3>Add Personnel</h3>
    <input id="personnel-name" placeholder="Name (e.g., John Doe)" />
    <div id="personnel-training">
      ${
        (getTrainingsForClass(station.type).length
          ? getTrainingsForClass(station.type)
          : [{ name: 'general', cost: 0 }]
        ).map((t,idx)=>{
          const name = typeof t === 'string' ? t : t.name;
          const cost = typeof t === 'object' && t.cost ? t.cost : 0;
          return `<label><input type="checkbox" value="${name}" data-cost="${cost}" ${idx===0?"checked":""}/> ${name}${cost?` ($${cost})`:''}</label><br>`;
        }).join('')
      }
    </div>
    <div id="personnel-cost"></div>
    <div id="bay-info">Bays: ${usedBays}/${station.bay_count || 0} (Free: ${freeBays})</div>
    ${holdingInfo}
    <div>
      <label>Add bays:
        <input id="add-bays-count" type="number" min="1" value="1">
      </label>
      <button id="add-bays-btn">Add Bays</button>
    </div>
    <h3>Station Equipment</h3>
    <div id="station-equipment-display">
      ${stationEquip.length ? `<ul>${stationEquip.map(e=>`<li>${e}</li>`).join('')}</ul>` : '<em>No equipment</em>'}
    </div>
    <div>
      <select id="equipment-buy">${equipOptions}</select>
      <button id="buy-equipment-btn">Buy</button>
    </div>
    <button id="create-personnel">Add Personnel</button>
    <h3>Personnel</h3>
    <ul id="personnel-list"></ul>
    <h3>Assigned Units</h3>
    <ul id="unit-list">
      ${units.map(u=>`
        <li>
          <strong style="cursor:pointer; color:blue;" onclick="showUnitDetails(${u.id})">${u.name}</strong> (${u.type}) - ${u.status}
          <button onclick="openAssignModal(${u.id}, ${station.id})">Assign</button>
          ${u.status !== 'available' ? `<button onclick="cancelUnit(${u.id}, ${station.id})">Cancel</button>` : ''}
          <button class="edit-unit-btn" data-unitid="${u.id}">Edit</button>
        </li>`).join('')}
    </ul>`;
	  const iconBtn = detail.querySelector('#change-station-icon');
	  iconBtn?.addEventListener('click', async () => {
		const url = prompt('Enter icon URL:');
		if (!url) return;
		const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
		const data = await res.json();
		if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
		station.icon = url;
		_stationById.set(station.id, station);
		fetchStations();
		showStationDetails(station);
	  });
        async function refreshBayInfo(stationId) {
          const [s, us] = await Promise.all([
            fetch(`/api/stations/${stationId}`, { cache: 'no-store' }).then(r=>r.json()),
            fetch(`/api/units?station_id=${stationId}`, { cache: 'no-store' }).then(r=>r.json())
          ]);
          const used = Array.isArray(us) ? us.length : 0;
          const el = document.getElementById('bay-info');
          el.textContent = `Bays: ${used}/${s.bay_count} (Free: ${s.bay_count - used})`;
          if (s.type === 'police' && Number(s.holding_cells) > 0) {
            const hc = document.getElementById('holding-info');
            if (hc) hc.textContent = `Holding Cells: ${Number(s.occupied_cells||0)}/${Number(s.holding_cells||0)} (Free: ${Number(s.holding_cells||0) - Number(s.occupied_cells||0)})`;
          }
        }

        const BASE_PERSON_COST = 100;
        function updatePersonnelCost() {
          const selected = Array.from(detail.querySelectorAll('#personnel-training input[type=checkbox]:checked'));
          const cost = selected.reduce((sum, cb) => sum + Number(cb.dataset.cost || 0), BASE_PERSON_COST);
          const el = detail.querySelector('#personnel-cost');
          if (el) el.textContent = `Cost: $${cost}`;
          return cost;
        }
        detail.querySelectorAll('#personnel-training input[type=checkbox]').forEach(cb => cb.addEventListener('change', updatePersonnelCost));
        updatePersonnelCost();

        document.getElementById('add-bays-btn')?.addEventListener('click', async () => {
          const n = Number(document.getElementById('add-bays-count').value || 1);
          const stationId = station.id;
          const res = await fetch(`/api/stations/${stationId}/bays`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ add: n })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
                alert(`Failed: ${data.error || res.statusText}`);
                return;
          }
          alert(`Added ${data.added} bay(s). Cost: $${data.cost}`);
          refreshBayInfo(stationId);
          refreshWallet();
        });
        document.getElementById('buy-equipment-btn')?.addEventListener('click', async () => {
          const sel = document.getElementById('equipment-buy');
          const name = sel.value;
          const res = await fetch(`/api/stations/${station.id}/equipment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
            alert(`Failed: ${data.error || res.statusText}`);
            return;
          }
          alert(`Purchased ${name} for $${data.cost}`);
          refreshWallet();
          refreshStationPanelNoCache(station.id);
        });
  // Replace inline openAssignModal with safe listeners
        detail.querySelectorAll('button').forEach(btn => {
          const m = btn.getAttribute('onclick');
          if (m && m.startsWith('openAssignModal(')) {
                btn.removeAttribute('onclick');
                const args = m.match(/openAssignModal\((\d+),\s*(\d+)\)/);
                if (args) {
                  const [_, unitId, stationId] = args.map(Number);
                  btn.addEventListener('click', () => openAssignModal(unitId, stationId));
                }
          }
        });

        // Hook up unit edit buttons
        detail.querySelectorAll('.edit-unit-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = parseInt(btn.dataset.unitid, 10);
            const u = _unitById.get(id);
            if (u) openUnitModal(u);
          });
        });

        // Replace inline editPersonnel with safe listener
        detail.querySelectorAll('#personnel-list button').forEach(btn => {
	  const m = btn.getAttribute('onclick');
	  if (m && m.startsWith('editPersonnel(')) {
		btn.removeAttribute('onclick');
		const id = parseInt(m.match(/editPersonnel\((\d+)\)/)[1], 10);
		btn.addEventListener('click', () => window.editPersonnel(id));
	  }
	});
	window.editPersonnel = editPersonnel;

  // ==== Edit Personnel Modal (prefill + robust save) ====
	function openPersonnelModal(person) {
	  const modal = document.getElementById('editPersonnelModal');
	  const content = document.getElementById('editPersonnelContent');

	  const st = station || window.currentStation || {};
	  const availableTrainings = getTrainingsForClass(st.type);

	  const currentName = (person && person.name) ? person.name : '';
	  const currentTraining = Array.isArray(person?.training) ? person.training : [];
	  const curSet = new Set(currentTraining.map(t => String(t).toLowerCase()));

	  content.innerHTML = `
		<div style="display:flex; flex-direction:column; gap:10px;">
		  <label>
			<div>Name</div>
			<input id="edit-personnel-name" type="text" style="width:100%;" value="${currentName.replace(/"/g, '&quot;')}" />
		  </label>

		  <div>
			<div>Training</div>
			<div id="edit-training-list" style="max-height:160px; overflow:auto; padding:6px; border:1px solid #ddd; border-radius:6px;">
                            ${
                                  availableTrainings.length
                                    ? availableTrainings.map(t => {
                                            const name = typeof t === 'string' ? t : t.name;
                                            const checked = curSet.has(String(name).toLowerCase()) ? 'checked' : '';
                                            return `<label style="display:block;"><input type="checkbox" value="${name}" ${checked}> ${name}</label>`;
                                          }).join('')
                                    : '<em>No training list available for this station type.</em>'
                            }
			</div>
		  </div>

		  <div style="display:flex; gap:8px; justify-content:flex-end;">
			<button id="edit-personnel-cancel" type="button">Cancel</button>
			<button id="edit-personnel-save" type="button" style="background:#0b5; color:#fff;">Save</button>
		  </div>
		</div>
	  `;

	  // Wire buttons
	  content.querySelector('#edit-personnel-cancel').onclick = () => { modal.style.display = 'none'; };

	  content.querySelector('#edit-personnel-save').onclick = async () => {
	    const nameEl = content.querySelector('#edit-personnel-name');
	    const name = (nameEl?.value || '').trim();

	    const selectedTrainings = Array.from(
		  content.querySelectorAll('#edit-training-list input[type=checkbox]:checked')
	    ).map(cb => cb.value);

      // Build a payload that many backends accept
      const payload = {
        id: person.id,
        station_id: (station && station.id) || person.station_id,
        name,
        training: selectedTrainings
      };
      const urlBase = `/api/personnel/${person.id}`;

      // Try common update styles until one succeeds
      const attempts = [
        { method: 'PATCH', url: urlBase, body: payload },
        { method: 'PUT',   url: urlBase, body: payload },
        { method: 'POST',  url: `${urlBase}?_method=PATCH`, body: payload },
        { method: 'POST',  url: `${urlBase}?_method=PUT`,   body: payload },
        { method: 'POST',  url: urlBase, body: payload, headers: { 'X-HTTP-Method-Override': 'PATCH' } },
        { method: 'POST',  url: urlBase, body: payload, headers: { 'X-HTTP-Method-Override': 'PUT' } },
        { method: 'POST',  url: `/api/personnel/update`, body: payload },
      ];

      let ok = false, lastStatus = 0, lastText = '';
      for (const a of attempts) {
        try {
          const res = await fetch(a.url, {
            method: a.method,
            headers: { 'Content-Type': 'application/json', ...(a.headers || {}) },
            body: JSON.stringify(a.body),
            cache: 'no-store'
          });
          lastStatus = res.status;
          lastText = await res.text().catch(()=>'');

          if (res.ok || [200,201,202,204].includes(res.status)) {
            ok = true;
            console.log(`[save] Success via ${a.method} ${a.url} — status ${res.status}`, lastText.slice(0,120));
            break;
          } else {
            console.warn(`[save] Failed via ${a.method} ${a.url} — status ${res.status}`, lastText.slice(0,120));
          }
        } catch (e) {
          lastText = e?.message || String(e);
          console.warn(`[save] Network error via ${a.method} ${a.url}:`, lastText);
        }
      }

      if (!ok) {
        alert(`Failed to save personnel changes.\nLast response (${lastStatus}): ${lastText}`);
        return;
      }

      // Close and refresh the station panel with uncached GETs
      modal.style.display = 'none';
      await refreshStationPanelNoCache(station.id);
	  };

    modal.style.display = 'block';
	}

	// expose globally for inline paths
        window.openPersonnelModal = openPersonnelModal;

        function editPersonnel(id) {
          fetch(`/api/personnel/${id}`)
                .then(res => res.json())
                .then(person => {
                  openPersonnelModal(person);
                });
        }

  document.getElementById('create-unit').addEventListener('click', async ()=>{
    const type = document.getElementById('unit-type').value;
    const name = document.getElementById('unit-name').value;
    if (!type || !name) return alert("Missing name or type");
    await fetch('/api/units',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({station_id:station.id,class:station.type,type,name})});
    showStationDetails(station);
  });
  document.getElementById('create-personnel').addEventListener('click', async ()=>{
    const name = document.getElementById('personnel-name').value;
    const training = Array.from(document.querySelectorAll('#personnel-training input[type=checkbox]:checked')).map(cb=>cb.value);
    if (!name) return alert("Missing name");
    const res = await fetch('/api/personnel',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({ name, station_id: station.id, training })});
    const data = await res.json();
    if (!res.ok) { alert(`Failed: ${data.error || res.statusText}`); return; }
    alert(`Personnel added. Cost: $${data.charged}`);
    refreshWallet();
    showStationDetails(station);
  });

  // Load personnel (no-cache so edits show immediately)
  const personnel = await fetchNoCache(`/api/personnel?station_id=${station.id}`).then(r=>r.json());
  const personnelList = document.getElementById("personnel-list");
  personnelList.innerHTML = '';
  personnel.forEach(p=>{
    const li = document.createElement("li");
    const trainings = (p.training || []).map(t => typeof t === 'string' ? t : t.name).join(', ');
    li.innerHTML = `<strong>${p.name}</strong> (${trainings}) <button onclick="editPersonnel(${p.id})" style="margin-left:10px;">Edit</button>`;
    personnelList.appendChild(li);
  });

  refreshBayInfo(station.id);
}

// ==== Edit Unit Modal ====
function openUnitModal(unit) {
  const modal = document.getElementById('editUnitModal');
  const content = document.getElementById('editUnitContent');
  const currentName = unit?.name || '';

  content.innerHTML = `
    <div style="display:flex; flex-direction:column; gap:10px;">
      <label>
        <div>Name</div>
        <input id="edit-unit-name" type="text" style="width:100%;" value="${currentName.replace(/"/g,'&quot;')}" />
      </label>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="edit-unit-cancel" type="button">Cancel</button>
        <button id="edit-unit-save" type="button" style="background:#0b5; color:#fff;">Save</button>
      </div>
    </div>`;

  content.querySelector('#edit-unit-cancel').onclick = () => { modal.style.display = 'none'; };

  content.querySelector('#edit-unit-save').onclick = async () => {
    const nameEl = content.querySelector('#edit-unit-name');
    const name = (nameEl?.value || '').trim();
    const payload = { name };
    const urlBase = `/api/units/${unit.id}`;
    const attempts = [
      { method:'PATCH', url:urlBase, body:payload },
      { method:'PUT', url:urlBase, body:payload },
      { method:'POST', url:`${urlBase}?_method=PATCH`, body:payload },
      { method:'POST', url:`${urlBase}?_method=PUT`, body:payload },
      { method:'POST', url:urlBase, body:payload, headers:{'X-HTTP-Method-Override':'PATCH'} },
      { method:'POST', url:urlBase, body:payload, headers:{'X-HTTP-Method-Override':'PUT'} },
      { method:'POST', url:'/api/units/update', body:{ id:unit.id, ...payload } }
    ];
    let ok=false,lastStatus=0,lastText='';
    for(const a of attempts){
      try{
        const res=await fetch(a.url,{method:a.method,headers:{'Content-Type':'application/json',...(a.headers||{})},body:JSON.stringify(a.body),cache:'no-store'});
        lastStatus=res.status; lastText=await res.text().catch(()=> '');
        if(res.ok||[200,201,202,204].includes(res.status)){ ok=true; break; }
      }catch(e){ lastText=e?.message||String(e); }
    }
    if(!ok){ alert(`Failed to save unit changes.\nLast response (${lastStatus}): ${lastText}`); return; }
    modal.style.display='none';
    await refreshStationPanelNoCache(unit.station_id);
  };

  modal.style.display = 'block';
}

function editUnit(id){
  const u=_unitById.get(id);
  if(u) openUnitModal(u);
}
window.editUnit = editUnit;

// Build station
document.getElementById("buildStation").addEventListener("click", () => { buildStationMode = true; alert("Click the map to place your new station"); });
map.on("click", async (e) => {
  if (!buildStationMode) return;
  const name = prompt("Station Name?");
  const type = prompt("Type (fire, police, ambulance, hospital, jail)?", "fire")?.toLowerCase();
  const department = prompt("Department?") || null;
  if (!name || !["fire","police","ambulance","hospital","jail"].includes(type)) { alert("Cancelled or invalid type."); buildStationMode=false; return; }
  let holding_cells = 0, beds = 0;
  if (type === "police" || type === "jail") {
    holding_cells = Number(prompt("Holding cells?", "0")) || 0;
  }
  if (type === "hospital") {
    beds = Number(prompt("Beds?", "0")) || 0;
  }
  await fetch("/api/stations", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ name, type, department, lat:e.latlng.lat, lon:e.latlng.lng, holding_cells, beds }) });
  buildStationMode = false;
  pendingStationCoords = null;
  fetchStations();
});

function randomCount({min=0, max=0, chance=1}) {
  min = Math.floor(min); max = Math.floor(max);
  if (max <= min) return min;
  if (Math.random() < chance) return max;
  return min + Math.floor(Math.random() * (max - min));
}

function instantiatePatients(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    return { count, codes: p.codes };
  }).filter(p => p.count > 0);
}

function instantiatePrisoners(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    const transportChance = Number(p.transportChance) || 0;
    let transport = 0;
    for (let i = 0; i < count; i++) {
      if (Math.random() < transportChance) transport++;
    }
    return { count, transport };
  }).filter(p => p.count > 0);
}

// Generate Mission
document.getElementById('generateMission').addEventListener('click', async ()=>{
  if (missionTemplates.length===0) { alert("No mission templates loaded."); return; }
  const stations = await fetch('/api/stations').then(r=>r.json()).catch(()=>[]);
  if (!stations.length) { alert("No stations available."); return; }
  const st = stations[Math.floor(Math.random()*stations.length)];
  const radius = 5000; // meters
  const dist = Math.random()*radius;
  const angle = Math.random()*2*Math.PI;
  const dx = dist * Math.cos(angle);
  const dy = dist * Math.sin(angle);
  const lat = st.lat + (dy / 111320);
  const lon = st.lon + (dx / (111320 * Math.cos(st.lat * Math.PI/180)));
  const template = missionTemplates[Math.floor(Math.random()*missionTemplates.length)];
  const missionData = {
    type: template.name, lat, lon,
    required_units: template.required_units,
    required_training: template.required_training || [],
    equipment_required: template.equipment_required || [],
    patients: instantiatePatients(template.patients),
    prisoners: instantiatePrisoners(template.prisoners),
    modifiers: template.modifiers || [],
    timing: template.timing ?? 10
  };
  try {
    const res = await fetch('/api/missions',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(missionData)});
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    await fetchMissions();
  } catch (err) { console.error("Failed to create mission:", err); alert("Failed to create mission."); }
});

// Clear Missions
document.getElementById("clearMissions").addEventListener("click", async ()=>{
  if (!confirm("Clear ALL missions?")) return;
  await fetch("/api/missions", { method:"DELETE" });
  fetchMissions();
});

// Focus
document.addEventListener("click", (e)=>{
  if (e.target.classList.contains("focus-mission") || e.target.classList.contains("focus-station")) {
    const lat = parseFloat(e.target.dataset.lat);
    const lon = parseFloat(e.target.dataset.lon);
    map.setView([lat, lon], 16);
  }
});

// Assign personnel modal
async function openAssignModal(unitId, stationId) {
  const modal = document.getElementById("assignPersonnelModal");
  const content = document.getElementById("assignModalContent");

  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();

  const unassigned = personnel.filter(p => !p.unit_id);

  if (!unassigned.length) {
    content.innerHTML = "<p>No available personnel to assign.</p>";
    modal.style.display = "block";
    return;
  }

  content.innerHTML = `
    <select id="assign-personnel-select" style="width:100%;">
      ${unassigned.map(p => `
        <option value="${p.id}">${p.name || '(no name)'}${Array.isArray(p.training) && p.training.length ? ` (${p.training.join(', ')})` : ''}</option>
      `).join('')}
    </select>
    <br><br>
    <button id="assignPersonnelConfirm">Assign</button>
  `;

  document.getElementById("assignPersonnelConfirm").onclick = async () => {
    const select = document.getElementById("assign-personnel-select");
    const pid = parseInt(select.value, 10);
    if (!pid) return;
    await assignPersonnel(pid, unitId, stationId);
  };

  modal.style.display = "block";
}

async function cancelUnit(unitId, stationId) {
  if (!confirm('Cancel this unit?')) return;
  const res = await fetch(`/api/units/${unitId}/cancel`, { method: 'POST' });
  if (!res.ok) {
    const msg = await res.text();
    alert(`Failed: ${msg}`);
    return;
  }
  refreshStationPanelNoCache(stationId);
}

async function showUnitDetails(unitId) {
  const modal = document.getElementById("unitDetailModal");
  const content = document.getElementById("unitDetailContent");

  const unit = _unitById.get(unitId);
  const station = unit ? _stationById.get(unit.station_id) : null;
  let mission = null;
  try {
    mission = await fetch(`/api/units/${unitId}/mission`).then(r => r.ok ? r.json() : null);
  } catch {}

  const res = await fetch(`/api/personnel?station_id=${unit?.station_id ?? ''}`);
  const personnel = await res.json();
  const assigned = personnel.filter(p => p.unit_id === unitId);

  const eqNames = Array.isArray(unit?.equipment)
    ? unit.equipment.map(e => typeof e === 'string' ? e : e?.name).filter(Boolean)
    : [];

  const equipmentHtml = eqNames.length
    ? `<ul>${eqNames.map(n => `<li>${n} <button class="remove-equip-btn" data-name="${n}">Remove</button></li>`).join('')}</ul>`
    : '<em>No equipment</em>';
  const availableEq = Array.isArray(station?.equipment) ? station.equipment : [];
  const assignHtml = availableEq.length
    ? `<select id="unit-equip-select">${availableEq.map(n=>`<option value="${n}">${n}</option>`).join('')}</select>
       <button id="assign-equip-btn">Assign</button>`
    : '<p><em>No equipment in station storage.</em></p>';

  const personnelHtml = assigned.length
    ? `<ul>${assigned.map(p => `
          <li>
            ${p.name || '(no name)'} ${Array.isArray(p.training) && p.training.length ? `(${p.training.join(', ')})` : ''}
            <button class="unassign-btn" data-person-id="${p.id}" data-station-id="${p.station_id}">Unassign</button>
          </li>
        `).join('')}</ul>`
    : '<p>No personnel assigned to this unit.</p>';

  const missionHtml = mission && mission.id
    ? `<p><strong>Current Mission:</strong> <span class="mission-link" data-missionid="${mission.id}" style="cursor:pointer; color:blue;">#${mission.id} ${mission.type}</span></p>`
    : '<p><strong>Current Mission:</strong> None</p>';

  content.innerHTML = `
    <p><strong>Name:</strong> ${unit?.name || 'Unknown'} <button id="edit-unit-btn">Edit</button></p>
    <p><strong>Station:</strong> ${station?.name || 'Unknown'}</p>
    <p><strong>Vehicle Class:</strong> ${unit?.class || 'Unknown'} (${unit?.type || ''})</p>
    ${missionHtml}
    <button id="change-unit-icon">Change Icon</button>
    <h4>Equipment Aboard</h4>
    ${equipmentHtml}
    <h4>Assign Equipment from Station</h4>
    ${assignHtml}
    <h4>Assigned Personnel</h4>
    ${personnelHtml}
  `;

  content.querySelectorAll('.unassign-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const pid = parseInt(btn.dataset.personId, 10);
      const sid = parseInt(btn.dataset.stationId, 10);
      await fetch(`/api/personnel/${pid}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ unit_id: null })
      });
      modal.style.display = "none";
      showStationDetails({ id: sid });
    });
  });
  content.querySelectorAll('.remove-equip-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const name = btn.dataset.name;
      const res = await fetch(`/api/units/${unitId}/equipment`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ station_id: unit.station_id, name })
      });
      const data = await res.json();
      if (!res.ok || !data.success) {
        alert(`Failed: ${data.error || res.statusText}`);
        return;
      }
      _unitById.set(unitId, { ...unit, equipment: data.equipment });
      modal.style.display = 'none';
      refreshStationPanelNoCache(unit.station_id);
    });
  });
  content.querySelector('#change-unit-icon')?.addEventListener('click', async () => {
    const url = prompt('Enter icon URL:');
    if (!url) return;
    const res = await fetch(`/api/units/${unitId}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
    const data = await res.json();
    if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
    _unitById.set(unitId, { ...unit, icon: url });
    const entry = unitMarkers.get(unitId);
    if (entry) entry.marker.setIcon(unitIconFor({ ...unit, icon: url }));
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });
  const assignBtn = content.querySelector('#assign-equip-btn');
  assignBtn?.addEventListener('click', async () => {
    const name = content.querySelector('#unit-equip-select').value;
    const res = await fetch(`/api/units/${unitId}/equipment`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ station_id: unit.station_id, name })
    });
    const data = await res.json();
    if (!res.ok || !data.success) {
      alert(`Failed: ${data.error || res.statusText}`);
      return;
    }
    _unitById.set(unitId, { ...unit, equipment: data.equipment });
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });

  content.querySelector('#edit-unit-btn')?.addEventListener('click', () => openUnitModal(unit));

  content.querySelector('.mission-link')?.addEventListener('click', async (e) => {
    const mid = parseInt(e.target.dataset.missionid, 10);
    try {
      const m = await fetch(`/api/missions/${mid}`).then(r => r.json());
      showMissionDetails(m);
    } catch {}
  });

  modal.style.display = "block";
}

async function unassignPersonnel(personnelId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ unit_id: null }) });
  document.getElementById("unitDetailModal").style.display = "none";
  showStationDetails({ id: stationId });
}

async function assignPersonnel(personnelId, unitId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ unit_id: unitId })
  });
  await showStationDetails({ id: stationId });
  const m = document.getElementById("assignPersonnelModal");
  if (m) m.style.display = "none";
}

function openUnitCreationForm(station) {
  const allowedTypes = unitTypes.filter(u => u.class === station.type);
  const unitName = prompt("Enter unit name (e.g., Engine 1):");
  if (!unitName) return;
  const typeOptions = allowedTypes.map(u => u.type).join(', ');
  const selectedType = prompt(`Choose unit type (${typeOptions}):`);
  if (!allowedTypes.find(u => u.type === selectedType)) { alert("Invalid type for this station."); return; }
  fetch("/api/units", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ station_id: station.id, class: station.type, type: selectedType, name: unitName })
  }).then(res => res.json()).then(() => showStationDetails(station))
    .catch(err => { console.error("Failed to add unit:", err); alert("Error adding unit."); });
}

async function assignPersonnelToUnit(unitId, stationId) {
  const modal = document.getElementById('assignPersonnelModal');
  const content = document.getElementById('assignPersonnelContent');
  modal.style.display = 'block';
  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();
  const available = personnel.filter(p => !p.unit_id);
  if (!available.length) { content.innerHTML = "<p>No unassigned personnel at this station.</p>"; return; }
  content.innerHTML = available.map(p => `
    <div><label><input type="checkbox" value="${p.id}" /> ${p.name} (${(p.training||[]).join(', ')})</label></div>`).join('');
  const assignBtn = document.createElement("button");
  assignBtn.textContent = "Assign Selected";
  assignBtn.onclick = async () => {
    const selected = Array.from(content.querySelectorAll("input[type=checkbox]:checked")).map(c => parseInt(c.value));
    for (const id of selected) {
      await fetch(`/api/personnel/${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ unit_id: unitId }) });
    }
    modal.style.display = 'none';
    showStationDetails({ id: stationId });
  };
  content.appendChild(assignBtn);
}

// ===== manual dispatch with busy lockout + sort/filter =====
async function getBusyUnitIds() {
  const units = await (await fetch('/api/units')).json();
  return new Set(units.filter(u => u.status && u.status !== 'available').map(u => u.id));
}

function renderManualList(stations, unitsByStation, busyIds, mission) {
  const selectSort = document.getElementById('md-sort');
  const selectClass = document.getElementById('md-class');
  const inputType = document.getElementById('md-type');
  const sortVal = selectSort ? selectSort.value : 'distance';
  const classVal = selectClass ? selectClass.value : '';
  const typeFilter = (inputType ? inputType.value : '').toLowerCase();

  const flat = [];
  for (const st of stations) {
    const units = unitsByStation[st.id] || [];
    for (const u of units) flat.push({ st, u });
  }

  const filtered = flat.filter(({u}) => {
    if (classVal && u.class !== classVal) return false;
    if (typeFilter && !u.type?.toLowerCase().includes(typeFilter)) return false;
    return true;
  });

  const mLL = [mission.lat, mission.lon];
  filtered.sort((a,b)=>{
    if (sortVal==='distance') {
      const da = haversineKm(a.st.lat, a.st.lon, mLL[0], mLL[1]);
      const db = haversineKm(b.st.lat, b.st.lon, mLL[0], mLL[1]);
      return da-db;
    } else if (sortVal==='type') {
      return (a.u.type||'').localeCompare(b.u.type||'') || (a.u.name||'').localeCompare(b.u.name||'');
    }
    return (a.u.name||'').localeCompare(b.u.name||'');
  });

  const byStation = new Map();
  for (const row of filtered) {
    if (!byStation.has(row.st.id)) byStation.set(row.st.id, []);
    byStation.get(row.st.id).push(row.u);
  }

  const html = Array.from(byStation.entries()).map(([sid, units])=>{
    const st = stations.find(s=>s.id===sid);
    return `
      <div style="margin:8px 0; padding:8px; border:1px solid #ddd; border-radius:8px;">
        <strong>${st.name} (${st.type})</strong>
        <div style="display:grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap:6px; margin-top:6px;">
          ${units.map(u=>{
            const isBusy = busyIds.has(u.id);
            const disabled = isBusy ? 'disabled' : '';
            const note = isBusy ? ' <em>(busy)</em>' : '';
            return `<label style="display:block; border:1px solid #eee; padding:6px; border-radius:6px;">
                <input type="checkbox" value="${u.id}" ${disabled}>
                <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer; color:blue;">${u.name}</span> — ${u.type}${note}
              </label>`;
          }).join('')}
        </div>
      </div>`;
  }).join('');

  return html || '<em>No units match your filters.</em>';
}

async function openManualDispatch(mission) {
  const area = document.getElementById('manualDispatchArea');
  area.innerHTML = 'Loading units…';

  try {
    const stations = await fetch('/api/stations').then(r=>r.json());

    // Try the all-units endpoint first
    let allUnits = [];
    try {
      const r = await fetch('/api/units');
      if (r.ok) allUnits = await r.json();
    } catch {}

    // Fallback: pull per-station if the all-units call is empty or failed
    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      const perStation = await Promise.all(
        stations.map(st => fetch(`/api/units?station_id=${st.id}`).then(r=>r.ok ? r.json() : []))
      );
      allUnits = perStation.flat();
    }

    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      area.innerHTML = '<span style="color:#b00;">No units found. (Backend returned no units.)</span>';
      return;
    }

    cacheUnits(allUnits);

    const busyIds = new Set(
      allUnits.filter(u => u.status && u.status !== 'available').map(u => u.id)
    );

    const unitsByStation = allUnits.reduce((acc,u)=>{
      const sid = u.station_id;
      if (!acc[sid]) acc[sid] = [];
      acc[sid].push(u);
      return acc;
    },{});

    area.innerHTML = `
      <div style="display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap: wrap;">
        <label>Sort:
          <select id="md-sort">
            <option value="distance" selected>Distance to call</option>
            <option value="name">Name (A–Z)</option>
            <option value="type">Type</option>
          </select>
        </label>
        <label>Filter class:
          <select id="md-class">
            <option value="">All</option>
            <option value="fire">Fire</option>
            <option value="police">Police</option>
            <option value="ambulance">Ambulance</option>
          </select>
        </label>
        <label>Filter type:
          <input id="md-type" placeholder="e.g. Engine" style="width:120px;">
        </label>
        <button id="md-reset" type="button">Reset Filters</button>
      </div>
      <div style="margin:8px 0;">
        <button id="dispatchSelectedBtn">Dispatch Selected Units</button>
      </div>
      <div id="md-list">Building list…</div>`;

    const mdList = document.getElementById('md-list');
    const attach = ()=>{
      mdList.querySelectorAll('.unit-link').forEach(span=>{
        span.addEventListener('click',()=>showUnitDetails(parseInt(span.dataset.unitid,10)));
      });
    };
    const redraw = ()=>{ mdList.innerHTML = renderManualList(stations, unitsByStation, busyIds, mission); attach(); };
    document.getElementById('md-sort').onchange = redraw;
    document.getElementById('md-class').onchange = redraw;
    document.getElementById('md-type').oninput = redraw;
    document.getElementById('md-reset').onclick = ()=>{
      document.getElementById('md-sort').value = 'distance';
      document.getElementById('md-class').value = '';
      document.getElementById('md-type').value = '';
      redraw();
    };
    redraw();

    document.getElementById('dispatchSelectedBtn').onclick = () => dispatchSelectedUnits(mission.id);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Failed to load units.</span>';
  }
}

async function sendUnitsToMission(mission, ids, area) {
  await Promise.all(ids.map(id => fetch('/api/mission-units',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ mission_id: mission.id, unit_id: id }) })));
  if (area) area.innerHTML = `<strong>Dispatched ${ids.length} unit(s) to mission #${mission.id}.</strong>`;
  const assigned = await refreshAssignedUnitsUI(mission.id);
  const reqDiv = document.getElementById('reqDynamic');
  if (reqDiv) reqDiv.innerHTML = renderRequirementsDynamic(mission, assigned);
  const trainDiv = document.getElementById('reqTrainingDynamic');
  if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(mission, assigned);
  const equipDiv = document.getElementById('reqEquipmentDynamic');
  if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(mission, assigned);

  const allUnits = await (await fetch('/api/units')).json();
  cacheUnits(allUnits);

  for (const uid of ids) {
    const u = _unitById.get(uid);
    if (!u) continue;
    const st = _stationById.get(u.station_id);
    if (!st) continue;
    const marker = ensureUnitMarker(u);
    if (!marker) continue;

    fetch(`/api/units/${uid}/status`, { method:'PATCH', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ status: 'enroute' }) });

    const current = marker.getLatLng ? marker.getLatLng() : L.latLng(st.lat, st.lon);
    const from = [current.lat, current.lng];
    const to   = [mission.lat, mission.lon];
    const spd  = TRAVEL_SPEED[u.class] || 45;

    routeAndAnimateUnit(
      uid, from, to, spd,
      async () => {
        await fetch(`/api/units/${uid}/status`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: 'onscene' })
        });

        const entry = unitMarkers.get(uid);
        if (entry) { try { map.removeLayer(entry.marker); } catch {} unitMarkers.delete(uid); }

        if (window.unitRoutes && unitRoutes.has(uid)) {
          try { map.removeLayer(unitRoutes.get(uid)); } catch {}
          unitRoutes.delete(uid);
        }
        if (typeof clearUnitEta === 'function') clearUnitEta(uid);

        const assignedAfter = await refreshAssignedUnitsUI(mission.id);
        const reqDiv2 = document.getElementById('reqDynamic');
        if (reqDiv2) reqDiv2.innerHTML = renderRequirementsDynamic(mission, assignedAfter);
        const trainDiv2 = document.getElementById('reqTrainingDynamic');
        if (trainDiv2) trainDiv2.innerHTML = renderTrainingRequirementsDynamic(mission, assignedAfter);
        const equipDiv2 = document.getElementById('reqEquipmentDynamic');
        if (equipDiv2) equipDiv2.innerHTML = renderEquipmentRequirementsDynamic(mission, assignedAfter);
        checkMissionCompletion(mission);
      },
      { mission_id: mission.id, phase: 'to_scene' }
    );
  }
}

async function dispatchSelectedUnits(missionId) {
  const area = document.getElementById('manualDispatchArea');
  const ids = Array.from(area.querySelectorAll('input[type="checkbox"]:checked')).map(cb=>parseInt(cb.value,10));
  if (!ids.length){ alert('Select at least one unit to dispatch.'); return; }
  try {
    const missions = await (await fetch('/api/missions')).json();
    const mission = missions.find(m=>m.id===missionId);
    if (!mission) { alert('Mission not found.'); return; }
    await sendUnitsToMission(mission, ids, area);
    openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  } catch (e) {
    console.error(e);
    alert('Failed to dispatch one or more units.');
  }
}

async function autoDispatch(mission) {
  const area = document.getElementById('manualDispatchArea');
  area.innerHTML = 'Selecting units…';
  try {
    const [stations, allUnitsRaw] = await Promise.all([
      fetch('/api/stations').then(r=>r.json()),
      fetch('/api/units?status=available').then(r=>r.json())
    ]);
    cacheStations(stations);
    const stMap = new Map(stations.map(s=>[s.id,s]));
    const allUnits = allUnitsRaw.map(u=>{
      const st = stMap.get(u.station_id);
      const dist = st ? haversineKm(st.lat, st.lon, mission.lat, mission.lon) : Infinity;
      return { ...u, _dist: dist };
    });
    const selected = [];
    const selectedIds = new Set();

    function pickUnits(filterFn, count) {
      const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && filterFn(u)).sort((a,b)=>a._dist - b._dist);
      const take = candidates.slice(0, count);
      for (const u of take) { selectedIds.add(u.id); selected.push(u); }
    }

    const reqUnits = Array.isArray(mission.required_units) ? mission.required_units : [];
    for (const r of reqUnits) {
      const need = r.quantity ?? r.count ?? r.qty ?? 1;
      pickUnits(u => u.type === r.type, need);
    }

    function trainingCount(u, name) {
      let c = 0;
      for (const p of Array.isArray(u.personnel)?u.personnel:[]) {
        for (const t of Array.isArray(p.training)?p.training:[]) {
          if (String(t).toLowerCase() === String(name).toLowerCase()) c++;
        }
      }
      return c;
    }
    function equipmentCount(u, name) {
      return Array.isArray(u.equipment)?u.equipment.filter(e=>String(e).toLowerCase()===String(name).toLowerCase()).length:0;
    }

    const reqTraining = Array.isArray(mission.required_training) ? mission.required_training : [];
    for (const r of reqTraining) {
      const need = r.qty ?? r.quantity ?? r.count ?? 1;
      const name = r.training || r.name || r;
      let have = selected.reduce((sum,u)=>sum + trainingCount(u,name),0);
      if (have < need) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && trainingCount(u,name)>0).sort((a,b)=>a._dist - b._dist);
        for (const u of candidates) {
          if (have >= need) break;
          selectedIds.add(u.id); selected.push(u); have += trainingCount(u,name);
        }
      }
    }

    const reqEquip = Array.isArray(mission.equipment_required) ? mission.equipment_required : [];
    for (const r of reqEquip) {
      const need = r.qty ?? r.quantity ?? r.count ?? 1;
      const name = r.name || r.type || r;
      let have = selected.reduce((sum,u)=>sum + equipmentCount(u,name),0);
      if (have < need) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && equipmentCount(u,name)>0).sort((a,b)=>a._dist - b._dist);
        for (const u of candidates) {
          if (have >= need) break;
          selectedIds.add(u.id); selected.push(u); have += equipmentCount(u,name);
        }
      }
    }

    if (!selected.length) { area.innerHTML = '<em>No available units meet the requirements.</em>'; return; }
    const ids = selected.map(u=>u.id);
    await sendUnitsToMission(mission, ids, area);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Auto dispatch failed.</span>';
  }
}

async function runCardDispatch(mission) {
  let area = document.getElementById('manualDispatchArea');
  let tempArea = false;
  if (!area) {
    area = document.createElement('div');
    area.id = 'manualDispatchArea';
    area.style.display = 'none';
    document.body.appendChild(area);
    tempArea = true;
  }
  try {
    const res = await fetch(`/api/run-cards/${encodeURIComponent(mission.type)}`);
    if (!res.ok) { alert('No run card for this mission.'); return; }
    const rc = await res.json();
    const rcMission = {
      ...mission,
      required_units: rc.units || [],
      required_training: rc.training || [],
      equipment_required: rc.equipment || []
    };
    await autoDispatch(rcMission);
  } catch (e) {
    console.error(e);
    alert('Run card dispatch failed.');
  } finally {
    if (tempArea) area.remove();
  }
}

async function dispatchRunCard() {
  if (window.currentMission) {
    await runCardDispatch(window.currentMission);
  }
}

async function clearAssignedUnit(missionId, unitId) {
  const res = await fetch('/api/mission-units',{ method:'DELETE', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ mission_id: missionId, unit_id: unitId }) });
  if (!res.ok) { const t = await res.text().catch(()=> ''); console.error('Unassign failed:', res.status, t); alert('Failed to clear unit from mission.'); return; }

  const [units, missions] = await Promise.all([ fetch('/api/units').then(r=>r.json()), fetch('/api/missions').then(r=>r.json()) ]);
  cacheUnits(units);
  const u = _unitById.get(unitId);
  const mission = missions.find(m=>m.id===missionId);
  const st = u && _stationById.get(u.station_id);
  if (u && mission && st) {
    ensureUnitMarker(u);
    const entry = unitMarkers.get(u.id);
    const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
    const from = [current.lat, current.lng];
    const to   = [st.lat, st.lon];
    routeAndAnimateUnit(
      u.id, from, to, TRAVEL_SPEED[u.class] || 45,
      () => { const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); } fetch(`/api/unit-travel/${u.id}`,{method:'DELETE'}).catch(()=>{}); },
      { phase: 'return' }
    );
  }
  const assigned = await refreshAssignedUnitsUI(missionId);
  if (document.getElementById('manualDispatchArea')) openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  const missionSnap = missions.find(m=>m.id===missionId);
  if (missionSnap) {
    const reqDiv = document.getElementById('reqDynamic');
    if (reqDiv) reqDiv.innerHTML = renderRequirementsDynamic(missionSnap, assigned);
    const trainDiv = document.getElementById('reqTrainingDynamic');
    if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(missionSnap, assigned);
    const equipDiv = document.getElementById('reqEquipmentDynamic');
    if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(missionSnap, assigned);
  }
}

// Work timer / resolve
const activeWorkTimers = new Map();

function persistWorkTimers() {
  const arr = Array.from(activeWorkTimers.entries()).map(([id, obj]) => ({ id, endTime: obj.endTime }));
  try { localStorage.setItem('activeWorkTimers', JSON.stringify(arr)); }
  catch { /* ignore */ }
}

(function restoreWorkTimers(){
  try {
    const data = JSON.parse(localStorage.getItem('activeWorkTimers') || '[]');
    const now = Date.now();
    for (const { id, endTime } of data) {
      if (endTime > now) activeWorkTimers.set(id, { endTime });
    }
    persistWorkTimers();
  } catch {
    /* ignore */
  }
})();

function startMissionCountdown(missionId, endTime) {
  const existing = activeWorkTimers.get(missionId);
  if (existing && existing.intervalId) clearInterval(existing.intervalId);
  let iid;
  const update = () => {
    const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
    if (openMissionId === missionId) {
      const tDiv = document.getElementById('missionTimerArea');
      if (remaining <= 0) {
        if (tDiv) tDiv.textContent = 'Resolving…';
      } else if (tDiv) {
        const mins = Math.floor(remaining / 60);
        const secs = remaining % 60;
        tDiv.textContent = `Time remaining: ${mins}:${secs.toString().padStart(2, '0')}`;
      }
    }
    if (remaining <= 0 && iid) clearInterval(iid);
  };
  update();
  iid = setInterval(update, 1000);
  if (existing) {
    existing.intervalId = iid;
    existing.endTime = endTime;
  } else {
    activeWorkTimers.set(missionId, { endTime, intervalId: iid });
  }
  persistWorkTimers();
}

for (const [id, obj] of Array.from(activeWorkTimers.entries())) {
  startMissionCountdown(id, obj.endTime);
}

async function checkMissionCompletion(mission) {
  const assigned = await (await fetch(`/api/missions/${mission.id}/units`)).json();
  const unitOnscene = new Map();
  const equipOnscene = new Map();
  const trainOnscene = new Map();
  for (const u of assigned) {
    if (u.status === 'onscene') {
      unitOnscene.set(u.type, (unitOnscene.get(u.type)||0)+1);
      for (const e of Array.isArray(u.equipment) ? u.equipment : []) {
        equipOnscene.set(e, (equipOnscene.get(e)||0)+1);
      }
      for (const p of Array.isArray(u.personnel) ? u.personnel : []) {
        for (const t of Array.isArray(p.training) ? p.training : []) {
          trainOnscene.set(t, (trainOnscene.get(t)||0)+1);
        }
      }
    }
  }
  const reqUnits = Array.isArray(mission.required_units) ? mission.required_units : [];
  const reqEquip = Array.isArray(mission.equipment_required) ? mission.equipment_required : [];
  const reqTrain = Array.isArray(mission.required_training) ? mission.required_training : [];
  const unitsMet = reqUnits.every(r => (unitOnscene.get(r.type)||0) >= (r.quantity ?? r.count ?? 1));
  const equipMet = reqEquip.every(r => (equipOnscene.get(r.name || r.type || r)||0) >= (r.qty ?? r.quantity ?? r.count ?? 1));
  const trainMet = reqTrain.every(r => (trainOnscene.get(r.training || r.name || r)||0) >= (r.qty ?? r.quantity ?? r.count ?? 1));
  const allMet = unitsMet && equipMet && trainMet;
  const existing = activeWorkTimers.get(mission.id);
  if (!allMet) {
    if (existing) {
      if (existing.timeoutId) clearTimeout(existing.timeoutId);
      if (existing.intervalId) clearInterval(existing.intervalId);
      activeWorkTimers.delete(mission.id);
      persistWorkTimers();
      if (openMissionId === mission.id) {
        const tDiv = document.getElementById('missionTimerArea');
        if (tDiv) tDiv.textContent = '';
      }
    }
    return;
  }

  if (!existing) {
    const minutes = Number.isFinite(mission.timing) ? mission.timing : 10;
    const ms = Math.max(5, minutes*60)*1000;
    const endTime = Date.now() + ms;
    const tid = setTimeout(async ()=>{
      const cur = activeWorkTimers.get(mission.id);
      if (cur && cur.intervalId) clearInterval(cur.intervalId);
      activeWorkTimers.delete(mission.id);
      persistWorkTimers();
      const assignedBefore = await (await fetch(`/api/missions/${mission.id}/units`)).json();
      await fetch(`/api/missions/${mission.id}/resolve`, { method:'POST' });
      if (!_stationById || _stationById.size===0) { const stations = await (await fetch('/api/stations')).json(); cacheStations(stations); }
      for (const u of assignedBefore) {
        const st = _stationById.get(u.station_id);
        if (!st) continue;
        ensureUnitMarker(u);
        const entry = unitMarkers.get(u.id);
        const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
        routeAndAnimateUnit(
          u.id,
          [current.lat, current.lng],
          [st.lat, st.lon],
          TRAVEL_SPEED[u.class] || 45,
          () => {
            const rp = unitRoutes.get(u.id);
            if (rp) { try { map.removeLayer(rp); } catch {} unitRoutes.delete(u.id); }
            fetch(`/api/unit-travel/${u.id}`, { method:'DELETE' }).catch(()=>{});
          },
          { phase: 'return' }
        );
      }
      await refreshAssignedUnitsUI(mission.id);
      await fetchMissions();
      const area = document.getElementById('manualDispatchArea');
      if (area) area.innerHTML = '<strong>Mission resolved.</strong>';
    }, ms);
    activeWorkTimers.set(mission.id, { timeoutId: tid, endTime });
    persistWorkTimers();
    startMissionCountdown(mission.id, endTime);
  }
}

// Rebuild en-route after reload (using backend unit-travel)
async function rebuildEnrouteMarkers() {
  const [stations, allUnits] = await Promise.all([ fetch('/api/stations').then(r=>r.json()), fetch('/api/units').then(r=>r.json()) ]);
  cacheStations(stations);
  cacheUnits(allUnits);

  let travels = [];
  try { travels = await (await fetch('/api/unit-travel/active')).json(); }
  catch(e){ console.warn('No /api/unit-travel/active; fallback to old behavior.'); }

  if (Array.isArray(travels) && travels.length) {
    for (const t of travels) {
      const u = _unitById.get(t.unit_id);
      if (!u) continue;
      ensureUnitMarker(u);
      routeAndAnimateUnit(
        t.unit_id, t.from, t.to, TRAVEL_SPEED[u.class] || 45,
        async () => {
          if (t.phase === 'to_scene') {
            await fetch(`/api/units/${t.unit_id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'onscene' }) });
          }
          const entry = unitMarkers.get(t.unit_id);
          if (t.phase === 'to_scene' && entry) { try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(t.unit_id); }
          const rp = unitRoutes.get(t.unit_id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(t.unit_id); }
          clearUnitEta(t.unit_id);
          fetch(`/api/unit-travel/${t.unit_id}`, { method:'DELETE' }).catch(()=>{});
        },
        { saved: t }
      );
    }
    return;
  }

  // Fallback: naive restart-from-station if travel store is empty
  try {
    const missions = await (await fetch('/api/missions')).json();
    const active = missions.filter(m => m.status !== 'resolved');
    for (const m of active) {
      const assigned = await (await fetch(`/api/missions/${m.id}/units`)).json();
      for (const u of assigned) {
        if (u.status === 'enroute') {
          const st = _stationById.get(u.station_id);
          if (!st) continue;
          ensureUnitMarker(u);
          routeAndAnimateUnit(u.id, [st.lat, st.lon], [m.lat, m.lon], TRAVEL_SPEED[u.class] || 45, async ()=>{
            await fetch(`/api/units/${u.id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'onscene' }) });
            const entry = unitMarkers.get(u.id); if (entry){ try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(u.id); }
            const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); }
            clearUnitEta(u.id);
            await refreshAssignedUnitsUI(m.id);
            checkMissionCompletion(m);
          });
        }
      }
    }
  } catch(e){ console.warn('Fallback rebuild failed:', e); }
}

// Init
(async () => {
  await fetchStations();
  await fetchMissions();
  rebuildEnrouteMarkers();
})();
</script>

</body>
</html>