<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Chief Responder</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
        <script type="module" src="js/common.js"></script>
        <script type="module" src="js/edit-dialogs.js"></script>
        <style>
                html, body { height: 100%; margin: 0; overflow: hidden; }
                body { display: flex; height: 100vh; font-family: sans-serif; }
                #sidebar { max-width: 30%; width: 100%; overflow-y: auto; padding: 10px; box-sizing: border-box; }
                #map { flex: 1; }
		.mission { border-bottom: 1px solid #ccc; margin-bottom: 1em; padding-bottom: 0.5em; }
                .tab-button { padding: 0.5em 1em; border: none; background: #ddd; cursor: pointer; }
                .tab-button.active { background: #aaa; font-weight: bold; }
                .mission-speed { padding: 0.5em 1em; border: none; background: #ddd; cursor: pointer; margin-right: 0.5em; }
                .mission-speed.active { background: #aaa; font-weight: bold; }
                .tab-content { display: none; }
                .tab-content.active { display: block; }
                #stationDetails { max-width: 30%; overflow-y: auto; }
		.popup { position: fixed; top: 10%; left: 30%; width: 40%; background: white; border: 2px solid black; padding: 20px; z-index: 9999; max-height: 80%; overflow-y: auto; }
		.hidden { display: none; }
		.modal-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; overflow: auto; }
		.modal-content { background: white; padding: 2rem; max-width: 90%; max-height: 90%; overflow-y: auto; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); }
                .mission-icon { width: 30px; height: 30px; object-fit: contain; vertical-align: middle; }
                .unit-tag-icon {
                        width: var(--tag-width, 36px);
                        height: var(--tag-height, 24px);
                        line-height: var(--tag-height, 24px);
                        text-align: center;
                        color: white;
                        border: 2px solid transparent;
                        font-size: 12px;
                        font-weight: bold;
                }
                .unit-tag-icon.fire { background: red; }
                .unit-tag-icon.police { background: blue; }
                .unit-tag-icon.ambulance { background: green; }
                .leaflet-marker-icon { overflow: visible !important; }
                .leaflet-pane, .leaflet-marker-pane { overflow: visible !important; }
                .unit-tag-icon.responding.fire,
                .unit-tag-icon.responding.ambulance {
                        animation: flash-rw 1s infinite;
                }
                .unit-tag-icon.responding.police {
                        animation: flash-rwb 1s infinite;
                }
                @keyframes flash-rw {
                        0%, 100% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                        50% {
                                border-color: white;
                                box-shadow: 0 0 6px 2px white;
                        }
                }
                @keyframes flash-rwb {
                        0% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                        33% {
                                border-color: white;
                                box-shadow: 0 0 6px 2px white;
                        }
                        66% {
                                border-color: blue;
                                box-shadow: 0 0 6px 2px blue;
                        }
                        100% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                }
        </style>
</head>
<body>

<div id="sidebar">
        <h2>Chief Responder</h2>
        <button id="openCad" onclick="location.href='cad.html'" style="margin-bottom:1em;">Open CAD</button>
	<div style="display: flex; gap: 1em; margin-bottom: 1em;">
                <button class="tab-button active" data-tab="missions">Missions</button>
                <button class="tab-button" data-tab="stations">Stations</button>
                <button class="tab-button" data-tab="zones">Zones</button>
	</div>
	<div id="walletDisplay">Balance: $0</div>
	<script>
	async function refreshWallet(){
	  const w = await fetch('/api/wallet').then(r=>r.json());
	  document.getElementById('walletDisplay').textContent = `Balance: $${w.balance}`;
	}
	setInterval(refreshWallet, 5000);
	refreshWallet();
        </script>
        <div id="tab-missions" class="tab-content active">
                <div id="missionSpeedControls" style="margin-bottom:1em;">
                        <button class="mission-speed active" data-speed="pause">Pause</button>
                        <button class="mission-speed" data-speed="slow">Slow</button>
                        <button class="mission-speed" data-speed="medium">Medium</button>
                        <button class="mission-speed" data-speed="fast">Fast</button>
                </div>
                <button id="generateMission">Generate Mission</button>
                <button id="startPatrols">Start Patrols</button>
                <button id="clearMissions" style="background: darkred; color: white; margin-top: 1em;">DEBUG CLEAR ALL CALLS</button>
                <button id="deleteAllStations">DEBUG DELETE ALL STATIONS</button>
                <div id="missionList"></div>
        </div>

        <div id="tab-stations" class="tab-content">
          <button id="buildStation" style="margin-bottom: 1em;">Build New Station</button>
          <div id="stationList"></div>
        </div>
        <div id="tab-zones" class="tab-content">
          <button id="addZoneBtn">Add Zone</button>
          <button id="saveZoneEditBtn" style="display:none;">Save Zone</button>
          <div id="zoneList"></div>
        </div>
</div>

<div id="map"></div>

<!-- Modal for Mission & Station Details -->
<div id="missionDetails" style="
  position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
  background: white; padding: 1em; border: 2px solid #444;
  box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 9999;
  width: 420px; max-height: 80vh; overflow-y: auto; border-radius: 8px;
  display: none;">
        <div style="text-align:right;">
                <button onclick="closeMissionDetails()">Close</button>
        </div>
        <h3>Details</h3>
        <div id="missionDetailsContent">Loading...</div>
</div>

<!-- Station Creation Form -->
<div id="stationForm" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: white; border: 2px solid #444; padding: 1em;
	width: 300px; max-width: 30%; box-shadow: 0 0 10px rgba(0,0,0,0.3);
	display: none; z-index: 10000;">
	<h3>Create Station</h3>

        <label for="stationName">Name:</label>
        <input type="text" id="stationName" style="width: 100%;" />
        <br><br>
        <label for="stationDept">Department:</label>
        <input type="text" id="stationDept" style="width: 100%;" />
        <br><br>
        <label for="stationType">Type:</label>
        <select id="stationType" style="width: 100%;">
                <option value="fire">Fire</option>
		<option value="police">Police</option>
		<option value="ambulance">Ambulance</option>
	</select>
	<br><br>
	<button id="createStation">Create</button>
	<button onclick="document.getElementById('stationForm').style.display = 'none';">Cancel</button>
</div>

<!-- Unit Assignment Modal -->
<div id="assignPersonnelModal" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: white; border: 2px solid #444; padding: 1em;
	width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
	display: none; z-index: 10001;">
	<h3>Assign Personnel to Unit</h3>
	<div id="assignModalContent">Loading...</div>
	<button onclick="document.getElementById('assignPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Personnel Modal -->
<div id="editPersonnelModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001;">
        <h3>Edit Personnel</h3>
        <div id="editPersonnelContent">Loading...</div>
        <button onclick="document.getElementById('editPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Unit Modal -->
<div id="editUnitModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001;">
        <h3>Edit Unit</h3>
        <div id="editUnitContent">Loading...</div>
        <button onclick="document.getElementById('editUnitModal').style.display = 'none';">Close</button>
</div>

<!-- Unit Detail Modal -->
<div id="unitDetailModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: white; border: 2px solid #444; padding: 1em;
        width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.3);
        display: none; z-index: 10001; max-height: 80vh; overflow-y: auto;">
        <h3>Unit Details</h3>
        <div id="unitDetailContent">Loading...</div>
        <button onclick="document.getElementById('unitDetailModal').style.display = 'none';">Close</button>
</div>

<div id="cadPopup" class="popup hidden">
  <h3 id="cadTitle"></h3>
  <p id="cadType"></p>
  <p id="cadRequired"></p>
  <button onclick="dispatchAuto()">Dispatch (Auto)</button>
  <button onclick="dispatchRecommended()">Dispatch (Recommended)</button>
  <button onclick="dispatchRunCard()">Dispatch (Run Card)</button>
  <button onclick="manualDispatch()">Manual Dispatch</button>
  <button onclick="closeCad()">Close</button>
</div>

<div id="stationDetails"></div>
<script src="/config/unitTypes.js"></script>
<script src="/config/trainings.js"></script>
<script src="/config/equipment.js"></script>

<script>
// ========= constants / helpers =========
const TRAVEL_SPEED = { fire: 63, police: 94, ambulance: 75 }; // km/h used across UI (25% faster)

function haversineKm(aLat, aLon, bLat, bLon) {
  const R = 6371;
  const dLat = (bLat - aLat) * Math.PI/180;
  const dLon = (bLon - aLon) * Math.PI/180;
  const la1 = aLat * Math.PI/180, la2 = bLat * Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

// Refresh a single station panel with fresh data (no cache)
async function refreshStationPanelNoCache(stationId) {
  const stations = await fetchNoCache('/api/stations').then(r=>r.json());
  cacheStations(stations);
  const st = stations.find(s => s.id === stationId);
  if (st) showStationDetails(st);
}

function makeIcon(url, size) {
  return L.divIcon({
    html: `<img src="${url}" style="width:100%;height:100%;object-fit:contain;object-position:center bottom;">`,
    iconSize: [size, size],
    iconAnchor: [size / 2, size],
    className: ''
  });
}

function makeTagIcon(tag, unitClass, responding, width = 36, height = 24) {
  const classes = ['unit-tag-icon'];
  if (unitClass) classes.push(unitClass);
  if (responding) classes.push('responding');
  const cls = classes.join(' ');
  return L.divIcon({
    html: `<div class="${cls}" style="--tag-width:${width}px; --tag-height:${height}px;">${tag || ''}</div>`,
    iconSize: [width, height],
    iconAnchor: [width / 2, height],
    className: ''
  });
}

const missionIcons = {
  none: makeIcon("/warning1.png", 30),
  partial: makeIcon("/warning2.png", 30),
  complete: makeIcon("/warning3.png", 30)
};
const stationIcons = { fire: "/fire.png", police: "/police.png", ambulance: "/star.png", hospital: "/star.png", jail: "/police.png" };

let missionMarkers = [];
let stationMarkers = [];
let buildStationMode = false;
let pendingStationCoords = null;
let openMissionId = null;

const map = L.map("map").setView([47.5646, -52.7002], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "&copy; OpenStreetMap contributors" }).addTo(map);

const zoneLayerGroup = L.featureGroup();
const zoneLayers = new Map();
let responseZones = [];
const deptColors = {};
const colorPalette = ['red','blue','green','purple','orange','brown','pink','gray'];
function colorForDept(d){
  if(!deptColors[d]) deptColors[d] = colorPalette[Object.keys(deptColors).length % colorPalette.length];
  return deptColors[d];
}

document.getElementById("deleteAllStations").addEventListener("click", async () => {
  if (!confirm("Are you sure you want to delete ALL stations? This will also orphan units!")) return;
  await fetch("/api/stations", { method: "DELETE" });
  fetchStations();
  alert("All stations deleted.");
});

function getTrainingsForClass(cls) {
  const key = String(cls || '').trim().toLowerCase();
  if (typeof trainingsByClass !== 'undefined' && trainingsByClass && trainingsByClass[key]) {
    return trainingsByClass[key];
  }
  return [];
}

// Tabs
document.querySelectorAll(".tab-button").forEach(button => {
  button.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    button.classList.add("active");
    document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
    if (button.dataset.tab === 'zones') {
      map.addLayer(zoneLayerGroup);
    } else {
      map.removeLayer(zoneLayerGroup);
    }
  });
});

function unitIconFor(unit) {
  if (!unit.icon && !unit.responding_icon) {
    const tag = (unit.tag || unit.name || '').split(' ')[0].slice(0, 4).toUpperCase();
    return makeTagIcon(tag, unit.class, unit.responding);
  }
  const sanitizedType = (unit.type || '').replace(/\s+/g, '');
  const baseIcon = sanitizedType ? `/images/${sanitizedType}.png` : null;
  const respDefault = sanitizedType ? `/images/${sanitizedType}-responding.png` : null;
  const normal = unit.icon || baseIcon || stationIcons[unit.class] || stationIcons.fire;
  const responding = unit.responding_icon || respDefault || normal;
  const url = unit.responding ? responding : normal;
  return makeIcon(url, 24);
}

function chooseMissionIcon(mission, assigned) {
  const responders = (Array.isArray(assigned) ? assigned : [])
    .filter(u => u.status === 'enroute' || u.status === 'on_scene');
  if (responders.length === 0) return missionIcons.none;
  if (activeWorkTimers.has(mission.id)) return missionIcons.complete;
  return missionIcons.partial;
}

function missionIconUrl(mission, assigned) {
  const responders = (Array.isArray(assigned) ? assigned : [])
    .filter(u => u.status === 'enroute' || u.status === 'on_scene');
  if (responders.length === 0) return '/warning1.png';
  if (activeWorkTimers.has(mission.id)) return '/warning3.png';
  return '/warning2.png';
}

// caches
window._stationById = new Map();
window._unitById = new Map();

// registries
const unitMarkers = new Map(); // unitId -> { marker, animId }
const unitRoutes  = new Map(); // unitId -> L.Polyline
// track ETA timers for enroute units
const unitEtaTimers = new Map(); // unitId -> intervalId
const missionListTimers = new Map(); // missionId -> intervalId

function formatEta(seconds){
  const s = Math.max(0, Math.floor(seconds));
  const m = Math.floor(s / 60);
  const sec = s % 60;
  return `${m}:${sec.toString().padStart(2,'0')}`;
}

function setUnitEta(unitId, elem, startedAt, totalDuration){
  clearUnitEta(unitId);
  function update(){
    const elapsed = (Date.now() - new Date(startedAt).getTime())/1000;
    const remaining = Math.max(0, (totalDuration||0) - elapsed);
    elem.textContent = `enroute (${formatEta(remaining)})`;
    if (remaining <= 0) clearUnitEta(unitId);
  }
  update();
  const iid = setInterval(update, 1000);
  unitEtaTimers.set(unitId, iid);
}

function clearUnitEta(unitId){
  const iid = unitEtaTimers.get(unitId);
  if (iid) clearInterval(iid);
  unitEtaTimers.delete(unitId);
}

function startMissionListTimer(id, endTime){
  const prev = missionListTimers.get(id);
  if (prev) clearInterval(prev);
  const elem = document.querySelector(`.mission-time[data-id="${id}"]`);
  if (!elem) return;
  let iid = null;
  function update(){
    const remaining = Math.max(0, (endTime - Date.now())/1000);
    elem.textContent = formatEta(remaining);
    if (remaining <= 0){
      clearInterval(iid);
      missionListTimers.delete(id);
    }
  }
  update();
  iid = setInterval(update, 1000);
  missionListTimers.set(id, iid);
}

function cacheStations(stations){
  _stationById = new Map(stations.map(s => [s.id, { ...s, department: s.department ?? null }]));
}
function cacheUnits(units){
  _unitById = new Map(units.map(u => [u.id, { ...u, priority: Number(u.priority) || 1 }]));
}

function ensureUnitMarker(unit) {
  const st = _stationById.get(unit.station_id);
  if (!st) return null;
  let entry = unitMarkers.get(unit.id);
  if (!entry) {
    const icon = unitIconFor(unit);
    const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 })
      .addTo(map)
      .on('click', () => showUnitDetails(unit.id));
    entry = { marker, animId: null };
    unitMarkers.set(unit.id, entry);
  } else {
    entry.marker.setIcon(unitIconFor(unit));
  }
  return entry.marker;
}

function animateMoveUnit(unitId, from, to, durationMs, onDone) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;
  const start = performance.now();
  function step(now) {
    const t = Math.min(1, (now - start) / durationMs);
    const lat = from[0] + (to[0] - from[0]) * t;
    const lon = from[1] + (to[1] - from[1]) * t;
    marker.setLatLng([lat, lon]);
    if (t < 1) entry.animId = requestAnimationFrame(step);
    else { entry.animId = null; if (onDone) onDone(); }
  }
  entry.animId = requestAnimationFrame(step);
}

// helpers for resume
function cumulative(segDurations){ const out=[0]; for(let i=0;i<segDurations.length;i++) out.push(out[i]+segDurations[i]); return out; }
function segmentAtElapsed(segDurations, elapsedSec){
  const cum = cumulative(segDurations);
  const total = cum[cum.length-1];
  const e = Math.max(0, Math.min(elapsedSec, total));
  let i=0; while(i<segDurations.length && e>cum[i+1]) i++;
  const segElapsed = e - cum[i];
  const segDur = Math.max(0.001, segDurations[i] || 0.001);
  const t = segElapsed / segDur;
  return { index: i, t, total };
}

function animateAlongRouteOffset(unitId, coords, segDurations, onDone, startOffsetSec = 0) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;

  const { index: startIdx, t: t0 } = segmentAtElapsed(segDurations, startOffsetSec);
  let segIdx = startIdx;
  let segRemainingMs = (1 - t0) * Math.max(1, (segDurations[segIdx] || 0.001)) * 1000;

  const placeAt = (idx, t) => {
    const a = coords[idx], b = coords[idx+1] || coords[idx];
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);
  };
  placeAt(segIdx, t0);

  let segStart = performance.now();
  let segEnd   = segStart + segRemainingMs;

  function step(now) {
    if (segIdx >= segDurations.length || segIdx >= coords.length - 1) {
      if (onDone) onDone();
      entry.animId = null;
      return;
    }
    const a = coords[segIdx], b = coords[segIdx+1];
    const t = Math.min(1, (now - segStart) / (segEnd - segStart));
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);

    if (t >= 1) {
      segIdx++;
      if (segIdx < segDurations.length && segIdx < coords.length - 1) {
        segStart = now;
        segEnd   = segStart + Math.max(1, segDurations[segIdx]) * 1000;
      }
    }
    entry.animId = requestAnimationFrame(step);
  }
  entry.animId = requestAnimationFrame(step);
}

// OSRM fetch
async function fetchRouteOSRM(from, to) {
  const url = `https://router.project-osrm.org/route/v1/driving/${from[1]},${from[0]};${to[1]},${to[0]}?overview=full&geometries=geojson&annotations=duration,distance&steps=false`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`OSRM ${res.status}`);
  const json = await res.json();
  if (!json.routes?.length) throw new Error('No route');
  const route = json.routes[0];
  const coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
  const duration = route.duration;
  const annotations = route.legs?.[0]?.annotation || null;
  return { coords, duration, annotations };
}

function drawRoute(unitId, coords) {
  try {
    const existing = unitRoutes.get(unitId);
    if (existing) { map.removeLayer(existing); unitRoutes.delete(unitId); }
    const poly = L.polyline(coords, { weight: 3, opacity: 0.35 });
    poly.addTo(map);
    unitRoutes.set(unitId, poly);
  } catch {}
}

async function routeAndAnimateUnit(unitId, from, to, speedClassKmh, onArrive, resumeOpts) {
  patrolStates.delete(unitId);
  try {
    // Resume with saved travel (from backend)
    if (resumeOpts?.saved) {
      const { coords, seg_durations, started_at } = resumeOpts.saved;
      drawRoute(unitId, coords);
      const u = _unitById.get(unitId) || { id: unitId, class: 'fire', station_id: 0 };
      ensureUnitMarker(u);
      const elapsedSec = Math.max(0, (Date.now() - new Date(started_at).getTime()) / 1000);
      animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, elapsedSec);
      return;
    }

    // Fresh route
    const { coords, duration, annotations } = await fetchRouteOSRM(from, to);
    const seg_durations = (annotations?.duration?.length === coords.length - 1)
      ? annotations.duration
      : Array.from({ length: coords.length - 1 }, () => duration / Math.max(1, coords.length - 1));

    // Light “emergency” multiplier
    const speedMultiplier = { fire: 1.2, police: 1.3, ambulance: 1.25 };
    const u = _unitById.get(unitId);
    const mult = u ? (speedMultiplier[u.class] || 1.0) : 1.0;
    const adjustedTotal = Math.max(5, duration / mult);

    // Persist to backend so we can resume on refresh
    try {
      await fetch('/api/unit-travel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          unit_id: unitId,
          mission_id: resumeOpts?.mission_id,
          phase: resumeOpts?.phase || 'to_scene',
          started_at: new Date().toISOString(),
          from, to,
          coords,
          seg_durations,
          total_duration: adjustedTotal
        })
      });
    } catch (e) { console.warn('Failed to persist travel:', e); }

    drawRoute(unitId, coords);
    ensureUnitMarker(u || { id: unitId, station_id: 0, class: 'fire' });
    animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, 0);
  } catch (err) {
    console.warn('OSRM route failed; straight-line fallback:', err);
    const R = 6371;
    const dLat = (to[0]-from[0]) * Math.PI/180, dLon = (to[1]-to[0]) * Math.PI/180;
    const la1 = from[0] * Math.PI/180, la2 = to[0] * Math.PI/180;
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    const distKm = 2*R*Math.asin(Math.sqrt(h));
      const etaSec = Math.max(5, Math.round((distKm / (speedClassKmh || 56)) * 3600));
    animateMoveUnit(unitId, from, to, etaSec * 1000, onArrive);
  }
}

let missionTemplates = [];
fetch('/api/mission-templates')
  .then(r => r.json())
  .then(data => { missionTemplates = data.map(t => ({ ...t, frequency: Number(t.frequency) || 3 })); })
  .catch(err => console.error('Failed to load mission templates:', err));

// UI helpers
function closeModal(){ const m = document.querySelector(".modal-overlay"); if (m) m.remove(); }

// Cache mission addresses by ID to avoid duplicate reverse-geocoding lookups.
const missionAddressCache = {};
async function reverseGeocode(lat, lon, id) {
  if (id && missionAddressCache[id]) return missionAddressCache[id];
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`);
    if (!res.ok) throw new Error('Reverse geocode failed');
    const data = await res.json();
    const addr = data.display_name || `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    if (id) missionAddressCache[id] = addr;
    return addr;
  } catch (err) {
    console.warn('Reverse geocode error:', err);
    return `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
  }
}

function sortMissions(missions) {
  const level = m => {
    if (m.resolve_at) return 3;
    return (m.assigned_count > 0) ? 2 : 1;
  };
  return missions
    .filter(m => m.status !== 'resolved')
    .map(m => ({ ...m, level: level(m) }))
    .sort((a, b) => {
      const diff = a.level - b.level;
      if (diff !== 0) return diff;
      return (a.id || 0) - (b.id || 0);
    });
}

async function fetchMissions() {
  try {
    const res = await fetch("/api/missions");
    let missions = await res.json();
    missions = sortMissions(missions);

    const missionById = new Map(missions.map(m => [m.id, m]));
    const missionIds = new Set(missionById.keys());
    for (const [id, iid] of Array.from(missionListTimers.entries())) {
      const m = missionById.get(id);
      if (!m || !Number.isFinite(m.resolve_at)) {
        clearInterval(iid);
        missionListTimers.delete(id);
      }
    }

    missionMarkers.forEach(m => map.removeLayer(m));
    missionMarkers = [];

    const missionList = document.getElementById("missionList");
    const scrollPos = missionList.scrollTop;
    const existingEls = new Map(Array.from(missionList.children).map(el => [Number(el.dataset.id), el]));

    const valid = missions.filter(m => Number.isFinite(m.lat) && Number.isFinite(m.lon));
    const assignedList = await Promise.all(
      valid.map(m => fetch(`/api/missions/${m.id}/units`).then(r => r.json()).catch(() => []))
    );
    const addresses = await Promise.all(
      valid.map(m => {
        if (m.address) {
          missionAddressCache[m.id] = m.address;
          return m.address;
        }
        return reverseGeocode(m.lat, m.lon, m.id);
      })
    );
    for (let i = 0; i < valid.length; i++) {
      const m = valid[i];
      const assigned = assignedList[i];
      const address = addresses[i];
      const marker = L.marker([m.lat, m.lon], { icon: chooseMissionIcon(m, assigned) })
        .addTo(map)
        .on("click", () => showMissionDetails(m));

      missionMarkers.push(marker);

      let el = existingEls.get(m.id);
      if (!el) {
        el = document.createElement("div");
        el.className = "mission";
        el.dataset.id = m.id;
      } else {
        existingEls.delete(m.id);
        el.innerHTML = ""; // clear for rebuild
      }
      const endTime = Number(m.resolve_at);
      const timerSpan = Number.isFinite(endTime)
        ? `<span class="mission-time" data-id="${m.id}">${formatEta((endTime - Date.now())/1000)}</span>`
        : "";
      el.innerHTML = `
        <img src="${missionIconUrl(m, assigned)}" class="mission-icon">
        <strong class="focus-mission" data-lat="${m.lat}" data-lon="${m.lon}" style="cursor:pointer;">${m.type}</strong>
        ${timerSpan}<br>
        Address: ${address}<br>`;
      const btn = document.createElement('button');
      btn.textContent = 'Details';
      btn.style.marginLeft = '8px';
      btn.addEventListener('click', () => showMissionDetails(m));
      const firstBr = el.querySelector('br');
      if (firstBr) {
        el.insertBefore(btn, firstBr);
      } else {
        el.appendChild(btn);
      }
      missionList.appendChild(el);
      if (Number.isFinite(endTime)) startMissionListTimer(m.id, endTime);
    }

    for (const el of existingEls.values()) {
      missionList.removeChild(el);
    }

    missionList.scrollTop = scrollPos;

      // Sync mission timers with server state
      const now = Date.now();
      const presentIds = new Set(missions.map(m => m.id));
    for (const [id, obj] of Array.from(activeWorkTimers.entries())) {
      if (!presentIds.has(id)) {
        if (obj.timeoutId) clearTimeout(obj.timeoutId);
        if (obj.intervalId) clearInterval(obj.intervalId);
        activeWorkTimers.delete(id);
      }
    }
    for (const m of missions) {
      const end = Number(m.resolve_at);
      if (end && end > now) {
        const ex = activeWorkTimers.get(m.id);
        if (!ex || ex.endTime !== end) {
          setupTimerForMission(m, end);
        }
      } else {
        const ex = activeWorkTimers.get(m.id);
        if (ex) {
          if (ex.timeoutId) clearTimeout(ex.timeoutId);
          if (ex.intervalId) clearInterval(ex.intervalId);
          activeWorkTimers.delete(m.id);
        }
      }
    }
    persistWorkTimers();
  } catch (err) {
    console.error("Failed to fetch missions:", err);
  }
}

// ===== Patrol helpers =====
const patrolStates = new Map();

function randomPointNear(lat, lon, radiusKm) {
  const r = radiusKm / 6371;
  const u = Math.random();
  const v = Math.random();
  const w = r * Math.sqrt(u);
  const t = 2 * Math.PI * v;
  const lat1 = lat * Math.PI/180;
  const lon1 = lon * Math.PI/180;
  const newLat = Math.asin(Math.sin(lat1)*Math.cos(w) + Math.cos(lat1)*Math.sin(w)*Math.cos(t));
  const newLon = lon1 + Math.atan2(Math.sin(t)*Math.sin(w)*Math.cos(lat1), Math.cos(w) - Math.sin(lat1)*Math.sin(newLat));
  return [newLat*180/Math.PI, newLon*180/Math.PI];
}

async function patrolRoute(unitId, from, to, speedClassKmh, onDone) {
  try {
    const { coords, duration, annotations } = await fetchRouteOSRM(from, to);
    const seg_durations = (annotations?.duration?.length === coords.length - 1)
      ? annotations.duration
      : Array.from({ length: coords.length - 1 }, () => duration / Math.max(1, coords.length - 1));
    drawRoute(unitId, coords);
    animateAlongRouteOffset(unitId, coords, seg_durations, onDone, 0);
  } catch (err) {
    const distKm = haversineKm(from[0], from[1], to[0], to[1]);
    const etaSec = Math.max(5, Math.round((distKm / (speedClassKmh || 56)) * 3600));
    animateMoveUnit(unitId, from, to, etaSec * 1000, onDone);
  }
}

function startUnitPatrol(unit) {
  if (!unit || patrolStates.has(unit.id)) return;
  const st = _stationById.get(unit.station_id);
  if (!st) return;
  ensureUnitMarker(unit);
  const speed = TRAVEL_SPEED[unit.class] || 63;
  const state = { start: Date.now() };
  patrolStates.set(unit.id, state);
  const maxMs = 60 * 60 * 1000;

  const step = (from) => {
    const s = patrolStates.get(unit.id);
    if (!s) return;
    if (Date.now() - s.start >= maxMs) {
      patrolRoute(unit.id, from, [st.lat, st.lon], speed, () => patrolStates.delete(unit.id));
      return;
    }
    const dest = randomPointNear(st.lat, st.lon, 5);
    patrolRoute(unit.id, from, dest, speed, () => step(dest));
  };

  step([st.lat, st.lon]);
}

async function generateMissionAtPOI(poi) {
  const res = await fetch('/api/random-mission');
  const mission = await res.json();
  const { name, required_units } = mission;
  document.getElementById("cadTitle").textContent = name;
  const tagVal = poi.tags.amenity || poi.tags.building || poi.tags.leisure || poi.tags.tourism || poi.tags.shop || poi.tags.aeroway || poi.tags.landuse || poi.tags.office || poi.tags.man_made || poi.tags.name;
  document.getElementById("cadType").textContent = `POI: ${tagVal}`;
  const formatReq = r => {
    const types = Array.isArray(r.types) ? r.types : [r.type];
    const typeStr = types.join(' or ');
    const count = r.count ?? r.quantity ?? r.qty ?? 1;
    return `${count}x ${typeStr}`;
  };
  document.getElementById("cadRequired").textContent = required_units.map(formatReq).join(', ');
  document.getElementById("cadPopup").classList.remove('hidden');
  window.currentMission = mission;
}

// ===== Station list / details =====
async function fetchStations() {
  const res = await fetch("/api/stations");
  const stations = await res.json();
  cacheStations(stations);
  stationMarkers.forEach(m => map.removeLayer(m));
  stationMarkers = [];
  const list = document.getElementById("stationList");
  list.innerHTML = "";

  const unitCounts = await Promise.all(
    stations.map(st => {
      if (st.type === 'hospital' || st.type === 'jail') return 0;
      return fetch(`/api/units?station_id=${st.id}`)
        .then(r=>r.json()).then(arr=>arr.length).catch(()=>0);
    })
  );

  stations.forEach((st, idx) => {
    const used = unitCounts[idx];
    const free = (st.bay_count || 0) - used;
    const iconUrl = st.icon || stationIcons[st.type] || stationIcons.fire;
    const icon = makeIcon(iconUrl, 30);
    const marker = L.marker([st.lat, st.lon], { icon }).addTo(map).on("click", () => showStationDetails(st));
    stationMarkers.push(marker);
    const el = document.createElement("div");
    let info = '';
    if (st.type === 'hospital') {
      const occ = Number(st.occupied_beds || 0);
      const cap = Number(st.bed_capacity || 0);
      info = `Beds: ${occ}/${cap} (Free: ${cap - occ})`;
    } else if (st.type === 'jail' || (st.type === 'police' && Number(st.holding_cells) > 0)) {
      const occ = Number(st.occupied_cells || 0);
      const cap = Number(st.holding_cells || 0);
      info = `Cells: ${occ}/${cap} (Free: ${cap - occ})`;
      if (st.type === 'police') {
        info += `<br>Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
      }
    } else {
      info = `Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
    }
    el.innerHTML = `<strong class="focus-station" data-lat="${st.lat}" data-lon="${st.lon}" style="cursor:pointer;">${st.name}</strong><br>Type: ${st.type}<br>Department: ${st.department || ''}<br>${info}<br>`;
    const btn = document.createElement('button');
    btn.textContent = 'Details';
    btn.addEventListener('click', () => showStationDetails(st));
    el.appendChild(btn);
    list.appendChild(el);
  });
}

async function fetchZones() {
  const res = await fetch('/api/response-zones');
  responseZones = await res.json();
  zoneLayerGroup.clearLayers();
  zoneLayers.clear();
  const list = document.getElementById('zoneList');
  if (list) list.innerHTML = '';
  responseZones.forEach(z => {
    const coords = (z.polygon?.coordinates || []).map(c => [c[0], c[1]]);
    const deptList = Array.isArray(z.departments) ? z.departments : [];
    const layer = L.polygon(coords, { color: colorForDept(deptList[0]) }).addTo(zoneLayerGroup);
    layer.bindPopup(`${z.name} (${deptList.join(', ')})`);
    layer.on('click', () => startEditZone(z.id));
    zoneLayers.set(z.id, layer);
    if (list) {
      const el = document.createElement('div');
      el.innerHTML = `${z.name} (${deptList.join(', ')}) <button class="edit-zone" data-id="${z.id}">Edit</button> <button class="delete-zone" data-id="${z.id}">Delete</button>`;
      list.appendChild(el);
    }
  });
  if (list) {
    list.querySelectorAll('.delete-zone').forEach(btn => {
      btn.onclick = async () => {
        await fetch(`/api/response-zones/${btn.dataset.id}`, { method: 'DELETE' });
        fetchZones();
      };
    });
    list.querySelectorAll('.edit-zone').forEach(btn => {
      btn.onclick = () => startEditZone(btn.dataset.id);
    });
  }
}

let editingZoneId = null;
function startEditZone(id) {
  const layer = zoneLayers.get(Number(id));
  if (!layer) return;
  editingZoneId = Number(id);
  layer.editing.enable();
  document.getElementById('saveZoneEditBtn').style.display = 'inline';
}

document.getElementById('saveZoneEditBtn').addEventListener('click', async () => {
  const id = editingZoneId;
  const layer = zoneLayers.get(id);
  if (!layer) return;
  layer.editing.disable();
  const latlngs = layer.getLatLngs()[0].map(p => [p.lat, p.lng]);
  const z = responseZones.find(r => r.id == id);
  const name = prompt('Zone name:', z?.name || '') || (z?.name || '');
  const deptInput = prompt('Departments (comma-separated):', (z?.departments||[]).join(', ')) || '';
  const departments = deptInput.split(',').map(s=>s.trim()).filter(Boolean);
  await fetch(`/api/response-zones/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, departments, polygon: { coordinates: latlngs } })
  });
  editingZoneId = null;
  document.getElementById('saveZoneEditBtn').style.display = 'none';
  fetchZones();
});

document.getElementById('addZoneBtn').addEventListener('click', () => {
  new L.Draw.Polygon(map).enable();
});

map.on('draw:created', async e => {
  const latlngs = e.layer.getLatLngs()[0].map(p => [p.lat, p.lng]);
  const ring = latlngs.slice();
  if (ring.length && (ring[0][0] !== ring[ring.length - 1][0] ||
                      ring[0][1] !== ring[ring.length - 1][1])) {
    ring.push(ring[0]);
  }
  const stations = await fetch('/api/stations').then(r => r.json());
  const depts = [...new Set(stations.map(s => s.department).filter(Boolean))];
  const name = prompt('Zone name?') || 'Zone';
  const deptInput = prompt(`Departments (comma-separated) (${depts.join(', ')})?`) || '';
  const departments = deptInput.split(',').map(s=>s.trim()).filter(Boolean);
  const newPoly = turf.polygon([ring.map(([lat, lng]) => [lng, lat])]);
  for (const z of [...responseZones]) {
    const existingRing = z.polygon.coordinates.slice();
    if (existingRing.length && (existingRing[0][0] !== existingRing[existingRing.length - 1][0] ||
                                existingRing[0][1] !== existingRing[existingRing.length - 1][1])) {
      existingRing.push(existingRing[0]);
    }
    const existing = turf.polygon([existingRing.map(([lat, lng]) => [lng, lat])]);
    const inter = turf.intersect(existing, newPoly);
    if (inter) {
      const diff = turf.difference(existing, newPoly);
      if (diff && diff.geometry && diff.geometry.coordinates.length) {
        const newCoords = diff.geometry.coordinates[0].map(([lng, lat]) => [lat, lng]);
        await fetch(`/api/response-zones/${z.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: z.name, departments: z.departments, polygon: { coordinates: newCoords } })
        });
      } else {
        await fetch(`/api/response-zones/${z.id}`, { method: 'DELETE' });
      }
    }
  }
  await fetch('/api/response-zones', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, departments, polygon: { coordinates: latlngs } })
  });
  fetchZones();
});

async function refreshAssignedUnitsUI(missionId) {
  const div = document.getElementById('assignedUnitsArea');
  if (!div) return [];
  try {
    div.innerHTML = 'Loading assigned units…';
    const [res, travelRes] = await Promise.all([
      fetch(`/api/missions/${missionId}/units`),
      fetch('/api/unit-travel/active').catch(()=>null)
    ]);
    const assigned = await res.json();
    let travelMap = new Map();
    try {
      const travels = travelRes ? await travelRes.json() : [];
      travelMap = new Map(travels.map(t => [t.unit_id, t]));
    } catch {}
    (assigned||[]).forEach(u => _unitById.set(u.id, { ...u, priority: Number(u.priority) || 1 }));
    if (!Array.isArray(assigned) || !assigned.length) {
      div.innerHTML = '<em>No units assigned yet.</em>';
      return [];
    }
    div.innerHTML = `
      <strong>Assigned Units:</strong>
      <ul style="list-style:none; padding-left:0;">
        ${assigned.map(u => `
          <li style="display:flex; align-items:center; gap:6px; margin:4px 0;">
            <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer; color:blue;">${u.name}</span> (${u.type}) — <span id="unit-status-${u.id}">${u.status || 'enroute'}</span>
            <button data-unitid="${u.id}" data-missionid="${missionId}" class="clear-unit-btn">Clear</button>
          </li>
        `).join('')}
      </ul>`;
    div.querySelectorAll('.unit-link').forEach(span => {
      span.addEventListener('click', () => showUnitDetails(parseInt(span.dataset.unitid,10)));
    });
    div.querySelectorAll('.clear-unit-btn').forEach(btn => {
      btn.onclick = async () => {
        btn.disabled = true;
        try { await clearAssignedUnit(parseInt(btn.dataset.missionid,10), parseInt(btn.dataset.unitid,10)); }
        finally { btn.disabled = false; }
      };
    });
    assigned.forEach(u => {
      const travel = travelMap.get(u.id);
      const statusEl = div.querySelector(`#unit-status-${u.id}`);
      if (u.status === 'enroute' && travel && statusEl) {
        setUnitEta(u.id, statusEl, travel.started_at, travel.total_duration);
      } else {
        clearUnitEta(u.id);
      }
    });
    return assigned;
  } catch (e) {
    console.error(e);
    div.innerHTML = '<span style="color:#b00;">Failed to load assigned units.</span>';
    return [];
  }
}

// ===== Dynamic requirements =====
function renderRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.required_units) ? mission.required_units : [];
  if (!req.length) return '<em>No specific unit requirements.</em>';
  const penalties = Array.isArray(mission.penalties) ? mission.penalties : [];
  const counts = { enroute: new Map(), on_scene: new Map() };
  for (const u of assigned || []) {
    if (u.status === 'on_scene') counts.on_scene.set(u.type, (counts.on_scene.get(u.type)||0)+1);
    else if (u.status === 'enroute') counts.enroute.set(u.type, (counts.enroute.get(u.type)||0)+1);
  }
  const items = req.map(r => {
    const types = Array.isArray(r.types) ? r.types : [r.type];
    const typeStr = types.join(' or ');
    const baseNeed = r.quantity ?? r.count ?? 1;
    const ignored = penalties.filter(p => types.includes(p.type)).reduce((s,p)=>s+(p.quantity||0),0);
    const need = Math.max(0, baseNeed - ignored);
    const onScene = types.reduce((s,t)=>s+(counts.on_scene.get(t)||0),0);
    const enroute = types.reduce((s,t)=>s+(counts.enroute.get(t)||0),0);
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${typeStr} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });
  const options = Array.isArray(mission.penalty_options) ? mission.penalty_options : [];
  let optHtml = '';
  if (options.length) {
    const rows = options.map((p, idx) => {
      const checked = penalties.some(sel => sel.type===p.type && sel.quantity===p.quantity && sel.timePenalty===p.timePenalty && sel.rewardPenalty===p.rewardPenalty);
      return `<div><label><input type="checkbox" class="penalty-opt" data-idx="${idx}" ${checked?"checked":""}> Ignore ${p.quantity}×${p.type} (-${p.timePenalty||0}% speed, -${p.rewardPenalty||0}% reward)</label></div>`;
    });
    optHtml = `<div><strong>Penalties:</strong>${rows.join('')}</div>`;
  }
  return `<ul>${items.join('')}</ul>${optHtml}`;
}

function attachPenaltyHandlers(mission) {
  document.querySelectorAll('.penalty-opt').forEach(cb => {
    cb.addEventListener('change', async () => {
      const options = Array.isArray(mission.penalty_options) ? mission.penalty_options : [];
      const selected = Array.from(document.querySelectorAll('.penalty-opt:checked')).map(c => options[parseInt(c.dataset.idx,10)]);
      mission.penalties = selected;
      await fetch(`/api/missions/${mission.id}/penalties`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ penalties: selected }) });
      checkMissionCompletion(mission);
    });
  });
}

function renderTrainingRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.required_training) ? mission.required_training : [];
  if (!req.length) return '';
  const counts = { enroute: new Map(), on_scene: new Map() };
  for (const u of assigned || []) {
    const target = u.status === 'on_scene' ? counts.on_scene : (u.status === 'enroute' ? counts.enroute : null);
    if (!target) continue;
    for (const p of Array.isArray(u.personnel) ? u.personnel : []) {
      for (const t of Array.isArray(p.training) ? p.training : []) {
        target.set(t, (target.get(t) || 0) + 1);
      }
    }
  }
  const items = req.map(r => {
    const need = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.training || r.name || r;
    const onScene = counts.on_scene.get(name) || 0;
    const enroute = counts.enroute.get(name) || 0;
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderEquipmentRequirementsDynamic(mission, assigned) {
  const req = Array.isArray(mission.equipment_required) ? mission.equipment_required : [];
  if (!req.length) return '';
  const counts = { enroute: new Map(), on_scene: new Map() };
  for (const u of assigned || []) {
    const target = u.status === 'on_scene' ? counts.on_scene : (u.status === 'enroute' ? counts.enroute : null);
    if (!target) continue;
    for (const e of Array.isArray(u.equipment) ? u.equipment : []) {
      target.set(e, (target.get(e) || 0) + 1);
    }
  }
  const items = req.map(r => {
    const need = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.name || r.type || r;
    const onScene = counts.on_scene.get(name) || 0;
    const enroute = counts.enroute.get(name) || 0;
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderPatientInfo(mission) {
  const pts = Array.isArray(mission.patients) ? mission.patients : [];
  if (!pts.length) return '';
  const items = pts.map(p => {
    if (typeof p.count === 'number') {
      const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
      const parts = [String(p.count)];
      if (codes) parts.push(`Codes: ${codes}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (codes) parts.push(`Codes: ${codes}`);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderPrisonerInfo(mission) {
  const prs = Array.isArray(mission.prisoners) ? mission.prisoners : [];
  if (!prs.length) return '';
  const items = prs.map(p => {
    if (typeof p.count === 'number') {
      const parts = [String(p.count)];
      if (Number.isFinite(p.transport)) parts.push(`Transport: ${p.transport}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const transport = Number.isFinite(p.transportChance) ? `Transport: ${Math.round(p.transportChance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (transport) parts.push(transport);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

// ===== Mission details =====
function showMissionDetails(mission) {
  openMissionId = mission.id;
  const container = document.getElementById("missionDetailsContent");
  const patientHtml = renderPatientInfo(mission);
  const prisonerHtml = renderPrisonerInfo(mission);
  const hasTraining = Array.isArray(mission.required_training) && mission.required_training.length;
  const hasEquipment = Array.isArray(mission.equipment_required) && mission.equipment_required.length;
  container.innerHTML = `
    <h3>${mission.type}</h3>
    <p><strong>Status:</strong> ${mission.status}</p>
    <p><strong>Unit Requirements:</strong></p>
    <div id="reqDynamic">Loading…</div>
    ${hasTraining ? '<p><strong>Personnel Requirements:</strong></p><div id="reqTrainingDynamic">Loading…</div>' : ''}
    ${hasEquipment ? '<p><strong>Equipment Required:</strong></p><div id="reqEquipmentDynamic">Loading…</div>' : ''}
    ${patientHtml ? '<p><strong>Patients:</strong></p>' + patientHtml : ''}
    ${prisonerHtml ? '<p><strong>Prisoners:</strong></p>' + prisonerHtml : ''}
    <div id="assignedUnitsArea" style="margin-top:8px;"></div>
    <div style="margin-top:10px;"><button id="manualDispatchBtn">Manual Dispatch</button> <button id="autoDispatchBtn">Auto Dispatch</button> <button id="runCardDispatchBtn">Run Card Dispatch</button> <button id="unitTypeDispatchBtn">Unit Type Dispatch</button></div>
    <div id="manualDispatchArea" style="margin-top:8px;"></div>
    <div id="unitTypeDispatchArea" style="margin-top:8px;"></div>
    <div id="missionTimerArea" style="margin-top:8px;"></div>
  `;
  document.getElementById('manualDispatchBtn').onclick = () => openManualDispatch(mission);
  document.getElementById('autoDispatchBtn').onclick = () => autoDispatch(mission);
  document.getElementById('runCardDispatchBtn').onclick = () => runCardDispatch(mission);
  document.getElementById('unitTypeDispatchBtn').onclick = () => openUnitTypeDispatch(mission);
  refreshAssignedUnitsUI(mission.id).then(assigned => {
    const reqDiv = document.getElementById('reqDynamic');
    if (reqDiv) { reqDiv.innerHTML = renderRequirementsDynamic(mission, assigned); attachPenaltyHandlers(mission); }
    const trainDiv = document.getElementById('reqTrainingDynamic');
    if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(mission, assigned);
    const equipDiv = document.getElementById('reqEquipmentDynamic');
    if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(mission, assigned);
  });
  document.getElementById("missionDetails").style.display = "block";
  const active = activeWorkTimers.get(mission.id);
  if (active && active.endTime) {
    startMissionCountdown(mission.id, active.endTime);
  } else {
    const t = document.getElementById('missionTimerArea');
    if (t) t.textContent = '';
  }
}

function closeMissionDetails() {
  document.getElementById('missionDetails').style.display = 'none';
  openMissionId = null;
}

// ===== Station details =====
async function showStationDetails(station) {
  station = await fetchNoCache(`/api/stations/${station.id}`).then(r=>r.json());
  const detail = document.getElementById('stationDetails');
  window.currentStation = station;
  if (station.type === 'hospital' || station.type === 'jail') {
    const isHospital = station.type === 'hospital';
    const occ = isHospital ? Number(station.occupied_beds || 0) : Number(station.occupied_cells || 0);
    const cap = isHospital ? Number(station.bed_capacity || 0) : Number(station.holding_cells || 0);
    detail.innerHTML = `
      <div style="text-align:right;">
        <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
      </div>
      <h2>${station.name}</h2>
          <button id="change-station-icon">Change Icon</button>
      <p>Type: ${station.type}</p>

      <p>Department: <span id="station-dept">${station.department || ''}</span> <button id="change-station-dept">Change Department</button></p>
      <div>${isHospital ? 'Beds' : 'Holding Cells'}: ${occ}/${cap} (Free: ${cap - occ})</div>
    `;
          const iconBtn = detail.querySelector('#change-station-icon');
      iconBtn?.addEventListener('click', async () => {
      const url = prompt('Enter icon URL:');
      if (!url) return;
      const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
      const data = await res.json();
      if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
      station.icon = url;
      _stationById.set(station.id, station);
      fetchStations();
      showStationDetails(station);
    });
    const deptBtn = detail.querySelector('#change-station-dept');
    deptBtn?.addEventListener('click', async () => {
      const dept = prompt('Enter department:');
      if (dept === null) return;
      const res = await fetch(`/api/stations/${station.id}/department`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ department: dept }) });
      const data = await res.json();
      if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
      station.department = dept;
      _stationById.set(station.id, station);
      fetchStations();
      showStationDetails(station);
    });
    return;
  }
  const res = await fetchNoCache(`/api/units?station_id=${station.id}`);
  const units = (await res.json()).map(u=>({ ...u, priority: Number(u.priority) || 1 }));
  units.forEach(u => _unitById.set(u.id, u));
  const unitOptions = unitTypes.filter(u=>u.class===station.type).map(u=>`<option value="${u.type}">${u.type}</option>`).join('');
  const usedBays = units.length;
  const freeBays = (station.bay_count || 0) - usedBays;
  const equipOptions = (equipment[station.type] || []).map(e=>{
    const name = typeof e === 'string' ? e : e.name;
    const cost = typeof e === 'object' && e.cost ? e.cost : 0;
    return `<option value="${name}" data-cost="${cost}">${name}${cost?` ($${cost})`:''}</option>`;
  }).join('');
  const stationEquip = Array.isArray(station.equipment) ? station.equipment : [];
  const holdingInfo = (station.type === 'police' && Number(station.holding_cells) > 0)
    ? `<div id="holding-info">Holding Cells: ${Number(station.occupied_cells || 0)}/${Number(station.holding_cells || 0)} (Free: ${Number(station.holding_cells || 0) - Number(station.occupied_cells || 0)})</div>`
    : '';
  detail.innerHTML = `
    <div style="text-align:right;">
      <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
    </div>
    <h2>${station.name}</h2>
        <button id="change-station-icon">Change Icon</button>
    <p>Type: ${station.type}</p>
    <p>Department: <span id="station-dept">${station.department || ''}</span> <button id="change-station-dept">Change Department</button></p>
    <h3>Create Unit</h3>
    <select id="unit-type">${unitOptions}</select>
    <input id="unit-name" placeholder="Unit name (e.g., Ladder 1)" />
    <input id="unit-tag" placeholder="Tag" />
    <input id="unit-priority" type="number" min="1" max="5" value="1" style="width:60px;" />
    <button id="create-unit">Create Unit</button>
    <h3>Add Personnel</h3>
    <input id="personnel-name" placeholder="Name (e.g., John Doe)" />
    <div id="personnel-training">
      ${
        (getTrainingsForClass(station.type).length
          ? getTrainingsForClass(station.type)
          : [{ name: 'general', cost: 0 }]
        ).map((t,idx)=>{
          const name = typeof t === 'string' ? t : t.name;
          const cost = typeof t === 'object' && t.cost ? t.cost : 0;
          return `<label><input type="checkbox" value="${name}" data-cost="${cost}" ${idx===0?"checked":""}/> ${name}${cost?` ($${cost})`:''}</label><br>`;
        }).join('')
      }
    </div>
    <div id="personnel-cost"></div>
    <div id="bay-info">Bays: ${usedBays}/${station.bay_count || 0} (Free: ${freeBays})</div>
    ${holdingInfo}
    <div>
      <label>Add bays:
        <input id="add-bays-count" type="number" min="1" value="1">
      </label>
      <button id="add-bays-btn">Add Bays</button>
    </div>
    <h3>Station Equipment</h3>
    <div id="station-equipment-display">
      ${stationEquip.length ? `<ul>${stationEquip.map(e=>`<li>${e}</li>`).join('')}</ul>` : '<em>No equipment</em>'}
    </div>
    <div>
      <select id="equipment-buy">${equipOptions}</select>
      <button id="buy-equipment-btn">Buy</button>
    </div>
    <button id="create-personnel">Add Personnel</button>
    <h3>Personnel</h3>
    <ul id="personnel-list"></ul>
    <h3>Assigned Units</h3>
    <ul id="unit-list">
      ${units.map(u=>`
        <li>
          <strong style="cursor:pointer; color:blue;" onclick="showUnitDetails(${u.id})">${u.name}</strong> (${u.type}) [P${u.priority}] - ${u.status}
          <button onclick="openAssignModal(${u.id}, ${station.id})">Assign</button>
          ${u.status !== 'available' ? `<button onclick="cancelUnit(${u.id}, ${station.id})">Cancel</button>` : ''}
          <button class="edit-unit-btn" data-unitid="${u.id}">Edit</button>
        </li>`).join('')}
    </ul>`;
  // Prepopulate personnel input with a random name
  try {
    const rnd = await fetch('/api/random-name').then(r => r.json());
    const input = document.getElementById('personnel-name');
    if (input && rnd.first && rnd.last) {
      input.value = `${rnd.first} ${rnd.last}`;
    }
  } catch {}
          const iconBtn = detail.querySelector('#change-station-icon');
          iconBtn?.addEventListener('click', async () => {
                const url = prompt('Enter icon URL:');
                if (!url) return;
                const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
                const data = await res.json();
                if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
                station.icon = url;
                _stationById.set(station.id, station);
                fetchStations();
                showStationDetails(station);
          });
          const deptBtn = detail.querySelector('#change-station-dept');
          deptBtn?.addEventListener('click', async () => {
                const dept = prompt('Enter department:');
                if (dept === null) return;
                const res = await fetch(`/api/stations/${station.id}/department`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ department: dept }) });
                const data = await res.json();
                if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
                station.department = dept;
                _stationById.set(station.id, station);
                fetchStations();
                showStationDetails(station);
          });
        async function refreshBayInfo(stationId) {
          const [s, us] = await Promise.all([
            fetch(`/api/stations/${stationId}`, { cache: 'no-store' }).then(r=>r.json()),
            fetch(`/api/units?station_id=${stationId}`, { cache: 'no-store' }).then(r=>r.json())
          ]);
          const used = Array.isArray(us) ? us.length : 0;
          const el = document.getElementById('bay-info');
          el.textContent = `Bays: ${used}/${s.bay_count} (Free: ${s.bay_count - used})`;
          if (s.type === 'police' && Number(s.holding_cells) > 0) {
            const hc = document.getElementById('holding-info');
            if (hc) hc.textContent = `Holding Cells: ${Number(s.occupied_cells||0)}/${Number(s.holding_cells||0)} (Free: ${Number(s.holding_cells||0) - Number(s.occupied_cells||0)})`;
          }
        }

        const BASE_PERSON_COST = 100;
        function updatePersonnelCost() {
          const selected = Array.from(detail.querySelectorAll('#personnel-training input[type=checkbox]:checked'));
          const cost = selected.reduce((sum, cb) => sum + Number(cb.dataset.cost || 0), BASE_PERSON_COST);
          const el = detail.querySelector('#personnel-cost');
          if (el) el.textContent = `Cost: $${cost}`;
          return cost;
        }
        detail.querySelectorAll('#personnel-training input[type=checkbox]').forEach(cb => cb.addEventListener('change', updatePersonnelCost));
        updatePersonnelCost();

        document.getElementById('add-bays-btn')?.addEventListener('click', async () => {
          const n = Number(document.getElementById('add-bays-count').value || 1);
          const stationId = station.id;
          const res = await fetch(`/api/stations/${stationId}/bays`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ add: n })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
                alert(`Failed: ${data.error || res.statusText}`);
                return;
          }
          alert(`Added ${data.added} bay(s). Cost: $${data.cost}`);
          refreshBayInfo(stationId);
          refreshWallet();
        });
        document.getElementById('buy-equipment-btn')?.addEventListener('click', async () => {
          const sel = document.getElementById('equipment-buy');
          const name = sel.value;
          const res = await fetch(`/api/stations/${station.id}/equipment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
            alert(`Failed: ${data.error || res.statusText}`);
            return;
          }
          alert(`Purchased ${name} for $${data.cost}`);
          refreshWallet();
          refreshStationPanelNoCache(station.id);
        });
  // Replace inline openAssignModal with safe listeners
        detail.querySelectorAll('button').forEach(btn => {
          const m = btn.getAttribute('onclick');
          if (m && m.startsWith('openAssignModal(')) {
                btn.removeAttribute('onclick');
                const args = m.match(/openAssignModal\((\d+),\s*(\d+)\)/);
                if (args) {
                  const [_, unitId, stationId] = args.map(Number);
                  btn.addEventListener('click', () => openAssignModal(unitId, stationId));
                }
          }
        });

        // Hook up unit edit buttons
        detail.querySelectorAll('.edit-unit-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = parseInt(btn.dataset.unitid, 10);
            const u = _unitById.get(id);
            if (u) openUnitModal(u);
          });
        });

        // Replace inline editPersonnel with safe listener
        detail.querySelectorAll('#personnel-list button').forEach(btn => {
          const m = btn.getAttribute('onclick');
          if (m && m.startsWith('editPersonnel(')) {
                btn.removeAttribute('onclick');
                const id = parseInt(m.match(/editPersonnel\((\d+)\)/)[1], 10);
                btn.addEventListener('click', () => window.editPersonnel(id));
          }
        });
  document.getElementById('create-unit').addEventListener('click', async ()=>{
    const type = document.getElementById('unit-type').value;
    const name = document.getElementById('unit-name').value;
    const tag = document.getElementById('unit-tag').value;
    const priority = Number(document.getElementById('unit-priority').value) || 1;
    if (!type || !name) return alert("Missing name or type");
    await fetch('/api/units',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({station_id:station.id,class:station.type,type,name,tag,priority})});
    showStationDetails(station);
  });
  document.getElementById('create-personnel').addEventListener('click', async ()=>{
    const name = document.getElementById('personnel-name').value;
    const training = Array.from(document.querySelectorAll('#personnel-training input[type=checkbox]:checked')).map(cb=>cb.value);
    if (!name) return alert("Missing name");
    const res = await fetch('/api/personnel',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({ name, station_id: station.id, training })});
    const data = await res.json();
    if (!res.ok) { alert(`Failed: ${data.error || res.statusText}`); return; }
    alert(`Personnel added. Cost: $${data.charged}`);
    refreshWallet();
    showStationDetails(station);
  });

  // Load personnel (no-cache so edits show immediately)
  const personnel = await fetchNoCache(`/api/personnel?station_id=${station.id}`).then(r=>r.json());
  const personnelList = document.getElementById("personnel-list");
  personnelList.innerHTML = '';
  personnel.forEach(p=>{
    const li = document.createElement("li");
    const trainings = (p.training || []).map(t => typeof t === 'string' ? t : t.name).join(', ');
    li.innerHTML = `<strong>${p.name}</strong> (${trainings}) <button onclick="editPersonnel(${p.id})" style="margin-left:10px;">Edit</button>`;
    personnelList.appendChild(li);
  });

  refreshBayInfo(station.id);
}

// Build station
document.getElementById("buildStation").addEventListener("click", () => { buildStationMode = true; alert("Click the map to place your new station"); });
map.on("click", async (e) => {
  if (!buildStationMode) return;
  const name = prompt("Station Name?");
  const type = prompt("Type (fire, police, ambulance, hospital, jail)?", "fire")?.toLowerCase();
  const department = prompt("Department?") || null;
  if (!name || !["fire","police","ambulance","hospital","jail"].includes(type)) { alert("Cancelled or invalid type."); buildStationMode=false; return; }
  let holding_cells = 0, beds = 0;
  if (type === "police" || type === "jail") {
    holding_cells = Number(prompt("Holding cells?", "0")) || 0;
  }
  if (type === "hospital") {
    beds = Number(prompt("Beds?", "0")) || 0;
  }
  await fetch("/api/stations", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ name, type, department, lat:e.latlng.lat, lon:e.latlng.lng, holding_cells, beds }) });
  buildStationMode = false;
  pendingStationCoords = null;
  fetchStations();
});

function randomCount({min=0, max=0, chance=1}) {
  min = Math.floor(min); max = Math.floor(max);
  if (max <= min) return min;
  if (Math.random() < chance) return max;
  return min + Math.floor(Math.random() * (max - min));
}

function instantiatePatients(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    return { count, codes: p.codes };
  }).filter(p => p.count > 0);
}

function instantiatePrisoners(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    const transportChance = Number(p.transportChance) || 0;
    let transport = 0;
    for (let i = 0; i < count; i++) {
      if (Math.random() < transportChance) transport++;
    }
    return { count, transport };
  }).filter(p => p.count > 0);
}

// Generate Mission
async function generateMission(retry = false, excludeIndex = null) {
  if (missionTemplates.length === 0) { alert("No mission templates loaded."); return; }
  const stations = await fetch('/api/stations').then(r => r.json()).catch(() => []);
  if (!stations.length) { alert("No stations available."); return; }
  const st = stations[Math.floor(Math.random() * stations.length)];
  const radius = 5000; // meters

  let availableTemplates = missionTemplates;
  if (excludeIndex !== null) {
    availableTemplates = missionTemplates.filter((_, idx) => idx !== excludeIndex);
    if (!availableTemplates.length) return;
  }
  const weights = availableTemplates.map(t => Math.max(1, 6 - (Number(t.frequency) || 3)));
  const totalWeight = weights.reduce((a, b) => a + b, 0);
  let pick = Math.random() * totalWeight;
  let template = availableTemplates[0];
  for (let i = 0; i < availableTemplates.length; i++) {
    if ((pick -= weights[i]) < 0) { template = availableTemplates[i]; break; }
  }
  const templateIndex = missionTemplates.indexOf(template);

  let lat, lon;
  if (template.trigger_type === 'poi' && template.trigger_filter) {
    try {
      const pois = await fetch(`/api/pois?lat=${st.lat}&lon=${st.lon}&radius=${radius}`)
        .then(r => r.json()).catch(() => []);
      const matches = pois.filter(p => {
        if (!p.tags) return false;
        if ((template.trigger_filter || "").includes("=")) {
          const [key, val] = template.trigger_filter.split("=");
          return p.tags[key] === val;
        }
        return p.tags.amenity === template.trigger_filter;
      });
      if (matches.length) {
        const poi = matches[Math.floor(Math.random() * matches.length)];
        lat = poi.lat; lon = poi.lon;
      } else {
        console.warn('No matching POI found.');
        if (!retry) return generateMission(true, templateIndex);
        return;
      }
    } catch (e) {
      console.error('POI lookup failed', e);
      alert('POI lookup failed.');
      return;
    }
  } else if (template.trigger_type === 'intersection' && template.trigger_filter) {
    const [road1, road2] = String(template.trigger_filter).split('|');
    if (road1 && road2) {
      try {
        const query = `[out:json];way["name"="${road1}"](around:${radius},${st.lat},${st.lon});way["name"="${road2}"](around:${radius},${st.lat},${st.lon});node(w["name"="${road1}"])(w["name"="${road2}"]);out;`;
        const resp = await fetch('https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(query));
        const data = await resp.json();
        if (Array.isArray(data.elements) && data.elements.length) {
          const inter = data.elements[0];
          lat = inter.lat; lon = inter.lon;
        }
      } catch (e) { console.error('Intersection lookup failed', e); }
    }
  }
  if (lat === undefined || lon === undefined) {
    try {
      const roadQuery = `[out:json];way["highway"](around:${radius},${st.lat},${st.lon});out geom;`;
      const roadResp = await fetch('https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(roadQuery));
      const roadData = await roadResp.json();
      if (Array.isArray(roadData.elements) && roadData.elements.length) {
        const way = roadData.elements[Math.floor(Math.random() * roadData.elements.length)];
        const geom = Array.isArray(way.geometry) ? way.geometry : [];
        if (geom.length) {
          const pt = geom[Math.floor(Math.random() * geom.length)];
          lat = pt.lat;
          lon = pt.lon;
        }
      }
    } catch (e) { console.error('Road lookup failed', e); }
  }
  if (lat === undefined || lon === undefined) {
    lat = st.lat;
    lon = st.lon;
  }

  const missionData = {
    type: template.name, lat, lon,
    required_units: template.required_units,
    required_training: template.required_training || [],
    equipment_required: template.equipment_required || [],
    patients: instantiatePatients(template.patients),
    prisoners: instantiatePrisoners(template.prisoners),
    modifiers: template.modifiers || [],
    penalty_options: template.penalty_options || [],
    penalties: [],
    timing: template.timing ?? 10
  };
  try {
    const res = await fetch('/api/missions', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(missionData) });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    playSound('/audio/newalert.mp3');
    await fetchMissions();
  } catch (err) { console.error("Failed to create mission:", err); alert("Failed to create mission."); }
}

document.getElementById('generateMission').addEventListener('click', () => generateMission());

// Start patrols for all units flagged
document.getElementById('startPatrols').addEventListener('click', async () => {
  const units = await fetch('/api/units').then(r => r.json()).catch(()=>[]);
  cacheUnits(units);
  units.filter(u => u.patrol).forEach(u => startUnitPatrol(u));
});

// Clear Missions
document.getElementById("clearMissions").addEventListener("click", async ()=>{
  if (!confirm("Clear ALL missions?")) return;
  await fetch("/api/missions", { method:"DELETE" });
  fetchMissions();
});

// Mission generation speed controls
let missionGenTimer = null;
let missionGenRange = null;

function scheduleMissionGeneration() {
  if (!missionGenRange) return;
  const [min, max] = missionGenRange;
  const delay = (Math.floor(Math.random() * (max - min + 1)) + min) * 1000;
  missionGenTimer = setTimeout(() => {
    const btn = document.getElementById('generateMission');
    if (btn) btn.click();
    scheduleMissionGeneration();
  }, delay);
}

function setMissionGenerationSpeed(range) {
  if (missionGenTimer) clearTimeout(missionGenTimer);
  missionGenRange = range;
  if (range) scheduleMissionGeneration();
}

document.querySelectorAll('.mission-speed').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mission-speed').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    switch (btn.dataset.speed) {
      case 'pause':
        setMissionGenerationSpeed(null);
        break;
      case 'slow':
        setMissionGenerationSpeed([90,150]);
        break;
      case 'medium':
        setMissionGenerationSpeed([30,90]);
        break;
      case 'fast':
        setMissionGenerationSpeed([10,30]);
        break;
    }
  });
});

// Focus
document.addEventListener("click", (e)=>{
  if (e.target.classList.contains("focus-mission") || e.target.classList.contains("focus-station")) {
    const lat = parseFloat(e.target.dataset.lat);
    const lon = parseFloat(e.target.dataset.lon);
    map.setView([lat, lon], 16);
  }
});

// Assign personnel modal
async function openAssignModal(unitId, stationId) {
  const modal = document.getElementById("assignPersonnelModal");
  const content = document.getElementById("assignModalContent");

  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();

  const unassigned = personnel.filter(p => !p.unit_id);

  if (!unassigned.length) {
    content.innerHTML = "<p>No available personnel to assign.</p>";
    modal.style.display = "block";
    return;
  }

  content.innerHTML = `
    <select id="assign-personnel-select" style="width:100%;">
      ${unassigned.map(p => `
        <option value="${p.id}">${p.name || '(no name)'}${Array.isArray(p.training) && p.training.length ? ` (${p.training.join(', ')})` : ''}</option>
      `).join('')}
    </select>
    <br><br>
    <button id="assignPersonnelConfirm">Assign</button>
  `;

  document.getElementById("assignPersonnelConfirm").onclick = async () => {
    const select = document.getElementById("assign-personnel-select");
    const pid = parseInt(select.value, 10);
    if (!pid) return;
    await assignPersonnel(pid, unitId, stationId);
  };

  modal.style.display = "block";
}

async function cancelUnit(unitId, stationId) {
  if (!confirm('Cancel this unit?')) return;

  let mission = null;
  try {
    mission = await fetch(`/api/units/${unitId}/mission`).then(r => r.ok ? r.json() : null);
  } catch {}

  if (mission && mission.id) {
    await clearAssignedUnit(mission.id, unitId);
    await checkMissionCompletion(mission);
  } else {
    const unit = _unitById.get(unitId);
    const st = unit ? _stationById.get(unit.station_id) : null;
    if (unit && st) {
      unit.responding = false;
      _unitById.set(unitId, unit);
      ensureUnitMarker(unit);
      const entry = unitMarkers.get(unit.id);
      const current = entry?.marker.getLatLng() || L.latLng(st.lat, st.lon);
      routeAndAnimateUnit(
        unit.id,
        [current.lat, current.lng],
        [st.lat, st.lon],
          TRAVEL_SPEED[unit.class] || 56,
        () => {
          const rp = unitRoutes.get(unit.id);
          if (rp) { try { map.removeLayer(rp); } catch {} unitRoutes.delete(unit.id); }
          fetch(`/api/unit-travel/${unit.id}`, { method:'DELETE' }).catch(()=>{});
        },
        { phase: 'return' }
      );
      await fetch(`/api/units/${unitId}/status`, {
        method:'PATCH',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ status:'available' })
      });
    }
  }

  refreshStationPanelNoCache(stationId);
}

async function showUnitDetails(unitId) {
  const modal = document.getElementById("unitDetailModal");
  const content = document.getElementById("unitDetailContent");

  const unit = _unitById.get(unitId);
  const station = unit ? _stationById.get(unit.station_id) : null;
  let mission = null;
  try {
    mission = await fetch(`/api/units/${unitId}/mission`).then(r => r.ok ? r.json() : null);
  } catch {}

  const res = await fetch(`/api/personnel?station_id=${unit?.station_id ?? ''}`);
  const personnel = await res.json();
  const assigned = personnel.filter(p => p.unit_id === unitId);

  const eqNames = Array.isArray(unit?.equipment)
    ? unit.equipment.map(e => typeof e === 'string' ? e : e?.name).filter(Boolean)
    : [];

  const equipmentHtml = eqNames.length
    ? `<ul>${eqNames.map(n => `<li>${n} <button class="remove-equip-btn" data-name="${n}">Remove</button></li>`).join('')}</ul>`
    : '<em>No equipment</em>';
  const availableEq = Array.isArray(station?.equipment) ? station.equipment : [];
  const assignHtml = availableEq.length
    ? `<select id="unit-equip-select">${availableEq.map(n=>`<option value="${n}">${n}</option>`).join('')}</select>
       <button id="assign-equip-btn">Assign</button>`
    : '<p><em>No equipment in station storage.</em></p>';

  const personnelHtml = assigned.length
    ? `<ul>${assigned.map(p => `
          <li>
            ${p.name || '(no name)'} ${Array.isArray(p.training) && p.training.length ? `(${p.training.join(', ')})` : ''}
            <button class="unassign-btn" data-person-id="${p.id}" data-station-id="${p.station_id}">Unassign</button>
          </li>
        `).join('')}</ul>`
    : '<p>No personnel assigned to this unit.</p>';

  const missionHtml = mission && mission.id
    ? `<p><strong>Current Mission:</strong> <span class="mission-link" data-missionid="${mission.id}" style="cursor:pointer; color:blue;">#${mission.id} ${mission.type}</span> <button id="cancel-mission-btn" data-missionid="${mission.id}">Cancel</button></p>`
    : '<p><strong>Current Mission:</strong> None</p>';
  const patrolHtml = `<p><label><input type="checkbox" id="patrol-toggle" ${unit?.patrol ? 'checked' : ''}/> Patrol</label></p>`;

  content.innerHTML = `
    <p><strong>Name:</strong> ${unit?.name || 'Unknown'} <button id="edit-unit-btn">Edit</button></p>
    <p><strong>Priority:</strong> ${unit?.priority ?? 1}</p>
    <p><strong>Station:</strong> ${station?.name || 'Unknown'}</p>
    <p><strong>Vehicle Class:</strong> ${unit?.class || 'Unknown'} (${unit?.type || ''})</p>
    ${missionHtml}
    ${patrolHtml}
    <button id="change-unit-icon">Change Icon</button>
    <h4>Equipment Aboard</h4>
    ${equipmentHtml}
    <h4>Assign Equipment from Station</h4>
    ${assignHtml}
    <h4>Assigned Personnel</h4>
    ${personnelHtml}
  `;

  const patrolToggle = content.querySelector('#patrol-toggle');
  patrolToggle?.addEventListener('change', async () => {
    const val = patrolToggle.checked;
    await fetch(`/api/units/${unitId}/patrol`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ patrol: val })
    });
    _unitById.set(unitId, { ...unit, patrol: val });
  });

  const cancelBtn = content.querySelector('#cancel-mission-btn');
  cancelBtn?.addEventListener('click', async () => {
    const mid = parseInt(cancelBtn.dataset.missionid,10);
    await clearAssignedUnit(mid, unitId);
    modal.style.display = 'none';
  });

  content.querySelectorAll('.unassign-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const pid = parseInt(btn.dataset.personId, 10);
      const sid = parseInt(btn.dataset.stationId, 10);
      await fetch(`/api/personnel/${pid}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ unit_id: null })
      });
      modal.style.display = "none";
      showStationDetails({ id: sid });
    });
  });
  content.querySelectorAll('.remove-equip-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const name = btn.dataset.name;
      const res = await fetch(`/api/units/${unitId}/equipment`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ station_id: unit.station_id, name })
      });
      const data = await res.json();
      if (!res.ok || !data.success) {
        alert(`Failed: ${data.error || res.statusText}`);
        return;
      }
      _unitById.set(unitId, { ...unit, equipment: data.equipment });
      modal.style.display = 'none';
      refreshStationPanelNoCache(unit.station_id);
    });
  });
  content.querySelector('#change-unit-icon')?.addEventListener('click', async () => {
    const url = prompt('Enter icon URL:', unit.icon || '');
    if (url === null) return;
    const resp = prompt('Enter responding icon URL (optional):', unit.responding_icon || '');
    const body = { icon: url };
    if (resp !== null) body.responding_icon = resp;
    const res = await fetch(`/api/units/${unitId}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    const data = await res.json();
    if (!res.ok || !data.success) { alert(`Failed: ${data.error || res.statusText}`); return; }
    _unitById.set(unitId, { ...unit, icon: url, responding_icon: resp });
    const entry = unitMarkers.get(unitId);
    if (entry) entry.marker.setIcon(unitIconFor({ ...unit, icon: url, responding_icon: resp }));
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });
  const assignBtn = content.querySelector('#assign-equip-btn');
  assignBtn?.addEventListener('click', async () => {
    const name = content.querySelector('#unit-equip-select').value;
    const res = await fetch(`/api/units/${unitId}/equipment`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ station_id: unit.station_id, name })
    });
    const data = await res.json();
    if (!res.ok || !data.success) {
      alert(`Failed: ${data.error || res.statusText}`);
      return;
    }
    _unitById.set(unitId, { ...unit, equipment: data.equipment });
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });

  content.querySelector('#edit-unit-btn')?.addEventListener('click', () => openUnitModal(unit));

  content.querySelector('.mission-link')?.addEventListener('click', async (e) => {
    const mid = parseInt(e.target.dataset.missionid, 10);
    try {
      const m = await fetch(`/api/missions/${mid}`).then(r => r.json());
      showMissionDetails(m);
    } catch {}
  });

  modal.style.display = "block";
}

async function unassignPersonnel(personnelId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ unit_id: null }) });
  document.getElementById("unitDetailModal").style.display = "none";
  showStationDetails({ id: stationId });
}

async function assignPersonnel(personnelId, unitId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ unit_id: unitId })
  });
  await showStationDetails({ id: stationId });
  const m = document.getElementById("assignPersonnelModal");
  if (m) m.style.display = "none";
}

function openUnitCreationForm(station) {
  const allowedTypes = unitTypes.filter(u => u.class === station.type);
  const unitName = prompt("Enter unit name (e.g., Engine 1):");
  if (!unitName) return;
  const unitTag = prompt("Enter unit tag (optional):") || '';
  const typeOptions = allowedTypes.map(u => u.type).join(', ');
  const selectedType = prompt(`Choose unit type (${typeOptions}):`);
  if (!allowedTypes.find(u => u.type === selectedType)) { alert("Invalid type for this station."); return; }
  fetch("/api/units", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ station_id: station.id, class: station.type, type: selectedType, name: unitName, tag: unitTag })
  }).then(res => res.json()).then(() => showStationDetails(station))
    .catch(err => { console.error("Failed to add unit:", err); alert("Error adding unit."); });
}

async function assignPersonnelToUnit(unitId, stationId) {
  const modal = document.getElementById('assignPersonnelModal');
  const content = document.getElementById('assignPersonnelContent');
  modal.style.display = 'block';
  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();
  const available = personnel.filter(p => !p.unit_id);
  if (!available.length) { content.innerHTML = "<p>No unassigned personnel at this station.</p>"; return; }
  content.innerHTML = available.map(p => `
    <div><label><input type="checkbox" value="${p.id}" /> ${p.name} (${(p.training||[]).join(', ')})</label></div>`).join('');
  const assignBtn = document.createElement("button");
  assignBtn.textContent = "Assign Selected";
  assignBtn.onclick = async () => {
    const selected = Array.from(content.querySelectorAll("input[type=checkbox]:checked")).map(c => parseInt(c.value));
    for (const id of selected) {
      await fetch(`/api/personnel/${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ unit_id: unitId }) });
    }
    modal.style.display = 'none';
    showStationDetails({ id: stationId });
  };
  content.appendChild(assignBtn);
}

// ===== manual dispatch with busy lockout + sort/filter =====
async function getBusyUnitIds() {
  const units = await (await fetch('/api/units')).json();
  return new Set(units.filter(u => u.status && u.status !== 'available').map(u => u.id));
}

function renderManualList(stations, unitsByStation, busyIds, mission) {
  const selectSort = document.getElementById('md-sort');
  const selectClass = document.getElementById('md-class');
  const inputType = document.getElementById('md-type');
  const sortVal = selectSort ? selectSort.value : 'distance';
  const classVal = selectClass ? selectClass.value : '';
  const typeFilter = (inputType ? inputType.value : '').toLowerCase();

  const flat = [];
  for (const st of stations) {
    const units = unitsByStation[st.id] || [];
    for (const u of units) flat.push({ st, u });
  }

  const filtered = flat.filter(({u}) => {
    if (classVal && u.class !== classVal) return false;
    if (typeFilter && !u.type?.toLowerCase().includes(typeFilter)) return false;
    return true;
  });

  const mLL = [mission.lat, mission.lon];
  filtered.sort((a,b)=>{
    if (sortVal==='distance') {
      const da = haversineKm(a.st.lat, a.st.lon, mLL[0], mLL[1]);
      const db = haversineKm(b.st.lat, b.st.lon, mLL[0], mLL[1]);
      return da-db;
    } else if (sortVal==='type') {
      return (a.u.type||'').localeCompare(b.u.type||'') || (a.u.name||'').localeCompare(b.u.name||'');
    }
    return (a.u.name||'').localeCompare(b.u.name||'');
  });

  const byStation = new Map();
  for (const row of filtered) {
    if (!byStation.has(row.st.id)) byStation.set(row.st.id, []);
    byStation.get(row.st.id).push(row.u);
  }

  const html = Array.from(byStation.entries()).map(([sid, units])=>{
    const st = stations.find(s=>s.id===sid);
    return `
      <div style="margin:8px 0; padding:8px; border:1px solid #ddd; border-radius:8px;">
        <strong>${st.name} (${st.type})</strong>
        <div style="display:grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap:6px; margin-top:6px;">
          ${units.map(u=>{
            const isBusy = busyIds.has(u.id);
            const disabled = isBusy ? 'disabled' : '';
            const note = isBusy ? ' <em>(busy)</em>' : '';
            return `<label style="display:block; border:1px solid #eee; padding:6px; border-radius:6px;">
                <input type="checkbox" value="${u.id}" ${disabled}>
                <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer; color:blue;">${u.name}</span> — ${u.type}${note}
              </label>`;
          }).join('')}
        </div>
      </div>`;
  }).join('');

  return html || '<em>No units match your filters.</em>';
}

async function openManualDispatch(mission) {
  const area = document.getElementById('manualDispatchArea');
  area.innerHTML = 'Loading units…';

  try {
    const stations = await fetch('/api/stations').then(r=>r.json());

    // Try the all-units endpoint first
    let allUnits = [];
    try {
      const r = await fetch('/api/units');
      if (r.ok) allUnits = await r.json();
    } catch {}

    // Fallback: pull per-station if the all-units call is empty or failed
    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      const perStation = await Promise.all(
        stations.map(st => fetch(`/api/units?station_id=${st.id}`).then(r=>r.ok ? r.json() : []))
      );
      allUnits = perStation.flat();
    }

    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      area.innerHTML = '<span style="color:#b00;">No units found. (Backend returned no units.)</span>';
      return;
    }

    cacheUnits(allUnits);

    const busyIds = new Set(
      allUnits.filter(u => u.status && u.status !== 'available').map(u => u.id)
    );

    const unitsByStation = allUnits.reduce((acc,u)=>{
      const sid = u.station_id;
      if (!acc[sid]) acc[sid] = [];
      acc[sid].push(u);
      return acc;
    },{});

    area.innerHTML = `
      <div style="display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap: wrap;">
        <label>Sort:
          <select id="md-sort">
            <option value="distance" selected>Distance to call</option>
            <option value="name">Name (A–Z)</option>
            <option value="type">Type</option>
          </select>
        </label>
        <label>Filter class:
          <select id="md-class">
            <option value="">All</option>
            <option value="fire">Fire</option>
            <option value="police">Police</option>
            <option value="ambulance">Ambulance</option>
          </select>
        </label>
        <label>Filter type:
          <input id="md-type" placeholder="e.g. Engine" style="width:120px;">
        </label>
        <button id="md-reset" type="button">Reset Filters</button>
      </div>
      <div style="margin:8px 0;">
        <button id="dispatchSelectedBtn">Dispatch Selected Units</button>
      </div>
      <div id="md-list">Building list…</div>`;

    const mdList = document.getElementById('md-list');
    const attach = ()=>{
      mdList.querySelectorAll('.unit-link').forEach(span=>{
        span.addEventListener('click',()=>showUnitDetails(parseInt(span.dataset.unitid,10)));
      });
    };
    const redraw = ()=>{ mdList.innerHTML = renderManualList(stations, unitsByStation, busyIds, mission); attach(); };
    document.getElementById('md-sort').onchange = redraw;
    document.getElementById('md-class').onchange = redraw;
    document.getElementById('md-type').oninput = redraw;
    document.getElementById('md-reset').onclick = ()=>{
      document.getElementById('md-sort').value = 'distance';
      document.getElementById('md-class').value = '';
      document.getElementById('md-type').value = '';
      redraw();
    };
    redraw();

    document.getElementById('dispatchSelectedBtn').onclick = () => dispatchSelectedUnits(mission.id);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Failed to load units.</span>';
  }
}

  async function sendUnitsToMission(mission, ids, area, force=false) {
    await Promise.all(ids.map(id => fetch('/api/mission-units',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ mission_id: mission.id, unit_id: id, ...(force ? { force: true } : {}) }) })));
  if (ids.length) playSound('/audio/dispatch.mp3');
  if (area) area.innerHTML = `<strong>Dispatched ${ids.length} unit(s) to mission #${mission.id}.</strong>`;
  const assigned = await refreshAssignedUnitsUI(mission.id);
  const reqDiv = document.getElementById('reqDynamic');
  if (reqDiv) { reqDiv.innerHTML = renderRequirementsDynamic(mission, assigned); attachPenaltyHandlers(mission); }
  const trainDiv = document.getElementById('reqTrainingDynamic');
  if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(mission, assigned);
  const equipDiv = document.getElementById('reqEquipmentDynamic');
  if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(mission, assigned);

  const allUnits = await (await fetch('/api/units')).json();
  cacheUnits(allUnits);

  for (const uid of ids) {
    const u = _unitById.get(uid);
    if (!u) continue;
    const st = _stationById.get(u.station_id);
    if (!st) continue;
    u.responding = true;
    u.status = 'enroute';
    _unitById.set(uid, u);
    const marker = ensureUnitMarker(u);
    if (!marker) continue;

    fetch(`/api/units/${uid}/status`, { method:'PATCH', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ status: 'enroute' }) });

    const current = marker.getLatLng ? marker.getLatLng() : L.latLng(st.lat, st.lon);
    const from = [current.lat, current.lng];
    const to   = [mission.lat, mission.lon];
      const spd  = TRAVEL_SPEED[u.class] || 56;

    routeAndAnimateUnit(
      uid, from, to, spd,
      async () => {
        await fetch(`/api/units/${uid}/status`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: 'on_scene' })
        });

        const entry = unitMarkers.get(uid);
        if (entry) { try { map.removeLayer(entry.marker); } catch {} unitMarkers.delete(uid); }

        if (window.unitRoutes && unitRoutes.has(uid)) {
          try { map.removeLayer(unitRoutes.get(uid)); } catch {}
          unitRoutes.delete(uid);
        }
        if (typeof clearUnitEta === 'function') clearUnitEta(uid);

        const assignedAfter = await refreshAssignedUnitsUI(mission.id);
        const reqDiv2 = document.getElementById('reqDynamic');
        if (reqDiv2) { reqDiv2.innerHTML = renderRequirementsDynamic(mission, assignedAfter); attachPenaltyHandlers(mission); }
        const trainDiv2 = document.getElementById('reqTrainingDynamic');
        if (trainDiv2) trainDiv2.innerHTML = renderTrainingRequirementsDynamic(mission, assignedAfter);
        const equipDiv2 = document.getElementById('reqEquipmentDynamic');
        if (equipDiv2) equipDiv2.innerHTML = renderEquipmentRequirementsDynamic(mission, assignedAfter);
        checkMissionCompletion(mission);
      },
      { mission_id: mission.id, phase: 'to_scene' }
    );
  }
}

async function dispatchSelectedUnits(missionId) {
  const area = document.getElementById('manualDispatchArea');
  const ids = Array.from(area.querySelectorAll('input[type="checkbox"]:checked')).map(cb=>parseInt(cb.value,10));
  if (!ids.length){ alert('Select at least one unit to dispatch.'); return; }
  try {
    const missions = await (await fetch('/api/missions')).json();
    const mission = missions.find(m=>m.id===missionId);
    if (!mission) { alert('Mission not found.'); return; }
    await sendUnitsToMission(mission, ids, area, true);
    openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  } catch (e) {
    console.error(e);
    alert('Failed to dispatch one or more units.');
  }
}

async function openUnitTypeDispatch(mission) {
  const area = document.getElementById('unitTypeDispatchArea');
  area.innerHTML = 'Loading units…';
  try {
    const [stations, units] = await Promise.all([
      fetch('/api/stations').then(r=>r.json()),
      fetch('/api/units?status=available').then(r=>r.json())
    ]);
    const stMap = new Map(stations.map(s=>[s.id,s]));
    const groups = new Map();
    units.forEach(u=>{
      const st = stMap.get(u.station_id);
      const dist = st ? haversineKm(mission.lat, mission.lon, st.lat, st.lon) : Infinity;
      const arr = groups.get(u.type) || [];
      arr.push({ ...u, distance: dist });
      groups.set(u.type, arr);
    });
    let html = '<div style="margin-bottom:6px;"><button id="closeUnitTypeDispatch">Close</button></div>';
    for (const [type, list] of groups.entries()) {
      const arr = list.sort((a,b)=>a.distance-b.distance);
      html += `<div><strong>${type}</strong> (${arr.length}) <button data-type="${type}" class="utd-send">Send 1</button></div>`;
    }
    area.innerHTML = html;
    document.getElementById('closeUnitTypeDispatch').onclick = () => { area.innerHTML = ''; };
    area.querySelectorAll('.utd-send').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const type = btn.dataset.type;
        const list = groups.get(type) || [];
        if (!list.length) { alert('No available units'); return; }
        const unit = list.shift();
        await sendUnitsToMission(mission, [unit.id], undefined, true);
        openUnitTypeDispatch(mission);
      });
    });
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Failed to load units.</span>';
  }
}

async function autoDispatch(mission) {
  const area = document.getElementById('manualDispatchArea');
  area.innerHTML = 'Selecting units…';
  try {
    const [stations, allUnitsRaw] = await Promise.all([
      fetch('/api/stations').then(r=>r.json()),
      fetch('/api/units?status=available').then(r=>r.json())
    ]);
    cacheStations(stations);
    const stMap = new Map(stations.map(s=>[s.id,s]));
    const allUnits = allUnitsRaw
      .filter(u=>{
        const st = stMap.get(u.station_id);
        const mDepts = Array.isArray(mission.departments) ? mission.departments : [];
        return mDepts.length === 0 || (st && mDepts.includes(st.department));
      })
      .map(u=>{
        const st = stMap.get(u.station_id);
        const dist = st ? haversineKm(st.lat, st.lon, mission.lat, mission.lon) : Infinity;
        const priority = Number(u.priority) || 1;
        return { ...u, priority, _dist: dist };
      });

    const sortUnits = (a,b)=>{
      if (a.station_id === b.station_id) return a.priority - b.priority;
      return a._dist - b._dist;
    };

    function trainingCount(u, name) {
      let c = 0;
      for (const p of Array.isArray(u.personnel)?u.personnel:[]) {
        for (const t of Array.isArray(p.training)?p.training:[]) {
          if (String(t).toLowerCase() === String(name).toLowerCase()) c++;
        }
      }
      return c;
    }
    function equipmentCount(u, name) {
      return Array.isArray(u.equipment)?u.equipment.filter(e=>String(e).toLowerCase()===String(name).toLowerCase()).length:0;
    }

    const selected = [];
    const selectedIds = new Set();

    const trainingNeeds = (Array.isArray(mission.required_training)?mission.required_training:[])
      .map(r=>({ name: r.training || r.name || r, qty: r.qty ?? r.quantity ?? r.count ?? 1 }));
    const equipmentNeeds = (Array.isArray(mission.equipment_required)?mission.equipment_required:[])
      .map(r=>({ name: r.name || r.type || r, qty: r.qty ?? r.quantity ?? r.count ?? 1 }));

    function applyNeeds(u) {
      for (const n of trainingNeeds) {
        n.qty -= trainingCount(u, n.name);
      }
      for (const n of equipmentNeeds) {
        n.qty -= equipmentCount(u, n.name);
      }
    }

    // subtract already assigned units (enroute/on_scene)
    const assigned = await fetchNoCache(`/api/missions/${mission.id}/units`).then(r=>r.json()).catch(()=>[]);
    const assignedCounts = {};
    for (const a of assigned) {
      if (!['enroute','on_scene'].includes(a.status)) continue;
      assignedCounts[a.type] = (assignedCounts[a.type] || 0) + 1;
      applyNeeds(a);
    }

    function unitMatchesNeed(u) {
      return trainingNeeds.some(n=>n.qty>0 && trainingCount(u,n.name)>0) ||
             equipmentNeeds.some(n=>n.qty>0 && equipmentCount(u,n.name)>0);
    }

    function unitMatchesAllNeeds(u) {
      return trainingNeeds.every(n=>n.qty<=0 || trainingCount(u,n.name)>0) &&
             equipmentNeeds.every(n=>n.qty<=0 || equipmentCount(u,n.name)>0);
    }

    function selectUnit(u) {
      selectedIds.add(u.id);
      selected.push(u);
      applyNeeds(u);
    }

    const reqUnits = Array.isArray(mission.required_units) ? mission.required_units : [];
    for (const r of reqUnits) {
      const types = Array.isArray(r.types) ? r.types : [r.type];
      let need = (r.quantity ?? r.count ?? r.qty ?? 1) - types.reduce((s,t)=>s+(assignedCounts[t]||0),0);
      for (let i=0; i<need; i++) {
        let candidates = allUnits.filter(u=>!selectedIds.has(u.id) && types.includes(u.type))
                                 .sort(sortUnits);
        if (!candidates.length) break;
        const chosen = candidates.find(unitMatchesAllNeeds) ||
                       candidates.find(unitMatchesNeed) ||
                       candidates[0];
        selectUnit(chosen);
      }
    }

    for (const n of trainingNeeds) {
      while (n.qty > 0) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && trainingCount(u,n.name)>0)
                                   .sort(sortUnits);
        if (!candidates.length) break;
        selectUnit(candidates[0]);
      }
    }

    for (const n of equipmentNeeds) {
      while (n.qty > 0) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && equipmentCount(u,n.name)>0)
                                   .sort(sortUnits);
        if (!candidates.length) break;
        selectUnit(candidates[0]);
      }
    }

    if (!selected.length) { area.innerHTML = '<em>No additional units available.</em>'; return; }
    const ids = selected.map(u=>u.id);
    await sendUnitsToMission(mission, ids, area);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Auto dispatch failed.</span>';
  }
}

async function runCardDispatch(mission) {
  let area = document.getElementById('manualDispatchArea');
  let tempArea = false;
  if (!area) {
    area = document.createElement('div');
    area.id = 'manualDispatchArea';
    area.style.display = 'none';
    document.body.appendChild(area);
    tempArea = true;
  }
  try {
    const res = await fetch(`/api/run-cards/${encodeURIComponent(mission.type)}`);
    if (!res.ok) { alert('No run card for this mission.'); return; }
    const rc = await res.json();
    const rcMission = {
      ...mission,
      departments: mission.departments || [],
      required_units: rc.units || [],
      required_training: rc.training || [],
      equipment_required: rc.equipment || []
    };
    await autoDispatch(rcMission);
  } catch (e) {
    console.error(e);
    alert('Run card dispatch failed.');
  } finally {
    if (tempArea) area.remove();
  }
}

async function dispatchRunCard() {
  if (window.currentMission) {
    await runCardDispatch(window.currentMission);
  }
}

async function clearAssignedUnit(missionId, unitId) {
  const res = await fetch('/api/mission-units',{ method:'DELETE', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ mission_id: missionId, unit_id: unitId }) });
  if (!res.ok) { const t = await res.text().catch(()=> ''); console.error('Unassign failed:', res.status, t); alert('Failed to clear unit from mission.'); return; }

  const [units, missions] = await Promise.all([ fetch('/api/units').then(r=>r.json()), fetch('/api/missions').then(r=>r.json()) ]);
  cacheUnits(units);
  const u = _unitById.get(unitId);
  const mission = missions.find(m=>m.id===missionId);
  const st = u && _stationById.get(u.station_id);
  if (u && mission && st) {
    ensureUnitMarker(u);
    const entry = unitMarkers.get(u.id);
    const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
    const from = [current.lat, current.lng];
    const to   = [st.lat, st.lon];
    routeAndAnimateUnit(
        u.id, from, to, TRAVEL_SPEED[u.class] || 56,
      () => { const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); } fetch(`/api/unit-travel/${u.id}`,{method:'DELETE'}).catch(()=>{}); },
      { phase: 'return' }
    );
  }
  const assigned = await refreshAssignedUnitsUI(missionId);
  if (document.getElementById('manualDispatchArea')) openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  const missionSnap = missions.find(m=>m.id===missionId);
  if (missionSnap) {
    const reqDiv = document.getElementById('reqDynamic');
    if (reqDiv) { reqDiv.innerHTML = renderRequirementsDynamic(missionSnap, assigned); attachPenaltyHandlers(missionSnap); }
    const trainDiv = document.getElementById('reqTrainingDynamic');
    if (trainDiv) trainDiv.innerHTML = renderTrainingRequirementsDynamic(missionSnap, assigned);
    const equipDiv = document.getElementById('reqEquipmentDynamic');
    if (equipDiv) equipDiv.innerHTML = renderEquipmentRequirementsDynamic(missionSnap, assigned);
  }
}

// Work timer / resolve
const activeWorkTimers = new Map();

function persistWorkTimers() {
  const arr = Array.from(activeWorkTimers.entries()).map(([id, obj]) => ({ id, endTime: obj.endTime }));
  try { localStorage.setItem('activeWorkTimers', JSON.stringify(arr)); }
  catch { /* ignore */ }
}

(function restoreWorkTimers(){
  try {
    const data = JSON.parse(localStorage.getItem('activeWorkTimers') || '[]');
    const now = Date.now();
    for (const { id, endTime } of data) {
      if (endTime > now) activeWorkTimers.set(id, { endTime });
    }
    persistWorkTimers();
  } catch {
    /* ignore */
  }
})();

function startMissionCountdown(missionId, endTime) {
  const existing = activeWorkTimers.get(missionId);
  if (existing && existing.intervalId) clearInterval(existing.intervalId);
  let iid;
  const update = () => {
    const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
    if (openMissionId === missionId) {
      const tDiv = document.getElementById('missionTimerArea');
      if (remaining <= 0) {
        if (tDiv) tDiv.textContent = 'Resolving…';
      } else if (tDiv) {
        const mins = Math.floor(remaining / 60);
        const secs = remaining % 60;
        tDiv.textContent = `Time remaining: ${mins}:${secs.toString().padStart(2, '0')}`;
      }
    }
    if (remaining <= 0 && iid) clearInterval(iid);
  };
  update();
  iid = setInterval(update, 1000);
  if (existing) {
    existing.intervalId = iid;
    existing.endTime = endTime;
  } else {
    activeWorkTimers.set(missionId, { endTime, intervalId: iid });
  }
  persistWorkTimers();
}

function setupTimerForMission(mission, endTime) {
  const existing = activeWorkTimers.get(mission.id);
  if (existing) {
    if (existing.timeoutId) clearTimeout(existing.timeoutId);
    if (existing.intervalId) clearInterval(existing.intervalId);
  }
  const ms = Math.max(0, endTime - Date.now());
  const tid = setTimeout(async ()=>{
    const cur = activeWorkTimers.get(mission.id);
    if (cur && cur.intervalId) clearInterval(cur.intervalId);
    activeWorkTimers.delete(mission.id);
    persistWorkTimers();
    const assignedBefore = await (await fetch(`/api/missions/${mission.id}/units`)).json();
    await fetch(`/api/missions/${mission.id}/resolve`, { method:'POST' });
    if (!_stationById || _stationById.size===0) {
      const stations = await (await fetch('/api/stations')).json();
      cacheStations(stations);
    }
    for (const u of assignedBefore) {
      const st = _stationById.get(u.station_id);
      if (!st) continue;
      u.responding = false;
      u.status = 'available';
      _unitById.set(u.id, u);
      ensureUnitMarker(u);
      const entry = unitMarkers.get(u.id);
      const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
      routeAndAnimateUnit(
        u.id,
        [current.lat, current.lng],
        [st.lat, st.lon],
          TRAVEL_SPEED[u.class] || 56,
        () => {
          const rp = unitRoutes.get(u.id);
          if (rp) { try { map.removeLayer(rp); } catch {} unitRoutes.delete(u.id); }
          fetch(`/api/unit-travel/${u.id}`, { method:'DELETE' }).catch(()=>{});
        },
        { phase: 'return' }
      );
    }
    await refreshAssignedUnitsUI(mission.id);
    await fetchMissions();
    const area = document.getElementById('manualDispatchArea');
    if (area) area.innerHTML = '<strong>Mission resolved.</strong>';
  }, ms);
  activeWorkTimers.set(mission.id, { timeoutId: tid, endTime });
  startMissionCountdown(mission.id, endTime);
  persistWorkTimers();
}

for (const [id, obj] of Array.from(activeWorkTimers.entries())) {
  startMissionCountdown(id, obj.endTime);
}

// Mission completion is now handled entirely by the server.
async function checkMissionCompletion() {
  return;
}

// Rebuild en-route after reload (using backend unit-travel)
async function rebuildEnrouteMarkers() {
  const [stations, allUnits] = await Promise.all([ fetch('/api/stations').then(r=>r.json()), fetch('/api/units').then(r=>r.json()) ]);
  cacheStations(stations);
  cacheUnits(allUnits);

  let travels = [];
  try { travels = await (await fetch('/api/unit-travel/active')).json(); }
  catch(e){ console.warn('No /api/unit-travel/active; fallback to old behavior.'); }

  if (Array.isArray(travels) && travels.length) {
    for (const t of travels) {
      const u = _unitById.get(t.unit_id);
      if (!u) continue;
      ensureUnitMarker(u);
      routeAndAnimateUnit(
          t.unit_id, t.from, t.to, TRAVEL_SPEED[u.class] || 56,
        async () => {
          if (t.phase === 'to_scene') {
            await fetch(`/api/units/${t.unit_id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'on_scene' }) });
          }
          const entry = unitMarkers.get(t.unit_id);
          if (t.phase === 'to_scene' && entry) { try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(t.unit_id); }
          const rp = unitRoutes.get(t.unit_id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(t.unit_id); }
          clearUnitEta(t.unit_id);
          fetch(`/api/unit-travel/${t.unit_id}`, { method:'DELETE' }).catch(()=>{});
          if (t.mission_id) {
            let mission = null;
            try {
              mission = await fetch(`/api/missions/${t.mission_id}`).then(r => r.json());
            } catch {}
            if (mission) checkMissionCompletion(mission);
          }
        },
        { saved: t }
      );
    }
    return;
  }

  // Fallback: naive restart-from-station if travel store is empty
  try {
    const missions = await (await fetch('/api/missions')).json();
    const active = missions.filter(m => m.status !== 'resolved');
    for (const m of active) {
      const assigned = await (await fetch(`/api/missions/${m.id}/units`)).json();
      for (const u of assigned) {
        if (u.status === 'enroute') {
          const st = _stationById.get(u.station_id);
          if (!st) continue;
          ensureUnitMarker(u);
            routeAndAnimateUnit(u.id, [st.lat, st.lon], [m.lat, m.lon], TRAVEL_SPEED[u.class] || 56, async ()=>{
            await fetch(`/api/units/${u.id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'on_scene' }) });
            const entry = unitMarkers.get(u.id); if (entry){ try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(u.id); }
            const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); }
            clearUnitEta(u.id);
            await refreshAssignedUnitsUI(m.id);
            checkMissionCompletion(m);
          });
        }
      }
    }
  } catch(e){ console.warn('Fallback rebuild failed:', e); }
}

// Init
(async () => {
  await fetchStations();
  await fetchMissions();
  setInterval(fetchMissions, 5000);
  await fetchZones();
  rebuildEnrouteMarkers();
})();
</script>

</body>
</html>
