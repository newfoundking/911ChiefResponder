<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Chief Responder</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
        <script src="/config/defaultEquipment.js"></script>
        <script src="js/notifications.js"></script>
        <script type="module" src="js/common.js"></script>
        <script type="module" src="js/forms.js"></script>
        <script type="module" src="js/edit-dialogs.js"></script>
        <style>
                :root {
                        color-scheme: dark;
                        --bg-main: #0b1220;
                        --bg-panel: #111b2d;
                        --bg-panel-alt: #15233d;
                        --bg-elevated: #1c2a47;
                        --border-soft: rgba(148, 163, 184, 0.25);
                        --text-primary: #f8fafc;
                        --text-muted: #cbd5f5;
                        --accent-primary: #38bdf8;
                        --accent-secondary: #6366f1;
                        --accent-success: #22c55e;
                        --accent-danger: #ef4444;
                        --shadow-strong: 0 16px 40px rgba(15, 23, 42, 0.55);
                        --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.35);
                        --radius-lg: 18px;
                        --radius-md: 12px;
                }
                html, body { height: 100%; margin: 0; overflow: hidden; }
                body {
                        display: flex;
                        height: 100vh;
                        font-family: "Inter", "Segoe UI", sans-serif;
                        color: var(--text-primary);
                        background: radial-gradient(circle at top left, #1e293b 0%, #0b1220 55%, #05070f 100%);
                }
                #sidebar {
                        max-width: 360px;
                        width: 100%;
                        padding: 18px;
                        box-sizing: border-box;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                        gap: 16px;
                        background: linear-gradient(160deg, rgba(17, 24, 39, 0.96), rgba(15, 23, 42, 0.92));
                        border-right: 1px solid var(--border-soft);
                        box-shadow: inset -1px 0 0 rgba(148, 163, 184, 0.1);
                }
                .sidebar-fixed {
                        flex: 0 0 auto;
                        background: var(--bg-panel);
                        border-radius: var(--radius-lg);
                        padding: 16px 16px 20px;
                        box-shadow: var(--shadow-soft);
                        z-index: 1;
                        border: 1px solid var(--border-soft);
                }
                .sidebar-lists {
                        flex: 1 1 auto;
                        overflow-y: auto;
                        background: rgba(15, 23, 42, 0.5);
                        border-radius: var(--radius-lg);
                        padding: 12px;
                        border: 1px solid var(--border-soft);
                }
                #map { flex: 1; position: relative; }
                #map::before {
                        content: "";
                        position: absolute;
                        inset: 0;
                        background: linear-gradient(135deg, rgba(15, 23, 42, 0.25), rgba(15, 23, 42, 0));
                        pointer-events: none;
                        z-index: 400;
                }
                h2 {
                        margin: 0 0 10px;
                        font-size: 1.4rem;
                        letter-spacing: 0.06em;
                        text-transform: uppercase;
                }
                .app-subtitle {
                        font-size: 0.85rem;
                        color: var(--text-muted);
                        margin-bottom: 18px;
                }
                .button {
                        border: 1px solid transparent;
                        border-radius: 999px;
                        padding: 0.55em 1.1em;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
                        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.3);
                        background: var(--bg-elevated);
                        color: var(--text-primary);
                }
                .button:hover {
                        transform: translateY(-1px);
                        box-shadow: 0 10px 20px rgba(15, 23, 42, 0.45);
                }
                .button-primary {
                        background: linear-gradient(120deg, var(--accent-primary), var(--accent-secondary));
                }
                .button-secondary {
                        border-color: rgba(148, 163, 184, 0.35);
                        background: rgba(15, 23, 42, 0.8);
                }
                .button-success {
                        background: linear-gradient(120deg, #22c55e, #10b981);
                }
                .button-danger {
                        background: linear-gradient(120deg, #ef4444, #f97316);
                }
                .status-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        padding: 0.4em 0.8em;
                        border-radius: 999px;
                        background: rgba(56, 189, 248, 0.15);
                        border: 1px solid rgba(56, 189, 248, 0.35);
                        color: var(--text-primary);
                        font-weight: 600;
                        margin-bottom: 12px;
                }
                .status-chip span {
                        color: var(--accent-primary);
                }
                .status-chip.compact {
                        padding: 0.35em 0.65em;
                        font-size: 0.85rem;
                        white-space: nowrap;
                }
                .map-search {
                        position: absolute;
                        top: 10px;
                        left: 50%;
                        transform: translateX(-50%);
                        display: flex;
                        gap: 0.5em;
                        align-items: center;
                        background: rgba(15, 23, 42, 0.85);
                        padding: 0.65em 0.85em;
                        border-radius: 999px;
                        box-shadow: var(--shadow-soft);
                        border: 1px solid rgba(148, 163, 184, 0.25);
                        z-index: 1000;
                        backdrop-filter: blur(8px);
                }
                .map-search input[type="text"] {
                        min-width: 220px;
                        padding: 0.35em 0.5em;
                        border: 1px solid rgba(148, 163, 184, 0.35);
                        border-radius: 999px;
                        background: rgba(15, 23, 42, 0.75);
                        color: var(--text-primary);
                }
                .map-search button[type="submit"] {
                        padding: 0.35em 0.75em;
                        border: none;
                        border-radius: 999px;
                        background: linear-gradient(120deg, #38bdf8, #6366f1);
                        color: var(--text-primary);
                        cursor: pointer;
                }
                .map-search__clear {
                        background: rgba(15, 23, 42, 0.45);
                        color: var(--text-muted);
                        border: 1px solid rgba(148, 163, 184, 0.35);
                        border-radius: 50%;
                        width: 28px;
                        height: 28px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1rem;
                        line-height: 1;
                }
                .map-search__clear:hover,
                .map-search__clear:focus {
                        border-color: rgba(148, 163, 184, 0.7);
                        background: rgba(15, 23, 42, 0.7);
                        outline: none;
                }
                .map-search-status {
                        position: absolute;
                        top: 62px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(15, 23, 42, 0.85);
                        color: var(--text-primary);
                        padding: 0.35em 0.75em;
                        border-radius: 4px;
                        box-shadow: var(--shadow-soft);
                        z-index: 999;
                        max-width: 80%;
                        text-align: center;
                        pointer-events: none;
                        border: 1px solid rgba(148, 163, 184, 0.25);
                }
                .map-search-status:empty {
                        display: none;
                }
		.mission {
                        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
                        margin-bottom: 1em;
                        padding-bottom: 0.5em;
                }
                .tab-button {
                        padding: 0.5em 1em;
                        border: 1px solid transparent;
                        background: rgba(30, 41, 59, 0.7);
                        cursor: pointer;
                        border-radius: 999px;
                        color: var(--text-muted);
                        font-weight: 600;
                        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.15);
                }
                .tab-button.active {
                        background: linear-gradient(120deg, rgba(56, 189, 248, 0.8), rgba(99, 102, 241, 0.8));
                        color: var(--text-primary);
                        font-weight: 700;
                        box-shadow: 0 8px 20px rgba(56, 189, 248, 0.25);
                }
                .mission-speed {
                        padding: 0.5em 1em;
                        border: 1px solid transparent;
                        background: rgba(30, 41, 59, 0.7);
                        cursor: pointer;
                        margin-right: 0.5em;
                        border-radius: 999px;
                        color: var(--text-muted);
                        font-weight: 600;
                }
                .mission-speed.active {
                        background: linear-gradient(120deg, rgba(14, 165, 233, 0.9), rgba(99, 102, 241, 0.9));
                        color: var(--text-primary);
                        font-weight: 700;
                }
                .tab-content { display: none; }
                .tab-content.active { display: block; }
                .tab-controls { display: none; margin-top: 1em; }
                .tab-controls.active { display: block; }
                .speed-controls {
                        display: flex;
                        gap: 0.5em;
                        flex-wrap: nowrap;
                        overflow-x: auto;
                        white-space: nowrap;
                }
                .mission-speed {
                        white-space: nowrap;
                }
                #stationDetails { max-width: 30%; overflow-y: auto; }
                .popup {
                        position: fixed;
                        top: 10%;
                        left: 30%;
                        width: 40%;
                        background: var(--bg-panel);
                        border: 1px solid var(--border-soft);
                        padding: 20px;
                        z-index: 9999;
                        max-height: 80%;
                        overflow-y: auto;
                        border-radius: var(--radius-lg);
                        box-shadow: var(--shadow-strong);
                }
                .hidden { display: none; }
                .modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        background: rgba(2, 6, 23, 0.7);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 20000;
                        overflow: auto;
                        backdrop-filter: blur(6px);
                }
                .mission-overlay {
                        position: fixed;
                        inset: 0;
                        background: rgba(2, 6, 23, 0.75);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 24px;
                        z-index: 20000;
                        backdrop-filter: blur(8px);
                }
                .mission-overlay.hidden {
                        display: none;
                }
                .mission-overlay__panel {
                        width: min(1200px, 92vw);
                        height: min(820px, 90vh);
                        background: var(--bg-panel);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-soft);
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                        box-shadow: var(--shadow-strong);
                }
                .mission-overlay__header {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        gap: 16px;
                        padding: 16px 20px;
                        background: var(--bg-panel-alt);
                        border-bottom: 1px solid var(--border-soft);
                }
                .mission-overlay__title {
                        font-size: 1.8rem;
                        font-weight: 700;
                }
                .mission-overlay__title-row {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        justify-content: space-between;
                        width: 100%;
                }
                .mission-overlay__meta-row {
                        display: flex;
                        gap: 12px;
                        flex-wrap: wrap;
                        color: var(--text-muted);
                        font-size: 0.9rem;
                }
                .mission-overlay__address {
                        color: var(--text-muted);
                }
                .mission-overlay__zones {
                        color: #fde68a;
                        font-weight: 600;
                }
                .mission-overlay__run-cards {
                        background: rgba(15, 23, 42, 0.55);
                        padding: 12px 20px;
                        border-top: 1px solid var(--border-soft);
                        border-bottom: 1px solid var(--border-soft);
                }
                .mission-overlay__body {
                        flex: 1;
                        display: grid;
                        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
                        gap: 16px;
                        padding: 16px 20px;
                        overflow: hidden;
                        background: rgba(15, 23, 42, 0.35);
                }
                .mission-overlay__column {
                        display: flex;
                        flex-direction: column;
                        gap: 12px;
                        min-height: 0;
                        overflow-y: auto;
                }
                .mission-overlay__right {
                        background: rgba(15, 23, 42, 0.65);
                        border: 1px solid rgba(148, 163, 184, 0.35);
                        border-radius: var(--radius-md);
                        padding: 16px;
                        box-shadow: var(--shadow-soft);
                }
                .mission-overlay__footer {
                        padding: 12px 20px;
                        border-top: 1px solid var(--border-soft);
                        background: var(--bg-panel-alt);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        flex-wrap: wrap;
                        gap: 12px;
                }
                .mission-overlay__timer {
                        color: #fde68a;
                        font-weight: 600;
                }
                .modal-content {
                        background: var(--bg-panel);
                        padding: 2rem;
                        max-width: 90%;
                        max-height: 90%;
                        overflow-y: auto;
                        border-radius: 16px;
                        box-shadow: var(--shadow-strong);
                        border: 1px solid var(--border-soft);
                }
                .close-btn,
                .next-btn {
                        position: absolute;
                        top: 8px;
                        border: none;
                        border-radius: 999px;
                        padding: 0.35em 0.75em;
                        font-weight: 600;
                        background: rgba(15, 23, 42, 0.8);
                        color: var(--text-primary);
                        cursor: pointer;
                        border: 1px solid rgba(148, 163, 184, 0.4);
                }
                .close-btn { right: 8px; }
                .next-btn { right: 60px; }
                .mission-icon { width: 30px; height: 30px; object-fit: contain; vertical-align: middle; }
                .unit-tag-icon {
                        width: var(--tag-width, 36px);
                        height: var(--tag-height, 24px);
                        line-height: var(--tag-height, 24px);
                        text-align: center;
                        color: white;
                        border: 2px solid transparent;
                        font-size: 12px;
                        font-weight: bold;
                }
                .unit-tag-icon.fire { background: red; }
                .unit-tag-icon.police { background: blue; }
                .unit-tag-icon.ambulance { background: green; }
                .unit-tag-icon.sar { background: orange; }
                .unit-tag-icon,
                .unit-tag-icon.responding {
                        border-radius: 8px;
                }
                .leaflet-marker-icon { overflow: visible !important; }
                .leaflet-pane, .leaflet-marker-pane { overflow: visible !important; }
                .unit-tag-icon.responding.fire,
                .unit-tag-icon.responding.ambulance,
                .unit-tag-icon.responding.sar {
                        animation: flash-rw 1s infinite;
                }
                .unit-tag-icon.responding.police {
                        animation: flash-rwb 1s infinite;
                }
                @keyframes flash-rw {
                        0%, 100% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                        50% {
                                border-color: white;
                                box-shadow: 0 0 6px 2px white;
                        }
                }
                @keyframes flash-rwb {
                        0% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                        33% {
                                border-color: white;
                                box-shadow: 0 0 6px 2px white;
                        }
                        66% {
                                border-color: blue;
                                box-shadow: 0 0 6px 2px blue;
                        }
                        100% {
                                border-color: red;
                                box-shadow: 0 0 6px 2px red;
                        }
                }

                /* Station list grouping styles */
                .dept-group { margin-bottom: 1em; }
                .dept-heading {
                        font-weight: bold;
                        padding: 0.45em 0.75em;
                        margin-bottom: 0.45em;
                        border-radius: 999px;
                        text-transform: uppercase;
                        letter-spacing: 0.04em;
                        font-size: 0.75rem;
                }
                .dept-heading.dept-fire { background: rgba(239, 68, 68, 0.2); color: #fecaca; border: 1px solid rgba(239, 68, 68, 0.5); }
                .dept-heading.dept-police { background: rgba(59, 130, 246, 0.2); color: #bfdbfe; border: 1px solid rgba(59, 130, 246, 0.5); }
                .dept-heading.dept-ambulance { background: rgba(34, 197, 94, 0.2); color: #bbf7d0; border: 1px solid rgba(34, 197, 94, 0.5); }
                .dept-heading.dept-sar { background: rgba(249, 115, 22, 0.2); color: #fed7aa; border: 1px solid rgba(249, 115, 22, 0.5); }
                .dept-heading.dept-hospital { background: rgba(148, 163, 184, 0.2); color: #e2e8f0; border: 1px solid rgba(148, 163, 184, 0.5); }
                .dept-heading.dept-jail { background: rgba(100, 116, 139, 0.3); color: #e2e8f0; border: 1px solid rgba(100, 116, 139, 0.6); }
                .station-entry { margin-bottom: 0.5em; }
                .station-info { display: flex; justify-content: space-between; align-items: center; }
                .station-info button { margin-left: 0.5em; }
                .sidebar-actions {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 0.6em;
                        margin-bottom: 1em;
                }
                .sidebar-actions .button {
                        flex: 1 1 auto;
                }
                .sidebar-top-row {
                        display: flex;
                        align-items: center;
                        gap: 0.75em;
                        flex-wrap: nowrap;
                        margin-bottom: 0.75em;
                }
                .sidebar-top-row .button {
                        flex: 0 0 auto;
                }
                #walletDisplay {
                        font-weight: 600;
                        color: var(--text-primary);
                        margin-top: 6px;
                }
                #walletDisplay span {
                        color: var(--accent-primary);
                }
                .panel-title {
                        font-size: 0.85rem;
                        text-transform: uppercase;
                        letter-spacing: 0.08em;
                        color: var(--text-muted);
                        margin-bottom: 8px;
                }
                .sidebar-tabs {
                        display: flex;
                        gap: 0.5em;
                        flex-wrap: wrap;
                        margin-top: 12px;
                        padding: 12px;
                        border-radius: var(--radius-lg);
                        background: rgba(15, 23, 42, 0.85);
                        border: 1px solid var(--border-soft);
                }
                .utility-toggle {
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        width: 44px;
                        height: 44px;
                        border-radius: 50%;
                        border: 1px solid rgba(148, 163, 184, 0.35);
                        background: rgba(15, 23, 42, 0.9);
                        color: var(--text-primary);
                        box-shadow: var(--shadow-soft);
                        cursor: pointer;
                        z-index: 20001;
                }
                .utility-panel {
                        position: fixed;
                        bottom: 80px;
                        right: 20px;
                        display: none;
                        flex-direction: column;
                        gap: 0.5em;
                        padding: 12px;
                        border-radius: var(--radius-lg);
                        background: rgba(15, 23, 42, 0.95);
                        border: 1px solid var(--border-soft);
                        box-shadow: var(--shadow-strong);
                        z-index: 20001;
                }
                .utility-panel.is-open {
                        display: flex;
                }
                input[type="text"],
                select {
                        background: rgba(15, 23, 42, 0.85);
                        border: 1px solid rgba(148, 163, 184, 0.4);
                        border-radius: 10px;
                        color: var(--text-primary);
                        padding: 0.45em 0.6em;
                }
                input[type="text"]::placeholder {
                        color: rgba(203, 213, 245, 0.7);
                }
                button:focus,
                input:focus,
                select:focus {
                        outline: 2px solid rgba(56, 189, 248, 0.45);
                        outline-offset: 2px;
                }
        </style>
</head>
<body>

<div id="sidebar">
        <div class="sidebar-fixed">
                <h2>Chief Responder</h2>
                <div class="app-subtitle">Operations overview & citywide response.</div>
                <div class="sidebar-top-row">
                        <button id="openCad" class="button button-secondary" onclick="location.href='cad.html'">Open CAD</button>
                        <div class="status-chip compact">
                                Balance <span id="walletDisplay">$0</span>
                        </div>
                </div>
                <div id="missionSpeedControls" class="speed-controls" style="margin-bottom:1em;">
                        <button class="mission-speed active" data-speed="pause">Pause</button>
                        <button class="mission-speed" data-speed="slow">Slow</button>
                        <button class="mission-speed" data-speed="medium">Medium</button>
                        <button class="mission-speed" data-speed="fast">Fast</button>
                </div>
                <div class="sidebar-actions">
                        <button id="startPatrols" class="button button-success">Start Patrols</button>
                </div>
                <script>
                function formatWholeCurrency(amount) {
                  return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                  }).format(Math.floor(Number(amount) || 0));
                }

                function setWalletBalanceDisplay(balance){
                  const el = document.getElementById('walletDisplay');
                  if (!el) return;
                  el.textContent = formatWholeCurrency(balance);
                }

                async function refreshWallet(){
                  const w = await fetch('/api/wallet').then(r=>r.json());
                  setWalletBalanceDisplay(w.balance);
                }
                setInterval(refreshWallet, 5000);
                refreshWallet();
                </script>
                <div class="tab-controls active" data-tab="missions">
                </div>
                <div class="tab-controls" data-tab="stations">
                        <button id="buildStation" class="button button-primary" style="margin-bottom: 1em;">Build New Station</button>
                </div>
                <div class="tab-controls" data-tab="zones">
                        <button id="addZoneBtn" class="button button-primary">Add Zone</button>
                        <button id="saveZoneEditBtn" class="button button-secondary" style="display:none;">Save Zone</button>
                </div>
                <div class="tab-controls" data-tab="units">
                        <div style="margin-bottom:0.5em; display:flex; gap:0.5em; flex-wrap:wrap;">
                                <input type="text" id="unitFilter" placeholder="Filter units..." style="flex:1; min-width:120px;" />
                                <select id="unitSort">
                                  <option value="status">Status</option>
                                  <option value="name">Name</option>
                                  <option value="priority">Priority</option>
                                </select>
                        </div>
                </div>
        </div>
        <div class="sidebar-lists">
                <div id="tab-missions" class="tab-content active">
                        <div id="missionList"></div>
                </div>
                <div id="tab-stations" class="tab-content">
                        <div id="stationList"></div>
                </div>
                <div id="tab-zones" class="tab-content">
                        <div id="zoneList"></div>
                </div>
                <div id="tab-units" class="tab-content">
                        <div id="unitList"></div>
                </div>
        </div>
        <div class="sidebar-tabs">
                <button class="tab-button active" data-tab="missions">Missions</button>
                <button class="tab-button" data-tab="stations">Stations</button>
                <button class="tab-button" data-tab="zones">Zones</button>
                <button class="tab-button" data-tab="units">Units</button>
        </div>
</div>

<div id="map">
        <form id="addressSearchForm" class="map-search">
                <input type="text" id="addressSearchInput" placeholder="Search address..." />
                <button type="submit">Search</button>
                <button type="button" id="addressSearchClear" aria-label="Clear search" title="Clear search" class="map-search__clear">✕</button>
        </form>
        <div id="addressSearchStatus" class="map-search-status"></div>
</div>

<button id="utilityToggle" class="utility-toggle" aria-expanded="false" aria-controls="utilityPanel" title="Toggle utilities">⚙️</button>
<div id="utilityPanel" class="utility-panel" aria-hidden="true">
        <button id="generateMission" class="button button-primary">Generate Mission</button>
        <button id="clearMissions" class="button button-danger">DEBUG CLEAR ALL CALLS</button>
</div>

<!-- Mission Details Overlay -->
<div id="missionDetails" class="mission-overlay hidden">
        <div class="mission-overlay__panel">
                <header class="mission-overlay__header">
                        <div class="mission-overlay__title-block">
				<div class="mission-overlay__title-row">
					<span id="missionTitle" class="mission-overlay__title">Mission</span>
					<span id="missionTimerArea" class="mission-overlay__timer"></span>
				</div>
				<div class="mission-overlay__meta-row">
					<div id="missionAddress" class="mission-overlay__address"></div>
					<div id="missionZones" class="mission-overlay__zones"></div>
				</div>
			</div>
                        <div class="mission-overlay__header-actions">
                                <button id="closeMissionBtn" class="close-btn" onclick="closeMissionDetails()">Close</button>
                        </div>
                        <button id="closeMissionBtn" class="incident-modal__close" onclick="closeMissionDetails()">Close</button>
                </header>

                <section class="mission-overlay__run-cards hidden">
                        <div class="mission-section-title">
                                <h4>Run Cards</h4>
                                <div class="mission-section-actions">
                                        <button id="createRunCardBtn">Create Run Card</button>
                                </div>
                        </div>
                        <div id="runCardList" class="run-card-list">Loading run cards…</div>
                </section>

                <section class="mission-overlay__body hidden">
                        <div class="mission-overlay__left mission-overlay__column">
                                <div class="mission-subsection">
                                        <div id="reqDynamic"></div>
                                        <div id="missionMeta"></div>
                                </div>
                                <div id="assignedUnitsArea" class="mission-assigned-list"></div>
                        </div>
                        <div class="mission-overlay__right mission-overlay__column hidden">
                                <div class="mission-dispatch-header">
                                        <h4 class="mission-dispatch-title">Dispatch Panel</h4>
                                        <button id="closeDispatchPanelBtn" class="close-btn" type="button">Close</button>
                                </div>
                                <div class="mission-distance-filter" id="missionDistanceFilter"></div>
                                <div class="mission-unit-controls">
                                        <div class="mission-units-tabs">
                                                <button class="mission-units-tab active" data-tab="available">Available Units</button>
                                                <button class="mission-units-tab" data-tab="oncall">Units on Call</button>
                                        </div>
                                        <div class="mission-unit-filters">
                                                <label>
                                                        Search
                                                        <input id="missionSearchFilter" type="text" placeholder="Name, type, station">
                                                </label>
                                                <label>
                                                        Department
                                                        <select id="missionDeptFilter"></select>
                                                </label>
                                                <label>
                                                        Type
                                                        <select id="missionTypeFilter"></select>
                                                </label>
                                                <label>
                                                        Sort
                                                        <select id="missionSortFilter">
                                                                <option value="distance">Distance</option>
                                                                <option value="name">Unit Name</option>
                                                                <option value="priority">Priority</option>
                                                        </select>
                                                </label>
                                        </div>
                                </div>
                                <div id="missionUnitList" class="mission-unit-list">Loading units…</div>
                        </div>
                </section>

                <footer class="mission-overlay__footer">
                        <div class="mission-footer-actions">
                                <button id="prevMissionBtnFooter" class="button">Back</button>
                                <button id="nextMissionBtnFooter" class="button">Next</button>
                                <button id="autoDispatchBtn" class="button button-primary">Auto Dispatch</button>
                                <button id="dispatchSelectedBtn" class="button button-primary">Dispatch</button>
                                <button id="dispatchNextBtn" class="button">Dispatch + Next</button>
                        </div>
                </footer>
        </div>
</div>

<!-- Station Creation Form -->
<div id="stationForm" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: var(--bg-panel); border: 1px solid var(--border-soft); padding: 1em;
	width: 320px; max-width: 30%; box-shadow: var(--shadow-strong);
	display: none; z-index: 10000;">
	<h3>Create Station</h3>

        <label for="stationName">Name:</label>
        <input type="text" id="stationName" style="width: 100%;" />
        <br><br>
        <label for="stationDept">Department:</label>
        <input type="text" id="stationDept" style="width: 100%;" />
        <br><br>
        <label for="stationType">Type:</label>
        <select id="stationType" style="width: 100%;">
                <option value="fire">Fire</option>
                <option value="fire_rescue">Fire Rescue</option>
                <option value="police">Police</option>
                <option value="ambulance">Ambulance</option>
                <option value="sar">SAR</option>
        </select>
	<br><br>
	<button id="createStation">Create</button>
	<button onclick="document.getElementById('stationForm').style.display = 'none';">Cancel</button>
</div>

<!-- Unit Assignment Modal -->
<div id="assignPersonnelModal" style="
	position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
	background: var(--bg-panel); border: 1px solid var(--border-soft); padding: 1em;
	width: 320px; box-shadow: var(--shadow-strong);
	display: none; z-index: 10001;">
	<h3>Assign Personnel to Unit</h3>
	<div id="assignModalContent">Loading...</div>
        <button class="close-btn" onclick="document.getElementById('assignPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Personnel Modal -->
<div id="editPersonnelModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: var(--bg-panel); border: 1px solid var(--border-soft); padding: 1em;
        width: 320px; box-shadow: var(--shadow-strong);
        display: none; z-index: 10001;">
        <h3>Edit Personnel</h3>
        <div id="editPersonnelContent">Loading...</div>
        <button class="close-btn" onclick="document.getElementById('editPersonnelModal').style.display = 'none';">Close</button>
</div>

<!-- Edit Unit Modal -->
<div id="editUnitModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: var(--bg-panel); border: 1px solid var(--border-soft); padding: 1em;
        width: 320px; box-shadow: var(--shadow-strong);
        display: none; z-index: 10001;">
        <h3>Edit Unit</h3>
        <div id="editUnitContent">Loading...</div>
        <button class="close-btn" onclick="document.getElementById('editUnitModal').style.display = 'none';">Close</button>
</div>

<!-- Unit Detail Modal -->
<div id="unitDetailModal" style="
        position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
        background: var(--bg-panel); border: 1px solid var(--border-soft); padding: 1em;
        width: 320px; box-shadow: var(--shadow-strong);
        display: none; z-index: 10001; max-height: 80vh; overflow-y: auto;">
        <h3>Unit Details</h3>
        <div id="unitDetailContent">Loading...</div>
        <button class="close-btn" onclick="document.getElementById('unitDetailModal').style.display = 'none';">Close</button>
</div>

<div id="cadPopup" class="popup hidden">
  <h3 id="cadTitle"></h3>
  <p id="cadType"></p>
  <p id="cadRequired"></p>
  <button onclick="dispatchAuto()">Dispatch (Auto)</button>
  <button onclick="dispatchRecommended()">Dispatch (Recommended)</button>
    <button onclick="dispatchRunCard()">Dispatch (Run Card)</button>
    <button onclick="manualDispatch()">Manual Dispatch</button>
    <button class="close-btn" onclick="closeCad()">Close</button>
  </div>

<div id="stationDetails"></div>
<script src="/config/unitTypes.js"></script>
<script src="/config/trainings.js"></script>
<script src="/config/equipment.js"></script>

<script>
// ========= constants / helpers =========
// CLASS_SPEED is provided by /config/unitTypes.js
const TRAVEL_SPEED = unitTypes.reduce((acc, u) => {
  acc[u.type] = u.speed || CLASS_SPEED[u.class] || 63;
  return acc;
}, {});

function findUnitDefinitionByType(unitClass, unitType) {
  const cls = String(unitClass || '').toLowerCase();
  const type = String(unitType || '').toLowerCase();
  return (unitTypes || []).find(
    (u) => String(u.class || '').toLowerCase() === cls && String(u.type || '').toLowerCase() === type
  ) || null;
}

function defaultSeatCapacity(unitClass, unitType) {
  const def = findUnitDefinitionByType(unitClass, unitType);
  return Number(def?.capacity || 0) || 0;
}
if (typeof window !== 'undefined') {
  window.defaultSeatCapacity = defaultSeatCapacity;
}

const FIRE_RESCUE_CLASSES = ['fire', 'ambulance'];
function stationUnitClasses(stationType) {
  return stationType === 'fire_rescue' ? FIRE_RESCUE_CLASSES.slice() : [stationType];
}
function stationUnitTypes(stationType, unitClass = null) {
  const classes = unitClass ? [unitClass] : stationUnitClasses(stationType);
  return (unitTypes || []).filter((u) => classes.includes(String(u.class || '').toLowerCase()));
}
function formatStationTypeLabel(value) {
  return String(value || '')
    .split('_')
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function normalizeUnitRecord(unit) {
  const base = unit || {};
  const priority = Number(base.priority) || 1;
  const defaultCap = Number(base.default_capacity ?? defaultSeatCapacity(base.class, base.type)) || 0;
  let seatOverride = base.seat_override;
  if (seatOverride !== null && seatOverride !== undefined) {
    seatOverride = Number(seatOverride);
    if (!Number.isFinite(seatOverride)) seatOverride = null;
  } else {
    seatOverride = null;
  }
  let seatCapacity;
  if (base.seat_capacity !== undefined && base.seat_capacity !== null) {
    seatCapacity = Number(base.seat_capacity);
  }
  if (!Number.isFinite(seatCapacity)) {
    seatCapacity = seatOverride != null ? seatOverride : defaultCap;
  }
  if (defaultCap > 0) {
    seatCapacity = Math.max(1, Math.min(defaultCap, seatCapacity || defaultCap));
    if (seatOverride != null) {
      seatOverride = Math.max(1, Math.min(defaultCap, seatOverride));
      if (seatOverride === defaultCap) seatOverride = null;
    }
  } else {
    seatCapacity = Math.max(0, seatCapacity || 0);
  }
  return {
    ...base,
    priority,
    seat_override: seatOverride,
    seat_capacity: seatCapacity,
    default_capacity: defaultCap,
  };
}

function haversineKm(aLat, aLon, bLat, bLon) {
  const R = 6371;
  const dLat = (bLat - aLat) * Math.PI/180;
  const dLon = (bLon - aLon) * Math.PI/180;
  const la1 = aLat * Math.PI/180, la2 = bLat * Math.PI/180;
  const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

// Refresh a single station panel with fresh data (no cache)
async function refreshStationPanelNoCache(stationId) {
  const stations = await fetchNoCache('/api/stations').then(r=>r.json());
  cacheStations(stations);
  const st = stations.find(s => s.id === stationId);
  if (st) showStationDetails(st);
}

function makeIcon(url, size) {
  return L.divIcon({
    html: `<img src="${url}" style="width:100%;height:100%;object-fit:contain;object-position:center bottom;">`,
    iconSize: [size, size],
    iconAnchor: [size / 2, size],
    className: ''
  });
}

function makeTagIcon(tag, unitClass, responding, width = 36, height = 24) {
  const classes = ['unit-tag-icon'];
  if (unitClass) classes.push(unitClass);
  if (responding) classes.push('responding');
  const cls = classes.join(' ');
  return L.divIcon({
    html: `<div class="${cls}" style="--tag-width:${width}px; --tag-height:${height}px;">${tag || ''}</div>`,
    iconSize: [width, height],
    iconAnchor: [width / 2, height],
    className: ''
  });
}

function cleanRankValue(value) {
  if (value === null || value === undefined) return '';
  const str = String(value).trim();
  return str;
}

function normalizeRankListInput(input) {
  let arr;
  if (Array.isArray(input)) {
    arr = input;
  } else if (typeof input === 'string') {
    arr = input.split(/[\n,]/);
  } else {
    arr = [];
  }
  const seen = new Set();
  const result = [];
  for (const item of arr) {
    const val = cleanRankValue(item);
    if (!val) continue;
    const key = val.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    result.push(val);
  }
  return result;
}

const departmentRankCache = new Map();

async function fetchDepartmentRanks(department) {
  const dept = cleanRankValue(department);
  if (!dept) return [];
  if (departmentRankCache.has(dept)) {
    return departmentRankCache.get(dept);
  }
  try {
    const res = await fetch(`/api/departments/${encodeURIComponent(dept)}/ranks`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    const ranks = Array.isArray(data?.ranks) ? data.ranks.map(cleanRankValue).filter(Boolean) : [];
    departmentRankCache.set(dept, ranks);
    return ranks;
  } catch (err) {
    console.warn('Failed to fetch ranks for', department, err);
    return [];
  }
}

function cacheDepartmentRanks(department, ranks) {
  const dept = cleanRankValue(department);
  if (!dept) return;
  departmentRankCache.set(dept, normalizeRankListInput(ranks));
}

async function promptManageDepartmentRanks(initialDepartment) {
  const initial = cleanRankValue(initialDepartment);
  const dept = initial || cleanRankValue(prompt('Enter department to configure ranks:'));
  if (!dept) return null;
  const existing = await fetchDepartmentRanks(dept);
  const response = prompt(
    `Enter ranks for ${dept} (comma-separated):`,
    existing.join(', ')
  );
  if (response === null) return null;
  const ranks = normalizeRankListInput(response);
  try {
    const res = await fetch(`/api/departments/${encodeURIComponent(dept)}/ranks`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ranks }),
    });
    const data = await res.json();
    if (!res.ok) throw new Error(data?.error || res.statusText);
    cacheDepartmentRanks(dept, ranks);
    if (typeof notifySuccess === 'function') {
      notifySuccess(`Saved ${ranks.length} rank${ranks.length === 1 ? '' : 's'} for ${dept}.`);
    }
    return { department: dept, ranks };
  } catch (err) {
    if (typeof notifyError === 'function') {
      notifyError(`Failed to save ranks: ${err.message || err}`);
    } else {
      alert(`Failed to save ranks: ${err.message || err}`);
    }
    return null;
  }
}

const missionIcons = {
  none: makeIcon("/warning1.png", 30),
  partial: makeIcon("/warning2.png", 30),
  complete: makeIcon("/warning3.png", 30)
};
const stationIcons = { fire: "/fire.png", fire_rescue: "/fire.png", police: "/police.png", ambulance: "/star.png", sar: "/sar.png", hospital: "/images/hospital.png", jail: "/images/prison.png" };

let missionMarkers = [];
let stationMarkers = [];
const stationMarkerById = new Map();
let buildStationMode = false;
  let pendingStationCoords = null;
  let openMissionId = null;
  let missionsCache = [];
  let missionUnitTab = 'available';
  let missionMaxDistance = 400;
  let missionRosterCache = null;
let missionDeptFilter = 'all';
let missionTypeFilter = 'all';
let missionSortFilter = 'distance';
let missionSearchFilter = '';

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      if (document.querySelector('.modal-overlay')) return;
      const open = Array.from(document.querySelectorAll('.popup:not(.hidden), [id$="Modal"], #missionDetails, #stationForm'))
        .filter(el => el.style.display !== 'none');
      const el = open.pop();
      if (el) {
        if (el.id === 'missionDetails') closeMissionDetails();
        else if (el.classList.contains('popup')) el.classList.add('hidden');
        else el.style.display = 'none';
      }
    }
  });

const map = L.map("map").setView([47.5646, -52.7002], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: "&copy; OpenStreetMap contributors" }).addTo(map);

const addressSearchForm = document.getElementById('addressSearchForm');
const addressSearchInput = document.getElementById('addressSearchInput');
const addressSearchStatus = document.getElementById('addressSearchStatus');
const addressSearchClearButton = document.getElementById('addressSearchClear');
let addressSearchMarker = null;

function formatShortAddressString(value) {
  if (!value || typeof value !== 'string') return '';
  const parts = value.split(',').map(part => part.trim()).filter(Boolean);
  if (parts.length <= 2) return value;
  return parts.slice(0, 2).join(', ');
}

function formatShortAddressFromNominatim(result) {
  const address = result?.address || {};
  const street = [address.house_number, address.road].filter(Boolean).join(' ');
  const locality = address.city || address.town || address.village || address.hamlet || address.municipality || address.county || address.suburb;
  const parts = [street, locality].filter(Boolean);
  if (parts.length) return parts.join(', ');
  return formatShortAddressString(result?.display_name || '');
}

addressSearchForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!addressSearchInput || !addressSearchStatus) return;
  const query = addressSearchInput.value.trim();
  if (!query) {
    addressSearchStatus.textContent = 'Please enter an address to search.';
    return;
  }

  addressSearchStatus.textContent = `Searching for "${query}"...`;

  try {
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&addressdetails=1`;
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json'
      }
    });
    if (!response.ok) {
      throw new Error(`Lookup failed with status ${response.status}`);
    }
    const data = await response.json();
    if (!Array.isArray(data) || data.length === 0) {
      addressSearchStatus.textContent = `No results found for "${query}".`;
      return;
    }

    const result = data[0];
    const lat = parseFloat(result.lat);
    const lon = parseFloat(result.lon);
    if (Number.isNaN(lat) || Number.isNaN(lon)) {
      throw new Error('Received invalid coordinates from geocoder.');
    }

    const zoom = 16;
    map.setView([lat, lon], zoom);
    if (addressSearchMarker) {
      map.removeLayer(addressSearchMarker);
    }
    addressSearchMarker = L.marker([lat, lon]);
    addressSearchMarker.addTo(map);
    const shortAddress = formatShortAddressFromNominatim(result);
    if (shortAddress) {
      addressSearchMarker.bindPopup(shortAddress).openPopup();
    }
    addressSearchStatus.textContent = shortAddress ? `Located: ${shortAddress}` : 'Location found.';
  } catch (error) {
    console.error('Address lookup failed', error);
    addressSearchStatus.textContent = `Error searching address: ${error.message || error}`;
  }
});

addressSearchClearButton?.addEventListener('click', () => {
  if (!addressSearchInput || !addressSearchStatus) return;
  addressSearchInput.value = '';
  addressSearchInput.focus();
  addressSearchStatus.textContent = '';
  if (addressSearchMarker) {
    map.removeLayer(addressSearchMarker);
    addressSearchMarker = null;
  }
});

const zoneLayerGroup = L.featureGroup();
const zoneLayers = new Map();
let responseZones = [];
const deptColors = {};
const colorPalette = ['red','blue','green','purple','orange','brown','pink','gray'];
function colorForDept(d){
  if(!deptColors[d]) deptColors[d] = colorPalette[Object.keys(deptColors).length % colorPalette.length];
  return deptColors[d];
}

function deptClassFor(type){
  switch(type){
    case 'fire': return 'dept-fire';
    case 'police': return 'dept-police';
    case 'ambulance': return 'dept-ambulance';
	case 'sar': return 'dept-sar';
    case 'hospital': return 'dept-hospital';
    case 'jail': return 'dept-jail';
    default: return '';
  }
}

function getTrainingsForClass(cls) {
  const key = String(cls || '').trim().toLowerCase();
  if (typeof trainingsByClass !== 'undefined' && trainingsByClass && trainingsByClass[key]) {
    return trainingsByClass[key];
  }
  return [];
}

// Tabs
document.querySelectorAll(".tab-button").forEach(button => {
  button.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    document.querySelectorAll(".tab-controls").forEach(c => c.classList.remove("active"));
    button.classList.add("active");
    document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
    document.querySelector(`.tab-controls[data-tab="${button.dataset.tab}"]`)?.classList.add("active");
    if (button.dataset.tab === 'zones') {
      map.addLayer(zoneLayerGroup);
    } else {
      map.removeLayer(zoneLayerGroup);
    }
    if (button.dataset.tab === 'units') {
      loadUnitsTab();
    }
  });
});

const utilityToggle = document.getElementById('utilityToggle');
const utilityPanel = document.getElementById('utilityPanel');
utilityToggle?.addEventListener('click', () => {
  if (!utilityPanel) return;
  const isOpen = utilityPanel.classList.toggle('is-open');
  utilityToggle.setAttribute('aria-expanded', String(isOpen));
  utilityPanel.setAttribute('aria-hidden', String(!isOpen));
});

document.getElementById('unitFilter')?.addEventListener('input', renderUnitList);
document.getElementById('unitSort')?.addEventListener('change', renderUnitList);

function unitIconFor(unit) {
  if (!unit.icon && !unit.responding_icon) {
    const tag = (unit.tag || unit.name || '').split(' ')[0].slice(0, 4).toUpperCase();
    return makeTagIcon(tag, unit.class, unit.responding);
  }
  const sanitizedType = (unit.type || '').replace(/\s+/g, '');
  const baseIcon = sanitizedType ? `/images/${sanitizedType}.png` : null;
  const respDefault = sanitizedType ? `/images/${sanitizedType}-responding.png` : null;
  const normal = unit.icon || baseIcon || stationIcons[unit.class] || stationIcons.fire;
  const responding = unit.responding_icon || respDefault || normal;
  const url = unit.responding ? responding : normal;
  return makeIcon(url, 24);
}

function chooseMissionIcon(mission, assigned) {
  const responders = (Array.isArray(assigned) ? assigned : [])
    .filter(u => u.status === 'enroute' || u.status === 'on_scene');
  if (responders.length === 0) return missionIcons.none;
  if (activeWorkTimers.has(mission.id)) return missionIcons.complete;
  return missionIcons.partial;
}

function missionIconUrl(mission, assigned) {
  const responders = (Array.isArray(assigned) ? assigned : [])
    .filter(u => u.status === 'enroute' || u.status === 'on_scene');
  if (responders.length === 0) return '/warning1.png';
  if (activeWorkTimers.has(mission.id)) return '/warning3.png';
  return '/warning2.png';
}

// caches
window._stationById = new Map();
window._unitById = new Map();

// registries
const unitMarkers = new Map(); // unitId -> { marker, animId }
const unitRoutes  = new Map(); // unitId -> L.Polyline
// track ETA timers for enroute units
const unitEtaTimers = new Map(); // unitId -> intervalId
const missionListTimers = new Map(); // missionId -> intervalId

function formatEta(seconds){
  const s = Math.max(0, Math.floor(seconds));
  const m = Math.floor(s / 60);
  const sec = s % 60;
  return `${m}:${sec.toString().padStart(2,'0')}`;
}

function setUnitEta(unitId, elem, startedAt, totalDuration){
  clearUnitEta(unitId);
  function update(){
    const elapsed = (Date.now() - new Date(startedAt).getTime())/1000;
    const remaining = Math.max(0, (totalDuration||0) - elapsed);
    const unit = _unitById.get(unitId);
    const statusText = formatStatus('enroute', unit?.responding);
    elem.textContent = `${statusText} (${formatEta(remaining)})`;
    if (remaining <= 0) clearUnitEta(unitId);
  }
  update();
  const iid = setInterval(update, 1000);
  unitEtaTimers.set(unitId, iid);
}

function clearUnitEta(unitId){
  const iid = unitEtaTimers.get(unitId);
  if (iid) clearInterval(iid);
  unitEtaTimers.delete(unitId);
}

function startMissionListTimer(id, endTime){
  const prev = missionListTimers.get(id);
  if (prev) clearInterval(prev);
  const elem = document.querySelector(`.mission-time[data-id="${id}"]`);
  if (!elem) return;
  let iid = null;
  function update(){
    const remaining = Math.max(0, (endTime - Date.now())/1000);
    elem.textContent = formatEta(remaining);
    if (remaining <= 0){
      clearInterval(iid);
      missionListTimers.delete(id);
    }
  }
  update();
  iid = setInterval(update, 1000);
  missionListTimers.set(id, iid);
}

function cacheStations(stations){
  _stationById = new Map(stations.map(s => [s.id, { ...s, department: s.department ?? null }]));
}
function cacheUnits(units){
  _unitById = new Map(units.map(u => [u.id, normalizeUnitRecord(u)]));
  if (document.getElementById('tab-units')?.classList.contains('active')) {
    renderUnitList();
  }
}

function centerOnUnit(unitId) {
  const unit = _unitById.get(unitId);
  if (!unit) return;
  ensureUnitMarker(unit);
  const entry = unitMarkers.get(unitId);
  if (entry) {
    map.setView(entry.marker.getLatLng(), Math.max(map.getZoom(), 13));
  }
}

function renderUnitList() {
  const list = document.getElementById('unitList');
  if (!list) return;
  const filter = document.getElementById('unitFilter')?.value.trim().toLowerCase() || '';
  const sort = document.getElementById('unitSort')?.value || 'status';
  let units = Array.from(_unitById.values());
  if (filter) {
    units = units.filter(u => (u.name || '').toLowerCase().includes(filter) ||
      (u.type || '').toLowerCase().includes(filter) ||
      (u.tag || '').toLowerCase().includes(filter));
  }
  if (sort === 'name') {
    units.sort((a,b) => (a.name || '').localeCompare(b.name || ''));
  } else if (sort === 'priority') {
    units.sort((a,b) => (b.priority || 0) - (a.priority || 0));
  } else {
    const order = { on_scene: 0, enroute: 1, available: 2 };
    units.sort((a,b) => (order[a.status] ?? 3) - (order[b.status] ?? 3) ||
      (a.name || '').localeCompare(b.name || ''));
  }
  list.innerHTML = units.map(u => `
    <div class="unit-entry">
      <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer;color:blue;">${u.name}</span>
      (${u.type}) - <span>${formatStatus(u.status, u.responding)}</span>
      <button class="center-unit" data-unitid="${u.id}">Center</button>
      ${u.status !== 'available' ? `<button class="cancel-unit" data-unitid="${u.id}" data-stationid="${u.station_id}">Cancel</button>` : ''}
    </div>`).join('');
  list.querySelectorAll('.unit-link').forEach(el => {
    el.addEventListener('click', () => showUnitDetails(parseInt(el.dataset.unitid, 10)));
  });
  list.querySelectorAll('.center-unit').forEach(el => {
    el.addEventListener('click', () => centerOnUnit(parseInt(el.dataset.unitid, 10)));
  });
  list.querySelectorAll('.cancel-unit').forEach(el => {
    el.addEventListener('click', async () => {
      await cancelUnit(parseInt(el.dataset.unitid, 10), parseInt(el.dataset.stationid, 10));
      renderUnitList();
    });
  });
}

async function loadUnitsTab() {
  try {
    const units = await fetch('/api/units').then(r => r.json());
    cacheUnits(units);
  } catch {}
  renderUnitList();
}

function ensureUnitMarker(unit) {
  const st = _stationById.get(unit.station_id);
  if (!st) return null;
  let entry = unitMarkers.get(unit.id);
  if (!entry) {
    const icon = unitIconFor(unit);
    const marker = L.marker([st.lat, st.lon], { icon, zIndexOffset: 1000 })
      .addTo(map)
      .on('click', () => showUnitDetails(unit.id));
    entry = { marker, animId: null };
    unitMarkers.set(unit.id, entry);
  } else {
    entry.marker.setIcon(unitIconFor(unit));
  }
  return entry.marker;
}

function animateMoveUnit(unitId, from, to, durationMs, onDone) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;
  const start = performance.now();
  function step(now) {
    const t = Math.min(1, (now - start) / durationMs);
    const lat = from[0] + (to[0] - from[0]) * t;
    const lon = from[1] + (to[1] - from[1]) * t;
    marker.setLatLng([lat, lon]);
    if (t < 1) entry.animId = requestAnimationFrame(step);
    else { entry.animId = null; if (onDone) onDone(); }
  }
  entry.animId = requestAnimationFrame(step);
}

// helpers for resume
function cumulative(segDurations){ const out=[0]; for(let i=0;i<segDurations.length;i++) out.push(out[i]+segDurations[i]); return out; }
function segmentAtElapsed(segDurations, elapsedSec){
  const cum = cumulative(segDurations);
  const total = cum[cum.length-1];
  const e = Math.max(0, Math.min(elapsedSec, total));
  let i=0; while(i<segDurations.length && e>cum[i+1]) i++;
  const segElapsed = e - cum[i];
  const segDur = Math.max(0.001, segDurations[i] || 0.001);
  const t = segElapsed / segDur;
  return { index: i, t, total };
}

function animateAlongRouteOffset(unitId, coords, segDurations, onDone, startOffsetSec = 0) {
  const entry = unitMarkers.get(unitId);
  if (!entry) return;
  if (entry.animId) cancelAnimationFrame(entry.animId);
  const marker = entry.marker;

  const { index: startIdx, t: t0 } = segmentAtElapsed(segDurations, startOffsetSec);
  let segIdx = startIdx;
  let segRemainingMs = (1 - t0) * Math.max(1, (segDurations[segIdx] || 0.001)) * 1000;

  const placeAt = (idx, t) => {
    const a = coords[idx], b = coords[idx+1] || coords[idx];
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);
  };
  placeAt(segIdx, t0);

  let segStart = performance.now();
  let segEnd   = segStart + segRemainingMs;

  function step(now) {
    if (segIdx >= segDurations.length || segIdx >= coords.length - 1) {
      if (onDone) onDone();
      entry.animId = null;
      return;
    }
    const a = coords[segIdx], b = coords[segIdx+1];
    const t = Math.min(1, (now - segStart) / (segEnd - segStart));
    const lat = a[0] + (b[0] - a[0]) * t;
    const lon = a[1] + (b[1] - a[1]) * t;
    marker.setLatLng([lat, lon]);

    if (t >= 1) {
      segIdx++;
      if (segIdx < segDurations.length && segIdx < coords.length - 1) {
        segStart = now;
        segEnd   = segStart + Math.max(1, segDurations[segIdx]) * 1000;
      }
    }
    entry.animId = requestAnimationFrame(step);
  }
  entry.animId = requestAnimationFrame(step);
}

// OSRM fetch
async function fetchRouteOSRM(from, to) {
  const url = `/api/route?from=${from[0]},${from[1]}&to=${to[0]},${to[1]}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`route ${res.status}`);
  const { coords, duration, annotations } = await res.json();
  return { coords, duration, annotations };
}

function drawRoute(unitId, coords) {
  try {
    const existing = unitRoutes.get(unitId);
    if (existing) { map.removeLayer(existing); unitRoutes.delete(unitId); }
    const poly = L.polyline(coords, { weight: 3, opacity: 0.35 });
    poly.addTo(map);
    unitRoutes.set(unitId, poly);
  } catch {}
}

async function routeAndAnimateUnit(unitId, from, to, speedClassKmh, onArrive, resumeOpts) {
  patrolStates.delete(unitId);
  try {
    // Resume with saved travel (from backend)
    if (resumeOpts?.saved) {
      const { coords, seg_durations, started_at } = resumeOpts.saved;
      drawRoute(unitId, coords);
      const u = _unitById.get(unitId) || { id: unitId, class: 'fire', station_id: 0 };
      ensureUnitMarker(u);
      const elapsedSec = Math.max(0, (Date.now() - new Date(started_at).getTime()) / 1000);
      animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, elapsedSec);
      return;
    }

    // Fresh route
    const { coords, duration, annotations } = await fetchRouteOSRM(from, to);
    const seg_durations = (annotations?.duration?.length === coords.length - 1)
      ? annotations.duration
      : Array.from({ length: coords.length - 1 }, () => duration / Math.max(1, coords.length - 1));

    // Light “emergency” multiplier
    const speedMultiplier = { fire: 1.2, police: 1.3, ambulance: 1.25, sar: 1.2 };
    const u = _unitById.get(unitId);
    const mult = u ? (speedMultiplier[u.class] || 1.0) : 1.0;
    const adjustedTotal = Math.max(5, duration / mult);

    // Persist to backend so we can resume on refresh
    try {
      await fetch('/api/unit-travel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          unit_id: unitId,
          mission_id: resumeOpts?.mission_id,
          phase: resumeOpts?.phase || 'to_scene',
          started_at: new Date().toISOString(),
          from, to,
          coords,
          seg_durations,
          total_duration: adjustedTotal
        })
      });
    } catch (e) { console.warn('Failed to persist travel:', e); }

    drawRoute(unitId, coords);
    ensureUnitMarker(u || { id: unitId, station_id: 0, class: 'fire' });
    animateAlongRouteOffset(unitId, coords, seg_durations, onArrive, 0);
  } catch (err) {
    console.warn('OSRM route failed; straight-line fallback:', err);
    const R = 6371;
    const dLat = (to[0]-from[0]) * Math.PI/180;
    const dLon = (to[1]-from[1]) * Math.PI/180;
    const la1 = from[0] * Math.PI/180, la2 = to[0] * Math.PI/180;
    const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    const distKm = 2*R*Math.asin(Math.sqrt(h));
      const etaSec = Math.max(5, Math.round((distKm / (speedClassKmh || 56)) * 3600));
    animateMoveUnit(unitId, from, to, etaSec * 1000, onArrive);
  }
}

let missionTemplates = [];
fetch('/api/mission-templates')
  .then(r => r.json())
  .then(data => { missionTemplates = data.map(t => ({ ...t, frequency: Number(t.frequency) || 3 })); })
  .catch(err => console.error('Failed to load mission templates:', err));

// UI helpers
function closeModal(){ const m = document.querySelector(".modal-overlay"); if (m) m.remove(); }

// Cache mission addresses by ID to avoid duplicate reverse-geocoding lookups.
const missionAddressCache = {};
async function reverseGeocode(lat, lon, id) {
  if (id && missionAddressCache[id]) return missionAddressCache[id];
  try {
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`);
    if (!res.ok) throw new Error('Reverse geocode failed');
    const data = await res.json();
    const addr = formatShortAddressFromNominatim(data) || `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    if (id) missionAddressCache[id] = addr;
    return addr;
  } catch (err) {
    console.warn('Reverse geocode error:', err);
    return `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
  }
}

function sortMissions(missions) {
  const level = m => {
    if (m.resolve_at) return 3;
    return (m.assigned_count > 0) ? 2 : 1;
  };
  return missions
    .filter(m => m.status !== 'resolved')
    .map(m => ({ ...m, level: level(m) }))
    .sort((a, b) => {
      const diff = a.level - b.level;
      if (diff !== 0) return diff;
      return (a.id || 0) - (b.id || 0);
    });
}

async function fetchMissions() {
  try {
    const res = await fetch("/api/missions");
      let missions = await res.json();
      missions = sortMissions(missions);
      missionsCache = missions;

      const missionById = new Map(missions.map(m => [m.id, m]));
    const missionIds = new Set(missionById.keys());
    for (const [id, iid] of Array.from(missionListTimers.entries())) {
      const m = missionById.get(id);
      if (!m || !Number.isFinite(m.resolve_at)) {
        clearInterval(iid);
        missionListTimers.delete(id);
      }
    }

    missionMarkers.forEach(m => map.removeLayer(m));
    missionMarkers = [];

    const missionList = document.getElementById("missionList");
    const scrollPos = missionList.scrollTop;
    const existingEls = new Map(Array.from(missionList.children).map(el => [Number(el.dataset.id), el]));

    const valid = missions.filter(m => Number.isFinite(m.lat) && Number.isFinite(m.lon));
    const assignedList = await Promise.all(
      valid.map(m => fetch(`/api/missions/${m.id}/units`).then(r => r.json()).catch(() => []))
    );
    const addresses = await Promise.all(
      valid.map(m => {
        if (m.address) {
          missionAddressCache[m.id] = m.address;
          return m.address;
        }
        return reverseGeocode(m.lat, m.lon, m.id);
      })
    );
    for (let i = 0; i < valid.length; i++) {
      const m = valid[i];
      const assigned = assignedList[i];
      const address = formatShortAddressString(addresses[i] || '');
      const marker = L.marker([m.lat, m.lon], { icon: chooseMissionIcon(m, assigned) })
        .addTo(map)
        .on("click", () => showMissionDetails(m));

      missionMarkers.push(marker);

      let el = existingEls.get(m.id);
      if (!el) {
        el = document.createElement("div");
        el.className = "mission";
        el.dataset.id = m.id;
      } else {
        existingEls.delete(m.id);
        el.innerHTML = ""; // clear for rebuild
      }
      const endTime = Number(m.resolve_at);
      const timerSpan = Number.isFinite(endTime)
        ? `<span class="mission-time" data-id="${m.id}">${formatEta((endTime - Date.now())/1000)}</span>`
        : "";
      el.innerHTML = `
        <img src="${missionIconUrl(m, assigned)}" class="mission-icon">
        <strong class="focus-mission" data-lat="${m.lat}" data-lon="${m.lon}" style="cursor:pointer;">${m.type}</strong>
        ${timerSpan}<br>
        Address: ${address}<br>`;
      const btn = document.createElement('button');
      btn.textContent = 'Details';
      btn.style.marginLeft = '8px';
      btn.addEventListener('click', () => showMissionDetails(m));
      const firstBr = el.querySelector('br');
      if (firstBr) {
        el.insertBefore(btn, firstBr);
      } else {
        el.appendChild(btn);
      }
      missionList.appendChild(el);
      if (Number.isFinite(endTime)) startMissionListTimer(m.id, endTime);
    }

    for (const el of existingEls.values()) {
      missionList.removeChild(el);
    }

    missionList.scrollTop = scrollPos;

      // Sync mission timers with server state
      const now = Date.now();
      const presentIds = new Set(missions.map(m => m.id));
    for (const [id, obj] of Array.from(activeWorkTimers.entries())) {
      if (!presentIds.has(id)) {
        if (obj.timeoutId) clearTimeout(obj.timeoutId);
        if (obj.intervalId) clearInterval(obj.intervalId);
        activeWorkTimers.delete(id);
      }
    }
    for (const m of missions) {
      const end = Number(m.resolve_at);
      if (end && end > now) {
        const ex = activeWorkTimers.get(m.id);
        if (!ex || ex.endTime !== end) {
          setupTimerForMission(m, end);
        }
      } else {
        const ex = activeWorkTimers.get(m.id);
        if (ex) {
          if (ex.timeoutId) clearTimeout(ex.timeoutId);
          if (ex.intervalId) clearInterval(ex.intervalId);
          activeWorkTimers.delete(m.id);
        }
      }
    }
    persistWorkTimers();
  } catch (err) {
    console.error("Failed to fetch missions:", err);
  }
}

// ===== Patrol helpers =====
const patrolStates = new Map();

async function startUnitPatrol(unit) {
  if (!unit || patrolStates.has(unit.id)) return;
  patrolStates.set(unit.id, true);
  const step = async () => {
    let travel = null;
    try {
      const travels = await fetch('/api/unit-travel/active').then(r => r.json());
      travel = travels.find(t => t.unit_id === unit.id);
    } catch {}
    if (!travel || travel.phase !== 'patrol') {
      if (_unitById.get(unit.id)?.patrol) { setTimeout(step, 1000); }
      else patrolStates.delete(unit.id);
      return;
    }
    ensureUnitMarker(unit);
    const speed = TRAVEL_SPEED[unit.type] || CLASS_SPEED[unit.class] || 63;
    routeAndAnimateUnit(unit.id, travel.from, travel.to, speed, step, { saved: travel, phase: 'patrol' });
    patrolStates.set(unit.id, true);
  };
  setTimeout(step, 200);
}

async function generateMissionAtPOI(poi) {
  const res = await fetch('/api/random-mission');
  const mission = await res.json();
  const { name, required_units } = mission;
  document.getElementById("cadTitle").textContent = name;
  const tagVal = poi.tags.amenity || poi.tags.building || poi.tags.leisure || poi.tags.tourism || poi.tags.shop || poi.tags.aeroway || poi.tags.landuse || poi.tags.office || poi.tags.man_made || poi.tags.name;
  document.getElementById("cadType").textContent = `POI: ${tagVal}`;
  const formatReq = r => {
    const types = Array.isArray(r.types) ? r.types : [r.type];
    const typeStr = types.join(' or ');
    const count = r.count ?? r.quantity ?? r.qty ?? 1;
    return `${count}x ${typeStr}`;
  };
  document.getElementById("cadRequired").textContent = required_units.map(formatReq).join(', ');
  document.getElementById("cadPopup").classList.remove('hidden');
  window.currentMission = mission;
}

function closeCad() {
  document.getElementById('cadPopup').classList.add('hidden');
}

// ===== Station list / details =====
async function fetchStations() {
  const res = await fetch("/api/stations");
  const stations = await res.json();
  cacheStations(stations);
  stationMarkers.forEach(m => map.removeLayer(m));
  stationMarkers = [];
  stationMarkerById.clear();
  const list = document.getElementById("stationList");
  list.innerHTML = "";

  const unitCounts = await Promise.all(
    stations.map(st => {
      if (st.type === 'hospital' || st.type === 'jail') return 0;
      return fetch(`/api/units?station_id=${st.id}`)
        .then(r=>r.json()).then(arr=>arr.length).catch(()=>0);
    })
  );

  const stationData = stations.map((st, idx) => {
    const used = unitCounts[idx];
    const free = (st.bay_count || 0) - used;
    const iconUrl = st.icon || stationIcons[st.type] || stationIcons.fire;
    const icon = makeIcon(iconUrl, 30);
    const marker = L.marker([st.lat, st.lon], { icon }).addTo(map).on("click", () => showStationDetails(st));
    stationMarkers.push(marker);
    stationMarkerById.set(st.id, marker);
    let info = '';
    if (st.type === 'hospital') {
      const cap = Math.max(0, Number(st.bed_capacity || 0));
      const active = Math.min(cap, Math.max(0, Number(st.occupied_beds || 0)));
      const waiting = Math.max(0, Number(st.staged_patients || 0));
      const bedFree = Math.max(0, cap - active);
      info = `Beds: ${active}/${cap} (Waiting: ${waiting}, Free: ${bedFree})`;
    } else if (st.type === 'jail' || (st.type === 'police' && Number(st.holding_cells) > 0)) {
      const cap = Math.max(0, Number(st.holding_cells || 0));
      const active = Math.min(cap, Math.max(0, Number(st.occupied_cells || 0)));
      const waiting = Math.max(0, Number(st.staged_prisoners || 0));
      const cellFree = Math.max(0, cap - active);
      info = `Cells: ${active}/${cap} (Waiting: ${waiting}, Free: ${cellFree})`;
      if (st.type === 'police') {
        info += ` | Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
      }
    } else {
      info = `Bays: ${used}/${st.bay_count || 0} (Free: ${free})`;
    }
    return { st, info };
  });

  const groups = {};
  stationData.forEach(({ st, info }) => {
    const dept = st.department || 'Unknown';
    if (!groups[dept]) groups[dept] = [];
    groups[dept].push({ st, info });
  });

  Object.keys(groups).sort().forEach(dept => {
    const groupEl = document.createElement('div');
    groupEl.className = 'dept-group';
    const deptType = groups[dept][0].st.type;
    const header = document.createElement('div');
    header.className = `dept-heading ${deptClassFor(deptType)}`;
    header.textContent = dept;
    groupEl.appendChild(header);

    groups[dept].sort((a,b) => a.st.name.localeCompare(b.st.name));
    groups[dept].forEach(({ st, info }) => {
      const stationEl = document.createElement('div');
      stationEl.className = 'station-entry';
      const nameDiv = document.createElement('div');
      nameDiv.innerHTML = `<strong class="focus-station" data-lat="${st.lat}" data-lon="${st.lon}" style="cursor:pointer;">${st.name}</strong>`;
      stationEl.appendChild(nameDiv);
      const infoDiv = document.createElement('div');
      infoDiv.className = 'station-info';
      const infoSpan = document.createElement('span');
      infoSpan.innerHTML = info;
      const btn = document.createElement('button');
      btn.textContent = 'Details';
      btn.addEventListener('click', () => showStationDetails(st));
      infoDiv.appendChild(infoSpan);
      infoDiv.appendChild(btn);
      stationEl.appendChild(infoDiv);
      groupEl.appendChild(stationEl);
    });
    list.appendChild(groupEl);
  });
}

async function fetchZones() {
  const res = await fetch('/api/response-zones');
  responseZones = await res.json();
  zoneLayerGroup.clearLayers();
  zoneLayers.clear();
  const list = document.getElementById('zoneList');
  if (list) list.innerHTML = '';
  responseZones.forEach(z => {
    const coords = (z.polygon?.coordinates || []).map(c => [c[0], c[1]]);
    const deptList = Array.isArray(z.departments) ? z.departments : [];
    const layer = L.polygon(coords, { color: colorForDept(deptList[0]) }).addTo(zoneLayerGroup);
    layer.bindPopup(`${z.name} [P${z.priority ?? 'null'}] (${deptList.join(', ')})`);
    layer.on('click', () => startEditZone(z.id));
    zoneLayers.set(z.id, layer);
    if (list) {
      const el = document.createElement('div');
      el.innerHTML = `${z.name} [P${z.priority ?? 'null'}] (${deptList.join(', ')}) <button class="edit-zone" data-id="${z.id}">Edit</button> <button class="delete-zone" data-id="${z.id}">Delete</button>`;
      list.appendChild(el);
    }
  });
  if (list) {
    list.querySelectorAll('.delete-zone').forEach(btn => {
      btn.onclick = async () => {
        await fetch(`/api/response-zones/${btn.dataset.id}`, { method: 'DELETE' });
        fetchZones();
      };
    });
    list.querySelectorAll('.edit-zone').forEach(btn => {
      btn.onclick = () => startEditZone(btn.dataset.id);
    });
  }
}

let editingZoneId = null;
function startEditZone(id) {
  const layer = zoneLayers.get(Number(id));
  if (!layer) return;
  editingZoneId = Number(id);
  layer.editing.enable();
  document.getElementById('saveZoneEditBtn').style.display = 'inline';
}

document.getElementById('saveZoneEditBtn').addEventListener('click', async () => {
  const id = editingZoneId;
  const layer = zoneLayers.get(id);
  if (!layer) return;
  layer.editing.disable();
  const latlngs = layer.getLatLngs()[0].map(p => [p.lat, p.lng]);
  const z = responseZones.find(r => r.id == id);
  const result = await openFormModal({
    title: 'Edit Zone',
    fields: [
      { name: 'name', label: 'Zone name', type: 'text', value: z?.name || '', required: true },
      { name: 'departments', label: 'Departments (comma-separated)', type: 'text', value: (z?.departments||[]).join(', ') },
      { name: 'priority', label: 'Priority (lower is higher)', type: 'number', value: z?.priority ?? '' }
    ]
  });
  if (!result) { editingZoneId = null; document.getElementById('saveZoneEditBtn').style.display = 'none'; fetchZones(); return; }
  const name = result.name.trim() || (z?.name || '');
  const departments = (result.departments || '').split(',').map(s=>s.trim()).filter(Boolean);
  const priority = result.priority === '' ? null : Number(result.priority);
  await fetch(`/api/response-zones/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, departments, priority, polygon: { coordinates: latlngs } })
  });
  editingZoneId = null;
  document.getElementById('saveZoneEditBtn').style.display = 'none';
  fetchZones();
});

document.getElementById('addZoneBtn').addEventListener('click', () => {
  new L.Draw.Polygon(map).enable();
});

map.on('draw:created', async e => {
  const latlngs = e.layer.getLatLngs()[0].map(p => [p.lat, p.lng]);
  const ring = latlngs.slice();
  if (ring.length && (ring[0][0] !== ring[ring.length - 1][0] ||
                      ring[0][1] !== ring[ring.length - 1][1])) {
    ring.push(ring[0]);
  }
  const stations = await fetch('/api/stations').then(r => r.json());
  const depts = [...new Set(stations.map(s => s.department).filter(Boolean))];
  const result = await openFormModal({
    title: 'Create Zone',
    fields: [
      { name: 'name', label: 'Zone name', type: 'text', value: 'Zone', required: true },
      { name: 'departments', label: `Departments (comma-separated) (${depts.join(', ')})`, type: 'text' },
      { name: 'priority', label: 'Priority (lower is higher)', type: 'number', value: '' }
    ]
  });
  if (!result) { map.removeLayer(e.layer); return; }
  const name = result.name.trim() || 'Zone';
  const departments = (result.departments || '').split(',').map(s=>s.trim()).filter(Boolean);
  const priority = result.priority === '' ? null : Number(result.priority);
  const newPoly = turf.polygon([ring.map(([lat, lng]) => [lng, lat])]);
  for (const z of [...responseZones]) {
    const existingRing = z.polygon.coordinates.slice();
    if (existingRing.length && (existingRing[0][0] !== existingRing[existingRing.length - 1][0] ||
                                existingRing[0][1] !== existingRing[existingRing.length - 1][1])) {
      existingRing.push(existingRing[0]);
    }
    const existing = turf.polygon([existingRing.map(([lat, lng]) => [lng, lat])]);
    const inter = turf.intersect(existing, newPoly);
    if (inter) {
      const diff = turf.difference(existing, newPoly);
      if (diff && diff.geometry && diff.geometry.coordinates.length) {
        const newCoords = diff.geometry.coordinates[0].map(([lng, lat]) => [lat, lng]);
        await fetch(`/api/response-zones/${z.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: z.name, departments: z.departments, priority: z.priority ?? null, polygon: { coordinates: newCoords } })
        });
      } else {
        await fetch(`/api/response-zones/${z.id}`, { method: 'DELETE' });
      }
    }
  }
  await fetch('/api/response-zones', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, departments, priority, polygon: { coordinates: latlngs } })
  });
  fetchZones();
});

async function refreshAssignedUnitsUI(missionId) {
  const div = document.getElementById('assignedUnitsArea');
  if (!div) return [];
  try {
    div.innerHTML = 'Loading assigned units…';
    const [res, travelRes] = await Promise.all([
      fetch(`/api/missions/${missionId}/units`),
      fetch('/api/unit-travel/active').catch(()=>null)
    ]);
    const assigned = await res.json();
    let travelMap = new Map();
    try {
      const travels = travelRes ? await travelRes.json() : [];
      travelMap = new Map(travels.map(t => [t.unit_id, t]));
    } catch {}
    (assigned||[]).forEach(u => _unitById.set(u.id, normalizeUnitRecord(u)));
    if (!Array.isArray(assigned) || !assigned.length) {
      div.innerHTML = '<em>No units assigned yet.</em>';
      return [];
    }
    div.innerHTML = `
      <div class="assigned-units-header">Assigned Units</div>
      <div class="assigned-units-table-wrapper">
        <table class="mission-assigned-table">
          <thead>
            <tr>
              <th>Unit</th>
              <th>Type</th>
              <th>Station</th>
              <th>Status</th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            ${assigned.map(u => {
              const station = _stationById.get(u.station_id);
              return `
                <tr>
                  <td><span class="unit-link" data-unitid="${u.id}">${u.name}</span></td>
                  <td>${u.type}</td>
                  <td>${station?.name || 'Unknown Station'}</td>
                  <td><span id="unit-status-${u.id}">${formatStatus(u.status || 'enroute', u.responding)}</span></td>
                  <td><button data-unitid="${u.id}" data-missionid="${missionId}" class="clear-unit-btn">Cancel</button></td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      </div>`;
    div.querySelectorAll('.unit-link').forEach(span => {
      span.addEventListener('click', () => showUnitDetails(parseInt(span.dataset.unitid,10)));
    });
    div.querySelectorAll('.clear-unit-btn').forEach(btn => {
      btn.onclick = async () => {
        btn.disabled = true;
        try { await clearAssignedUnit(parseInt(btn.dataset.missionid,10), parseInt(btn.dataset.unitid,10)); }
        finally { btn.disabled = false; }
      };
    });
    assigned.forEach(u => {
      const travel = travelMap.get(u.id);
      const statusEl = div.querySelector(`#unit-status-${u.id}`);
      if (u.status === 'enroute' && travel && statusEl) {
        setUnitEta(u.id, statusEl, travel.started_at, travel.total_duration);
      } else {
        clearUnitEta(u.id);
      }
    });
    return assigned;
  } catch (e) {
    console.error(e);
    div.innerHTML = '<span style="color:#b00;">Failed to load assigned units.</span>';
    return [];
  }
}

// ===== Dynamic requirements =====
function equipmentKey(name) {
  if (name === null || name === undefined) return '';
  const trimmed = String(name).trim();
  return trimmed ? trimmed.toLowerCase() : '';
}

function gatherUnitEquipment(unit) {
  const counts = new Map();
  if (!unit) return counts;
  const eqArr = Array.isArray(unit.equipment) ? unit.equipment : [];
  for (const eq of eqArr) {
    const label = typeof eq === 'string' ? eq : eq?.name;
    const key = equipmentKey(label);
    if (!key) continue;
    counts.set(key, (counts.get(key) || 0) + 1);
  }
  if (typeof getDefaultUnitEquipment === 'function') {
    const defaults = getDefaultUnitEquipment(unit.class, unit.type) || [];
    for (const provided of defaults) {
      const key = equipmentKey(provided);
      if (!key || counts.has(key)) continue;
      counts.set(key, 1);
    }
  }
  return counts;
}

function renderRequirementsDynamic(mission, assigned) {
  const reqUnits = Array.isArray(mission.required_units) ? mission.required_units : [];
  const reqTraining = Array.isArray(mission.required_training) ? mission.required_training : [];
  const reqEquipment = Array.isArray(mission.equipment_required) ? mission.equipment_required : [];
  const penalties = Array.isArray(mission.penalties) ? mission.penalties : [];

  // Count assigned units by status
  const unitCounts = { enroute: new Map(), on_scene: new Map() };
  for (const u of assigned || []) {
    if (u.status === 'on_scene') unitCounts.on_scene.set(u.type, (unitCounts.on_scene.get(u.type) || 0) + 1);
    else if (u.status === 'enroute') unitCounts.enroute.set(u.type, (unitCounts.enroute.get(u.type) || 0) + 1);
  }

  // Count training and equipment on assigned units
  const trainingCounts = { enroute: new Map(), on_scene: new Map() };
  const equipmentCounts = { enroute: new Map(), on_scene: new Map() };
  for (const u of assigned || []) {
    const tTarget = u.status === 'on_scene' ? trainingCounts.on_scene : (u.status === 'enroute' ? trainingCounts.enroute : null);
    const eTarget = u.status === 'on_scene' ? equipmentCounts.on_scene : (u.status === 'enroute' ? equipmentCounts.enroute : null);
    if (tTarget) {
      for (const p of Array.isArray(u.personnel) ? u.personnel : []) {
        for (const t of Array.isArray(p.training) ? p.training : []) {
          tTarget.set(t, (tTarget.get(t) || 0) + 1);
        }
      }
    }
    if (eTarget) {
      const provided = gatherUnitEquipment(u);
      for (const [key, count] of provided.entries()) {
        eTarget.set(key, (eTarget.get(key) || 0) + count);
      }
    }
  }

  // Build unit requirement list
  const unitItems = reqUnits.map(r => {
    const types = Array.isArray(r.types) ? r.types : [r.type];
    const typeStr = types.join(' or ');
    const baseNeed = r.quantity ?? r.count ?? 1;
    const ignored = penalties
      .filter(p => (p.category || 'vehicle') === 'vehicle' && types.includes(p.type))
      .reduce((s, p) => s + (p.quantity || 0), 0);
    const need = Math.max(0, baseNeed - ignored);
    const onScene = types.reduce((s, t) => s + (unitCounts.on_scene.get(t) || 0), 0);
    const enroute = types.reduce((s, t) => s + (unitCounts.enroute.get(t) || 0), 0);
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${typeStr} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });

  // Build training requirement list
  const trainingItems = reqTraining.map(r => {
    const baseNeed = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.training || r.name || r;
    const ignored = penalties
      .filter(p => p.category === 'training' && p.type === name)
      .reduce((s, p) => s + (p.quantity || 0), 0);
    const need = Math.max(0, baseNeed - ignored);
    const onScene = trainingCounts.on_scene.get(name) || 0;
    const enroute = trainingCounts.enroute.get(name) || 0;
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });

  // Build equipment requirement list
  const equipmentItems = reqEquipment.map(r => {
    const baseNeed = r.qty ?? r.quantity ?? r.count ?? 1;
    const name = r.name || r.type || r;
    const key = equipmentKey(name);
    const ignored = penalties
      .filter(p => p.category === 'equipment' && key && equipmentKey(p.type || p.name) === key)
      .reduce((s, p) => s + (p.quantity || 0), 0);
    const need = Math.max(0, baseNeed - ignored);
    const onScene = key ? (equipmentCounts.on_scene.get(key) || 0) : 0;
    const enroute = key ? (equipmentCounts.enroute.get(key) || 0) : 0;
    const outstanding = Math.max(0, need - enroute - onScene);
    return `<li>${need} × ${name} <small>(Outstanding: ${outstanding}, En route: ${enroute}, On scene: ${onScene})</small></li>`;
  });

  const unitBlocks = [];
  if (unitItems.length) {
    unitBlocks.push(`<p><strong>Unit Requirements:</strong></p><ul>${unitItems.join('')}</ul>`);
  }
  if (equipmentItems.length) {
    unitBlocks.push(`<p><strong>Equipment Required:</strong></p><ul>${equipmentItems.join('')}</ul>`);
  }
  if (!unitBlocks.length) unitBlocks.push('<em>No unit requirements.</em>');

  const personnelBlocks = [];
  if (trainingItems.length) {
    personnelBlocks.push(`<p><strong>Personnel Requirements:</strong></p><ul>${trainingItems.join('')}</ul>`);
  }
  if (!personnelBlocks.length) personnelBlocks.push('<em>No personnel requirements.</em>');

  let html = `
    <div class="req-grid">
      <div class="req-units">${unitBlocks.join('')}</div>
      <div class="req-personnel">${personnelBlocks.join('')}</div>
    </div>
  `;

  const options = Array.isArray(mission.penalty_options) ? mission.penalty_options : [];
  if (options.length) {
    const rows = options.map((p, idx) => {
      const checked = penalties.some(sel =>
        (sel.category || 'vehicle') === (p.category || 'vehicle') &&
        sel.type === p.type &&
        sel.quantity === p.quantity &&
        sel.timePenalty === p.timePenalty &&
        sel.rewardPenalty === p.rewardPenalty
      );
      return `<div><label><input type="checkbox" class="penalty-opt" data-idx="${idx}" ${checked ? "checked" : ""}> Ignore ${p.quantity}×${p.category ? p.category + ':' : ''}${p.type} (-${p.timePenalty || 0}% speed, -${p.rewardPenalty || 0}% reward)</label></div>`;
    });
    html += `<div class="req-penalties"><strong>Penalties:</strong>${rows.join('')}</div>`;
  }
  return html;
}

function attachPenaltyHandlers(mission) {
  document.querySelectorAll('.penalty-opt').forEach(cb => {
    cb.addEventListener('change', async () => {
      const options = Array.isArray(mission.penalty_options) ? mission.penalty_options : [];
      const selected = Array.from(document.querySelectorAll('.penalty-opt:checked')).map(c => {
        const opt = options[parseInt(c.dataset.idx,10)];
        return { ...opt, category: opt.category || 'vehicle' };
      });
      mission.penalties = selected;
      await fetch(`/api/missions/${mission.id}/penalties`, {
        method:'PATCH',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ penalties: selected })
      });
      await refreshAssignedUnitsUI(mission.id);
      checkMissionCompletion(mission);
    });
  });
}
// renderTrainingRequirementsDynamic and renderEquipmentRequirementsDynamic merged into renderRequirementsDynamic

function renderPatientInfo(mission) {
  const pts = Array.isArray(mission.patients) ? mission.patients : [];
  if (!pts.length) return '';
  const items = pts.map(p => {
    if (typeof p.count === 'number') {
      const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
      const parts = [String(p.count)];
      if (codes) parts.push(`Codes: ${codes}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const codes = Array.isArray(p.codes) ? p.codes.join(', ') : (p.codes || '');
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (codes) parts.push(`Codes: ${codes}`);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function renderPrisonerInfo(mission) {
  const prs = Array.isArray(mission.prisoners) ? mission.prisoners : [];
  if (!prs.length) return '';
  const items = prs.map(p => {
    if (typeof p.count === 'number') {
      const parts = [String(p.count)];
      if (Number.isFinite(p.transport)) parts.push(`Transport: ${p.transport}`);
      return `<li>${parts.join(', ')}</li>`;
    }
    // Fallback for legacy structure
    const chance = Number.isFinite(p.chance) ? `Chance: ${Math.round(p.chance * 100)}%` : '';
    const transport = Number.isFinite(p.transportChance) ? `Transport: ${Math.round(p.transportChance * 100)}%` : '';
    const parts = [`${p.min ?? 0}-${p.max ?? 0}`];
    if (chance) parts.push(chance);
    if (transport) parts.push(transport);
    return `<li>${parts.join(', ')}</li>`;
  });
  return `<ul>${items.join('')}</ul>`;
}

function showNextMission() {
  if (!missionsCache.length || openMissionId === null) return;
  const idx = missionsCache.findIndex(m => m.id === openMissionId);
  const next = missionsCache[(idx + 1) % missionsCache.length];
  if (next) showMissionDetails(next);
}

function showPrevMission() {
  if (!missionsCache.length || openMissionId === null) return;
  const idx = missionsCache.findIndex(m => m.id === openMissionId);
  const prev = missionsCache[(idx - 1 + missionsCache.length) % missionsCache.length];
  if (prev) showMissionDetails(prev);
}

function missionZonesFor(mission) {
  if (!Number.isFinite(mission.lat) || !Number.isFinite(mission.lon)) return [];
  const matches = responseZones.filter(z => pointInPolygon(mission.lat, mission.lon, z.polygon));
  matches.sort((a, b) => (a.priority ?? 9999) - (b.priority ?? 9999));
  return matches.map(z => z.name);
}

function formatRunCardSummary(title, items, labelKey) {
  if (!items?.length) return '';
  const lines = items.map((i) => {
    const qty = i.quantity ?? i.qty ?? i.count ?? 1;
    const label = i[labelKey] || i.type || i.name || i.training || i;
    return `${qty}×${label}`;
  });
  return `<div><strong>${title}:</strong> ${lines.join(', ')}</div>`;
}

function parseRunCardEntries(input, labelKey) {
  if (!input || !input.trim()) return [];
  return input
    .split(',')
    .map(part => part.trim())
    .filter(Boolean)
    .map(part => {
      const match = part.match(/^(.*?)(?:\\s*[:x*]\\s*(\\d+))?$/i);
      const label = match ? match[1].trim() : part.trim();
      const qty = match && match[2] ? parseInt(match[2], 10) : 1;
      if (!label) return null;
      if (labelKey === 'type') return { type: label, quantity: qty };
      if (labelKey === 'training') return { training: label, qty };
      return { name: label, qty };
    })
    .filter(Boolean);
}

async function fetchRunCardsForMission(missionType) {
  const res = await fetch(`/api/run-cards?mission=${encodeURIComponent(missionType)}`);
  if (!res.ok) return [];
  return res.json();
}

async function refreshRunCardList(mission) {
  const list = document.getElementById('runCardList');
  if (!list) return;
  list.innerHTML = 'Loading run cards…';
  const cards = await fetchRunCardsForMission(mission.type);
  const createCardHtml = `
    <div class="run-card run-card--create">
      <div class="run-card__header">
        <button class="run-card-dispatch run-card-create-btn" type="button">
          + Create New Run Card
        </button>
      </div>
      <div class="run-card__summary">Build a new run card template for this mission type.</div>
    </div>
  `;
  if (!cards.length) {
    list.innerHTML = `
      ${createCardHtml}
      <div class="run-card">
        <div class="run-card__summary"><em>No run cards saved for this call type.</em></div>
      </div>
    `;
  } else {
    list.innerHTML = [
      createCardHtml,
      ...cards.map(card => `
        <div class="run-card">
          <div class="run-card__header">
            <button class="run-card-dispatch run-card-title-btn" data-id="${card.id ?? ''}" data-source="${card.source || 'custom'}">
              ${card.label || 'Run Card'}
            </button>
            ${card.source === 'default' ? '<span class="run-card-badge">Default</span>' : ''}
          </div>
          <div class="run-card__summary">
            ${formatRunCardSummary('Units', card.units, 'type')}
            ${formatRunCardSummary('Training', card.training, 'training')}
            ${formatRunCardSummary('Equipment', card.equipment, 'name')}
          </div>
        </div>
      `)
    ].join('');
  }
  list.querySelectorAll('.run-card-create-btn').forEach(btn => {
    btn.addEventListener('click', () => openRunCardCreator(mission));
  });
  list.querySelectorAll('.run-card-dispatch').forEach(btn => {
    if (btn.classList.contains('run-card-create-btn')) return;
    btn.addEventListener('click', () => runCardDispatch(mission, {
      id: btn.dataset.id || null,
      source: btn.dataset.source || 'custom'
    }));
  });
}

async function openRunCardCreator(mission) {
  const result = await openFormModal({
    title: `Create Run Card for ${mission.type}`,
    fields: [
      { name: 'label', label: 'Run card name', type: 'text', required: true, placeholder: 'Downtown response' },
      { name: 'units', label: 'Units (comma-separated, e.g., Engine:2, Ladder:1)', type: 'text', placeholder: 'Engine:2, Ladder:1' },
      { name: 'training', label: 'Training (comma-separated, e.g., ALS:1)', type: 'text', placeholder: 'ALS:1' },
      { name: 'equipment', label: 'Equipment (comma-separated, e.g., Jaws:1)', type: 'text', placeholder: 'Jaws:1' }
    ]
  });
  if (!result) return;
  const payload = {
    mission_name: mission.type,
    label: result.label.trim(),
    units: parseRunCardEntries(result.units, 'type'),
    training: parseRunCardEntries(result.training, 'training'),
    equipment: parseRunCardEntries(result.equipment, 'equipment')
  };
  try {
    const res = await fetch('/api/run-cards', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const msg = await res.text();
      throw new Error(msg || 'Failed to save run card.');
    }
    await refreshRunCardList(mission);
  } catch (err) {
    console.error(err);
    notifyError('Failed to save run card.');
  }
}

async function updateMissionHeader(mission) {
  const titleEl = document.getElementById('missionTitle');
  const addressEl = document.getElementById('missionAddress');
  const zonesEl = document.getElementById('missionZones');
  if (titleEl) titleEl.textContent = mission.type;
  if (addressEl) {
    let address = mission.address || missionAddressCache[mission.id] || '';
    if (!address && Number.isFinite(mission.lat) && Number.isFinite(mission.lon)) {
      address = await reverseGeocode(mission.lat, mission.lon, mission.id);
    }
    const trimmed = formatShortAddressString(address);
    addressEl.textContent = trimmed || `${mission.lat?.toFixed(4) ?? ''}, ${mission.lon?.toFixed(4) ?? ''}`;
  }
  if (zonesEl) {
    const zones = missionZonesFor(mission);
    zonesEl.textContent = zones.length ? `Zones: ${zones.join(', ')}` : 'NO ZONE DATA';
  }
}

async function refreshMissionUnitRoster(mission) {
  const [stations, units] = await Promise.all([
    fetch('/api/stations').then(r => r.json()),
    fetch('/api/units').then(r => r.json())
  ]);
  cacheStations(stations);
  cacheUnits(units);
  const stationMap = new Map(stations.map(s => [s.id, s]));
  const rows = (units || []).map(u => {
    const station = stationMap.get(u.station_id);
    const dist = station ? haversineKm(station.lat, station.lon, mission.lat, mission.lon) : Infinity;
    return {
      unit: normalizeUnitRecord(u),
      station,
      distance: dist
    };
  }).filter(row => row.station);
  missionRosterCache = { missionId: mission.id, rows };
}

function formatDistance(distance) {
  if (!Number.isFinite(distance)) return '—';
  return `${distance.toFixed(1)} km`;
}

function estimateEta(distanceKm, unit) {
  if (!Number.isFinite(distanceKm)) return '—';
  const speed = TRAVEL_SPEED[unit.type] || CLASS_SPEED[unit.class] || 56;
  const seconds = (distanceKm / speed) * 3600;
  return formatEta(seconds);
}

function setMissionDistanceFilter(value) {
  missionMaxDistance = value;
  const buttons = document.querySelectorAll('.distance-filter-btn');
  buttons.forEach(btn => {
    btn.classList.toggle('active', Number(btn.dataset.value) === value);
  });
}

function renderMissionDistanceFilter(mission) {
  const container = document.getElementById('missionDistanceFilter');
  if (!container) return;
  const options = [1, 5, 10, 20, 40, 50, 100, 200, 300, 400];
  container.innerHTML = `
    <div class="mission-distance-title">Maximum distance from vehicle:</div>
    <div class="mission-distance-buttons">
      ${options.map(opt => `<button class="distance-filter-btn${opt === missionMaxDistance ? ' active' : ''}" data-value="${opt}">${opt} km</button>`).join('')}
    </div>
  `;
  container.querySelectorAll('.distance-filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      setMissionDistanceFilter(Number(btn.dataset.value));
      renderMissionUnitList(mission);
    });
  });
}

function renderMissionUnitFilters(rows) {
  const deptSelect = document.getElementById('missionDeptFilter');
  const typeSelect = document.getElementById('missionTypeFilter');
  const sortSelect = document.getElementById('missionSortFilter');
  const searchInput = document.getElementById('missionSearchFilter');
  if (!deptSelect || !typeSelect || !sortSelect || !searchInput) return;

  const departments = Array.from(new Set(rows.map(row => row.station?.department).filter(Boolean))).sort();
  const types = Array.from(new Set(rows.map(row => row.unit.type).filter(Boolean))).sort();

  deptSelect.innerHTML = ['all', ...departments].map(dep => `
    <option value="${dep}">${dep === 'all' ? 'All Departments' : dep}</option>
  `).join('');
  typeSelect.innerHTML = ['all', ...types].map(type => `
    <option value="${type}">${type === 'all' ? 'All Types' : type}</option>
  `).join('');

  if (![...departments, 'all'].includes(missionDeptFilter)) missionDeptFilter = 'all';
  if (![...types, 'all'].includes(missionTypeFilter)) missionTypeFilter = 'all';
  deptSelect.value = missionDeptFilter;
  typeSelect.value = missionTypeFilter;
  sortSelect.value = missionSortFilter;
  searchInput.value = missionSearchFilter;

  deptSelect.onchange = () => {
    missionDeptFilter = deptSelect.value;
    renderMissionUnitList(openMissionId ? missionsCache.find(m => m.id === openMissionId) : null);
  };
  typeSelect.onchange = () => {
    missionTypeFilter = typeSelect.value;
    renderMissionUnitList(openMissionId ? missionsCache.find(m => m.id === openMissionId) : null);
  };
  sortSelect.onchange = () => {
    missionSortFilter = sortSelect.value;
    renderMissionUnitList(openMissionId ? missionsCache.find(m => m.id === openMissionId) : null);
  };
  searchInput.oninput = () => {
    missionSearchFilter = searchInput.value;
    renderMissionUnitList(openMissionId ? missionsCache.find(m => m.id === openMissionId) : null);
  };
}

async function renderMissionUnitList(mission) {
  const list = document.getElementById('missionUnitList');
  if (!list) return;
  if (!mission) return;
  if (!missionRosterCache || missionRosterCache.missionId !== mission.id) {
    list.innerHTML = 'Loading units…';
    await refreshMissionUnitRoster(mission);
  }
  const baseRows = missionRosterCache?.rows || [];
  renderMissionUnitFilters(baseRows);
  const searchValue = missionSearchFilter.trim().toLowerCase();
  const rows = baseRows.filter(row => {
    if (row.distance > missionMaxDistance) return false;
    if (missionUnitTab === 'available') return (row.unit.status || 'available') === 'available';
    return (row.unit.status || 'available') !== 'available';
  }).filter(row => {
    if (missionDeptFilter !== 'all' && row.station?.department !== missionDeptFilter) return false;
    if (missionTypeFilter !== 'all' && row.unit.type !== missionTypeFilter) return false;
    if (searchValue) {
      const terms = [
        row.unit.name,
        row.unit.type,
        row.unit.class,
        row.unit.tag,
        row.station?.name,
        row.station?.department
      ].map(value => String(value || '').toLowerCase());
      if (!terms.some(term => term.includes(searchValue))) return false;
    }
    return true;
  });
  rows.sort((a, b) => {
    switch (missionSortFilter) {
      case 'name':
        return String(a.unit.name).localeCompare(String(b.unit.name));
      case 'priority':
        return (a.unit.priority || 0) - (b.unit.priority || 0) || a.distance - b.distance;
      default:
        return a.distance - b.distance || (a.unit.priority || 0) - (b.unit.priority || 0);
    }
  });

  if (!rows.length) {
    list.innerHTML = '<em>No units match the current filters.</em>';
    return;
  }

  list.innerHTML = `
    <table class="mission-units-table">
      <thead>
        <tr>
          <th>${missionUnitTab === 'available' ? '' : ''}</th>
          <th>Unit</th>
          <th>Type</th>
          <th>Station</th>
          <th>Distance</th>
          <th>${missionUnitTab === 'available' ? 'ETA' : 'Status'}</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(row => `
          <tr>
            <td>${missionUnitTab === 'available' ? `<input type="checkbox" value="${row.unit.id}">` : ''}</td>
            <td><span class="unit-link" data-unitid="${row.unit.id}">${row.unit.name}</span></td>
            <td>${row.unit.type || row.unit.class || ''}</td>
            <td>${row.station?.name || 'Unknown'}</td>
            <td>${formatDistance(row.distance)}</td>
            <td>${missionUnitTab === 'available'
              ? estimateEta(row.distance, row.unit)
              : formatStatus(row.unit.status || 'unknown', row.unit.responding)}</td>
            <td>${missionUnitTab === 'oncall'
              ? `<button class="queue-unit-btn" data-unitid="${row.unit.id}">Queue</button>`
              : ''}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
  list.querySelectorAll('.unit-link').forEach(span => {
    span.addEventListener('click', () => showUnitDetails(parseInt(span.dataset.unitid, 10)));
  });
  list.querySelectorAll('.queue-unit-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const unitId = parseInt(btn.dataset.unitid, 10);
      if (!Number.isFinite(unitId)) return;
      try {
        await sendUnitsToMission(mission, [unitId], null, true);
        await refreshAssignedUnitsUI(mission.id);
        await refreshMissionUnitRoster(mission);
        renderMissionUnitList(mission);
      } catch (err) {
        console.error(err);
        notifyError('Failed to queue unit.');
      }
    });
  });
}

async function dispatchSelectedFromList(mission, showNext = false) {
  const list = document.getElementById('missionUnitList');
  if (!list) return;
  const ids = Array.from(list.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.value, 10));
  if (!ids.length) { notifyError('Select at least one unit to dispatch.'); return; }
  try {
    await sendUnitsToMission(mission, ids, null, false);
    await refreshAssignedUnitsUI(mission.id);
    await refreshMissionUnitRoster(mission);
    renderMissionUnitList(mission);
    if (showNext) showNextMission();
  } catch (err) {
    console.error(err);
    notifyError('Failed to dispatch one or more units.');
  }
}

function openDispatchPanel() {
  const panel = document.querySelector('.mission-overlay__right');
  if (panel) panel.classList.remove('hidden');
}

function closeDispatchPanel() {
  const panel = document.querySelector('.mission-overlay__right');
  if (panel) panel.classList.add('hidden');
}

// ===== Mission details =====
async function showMissionDetails(mission) {
  openMissionId = mission.id;
  await updateMissionHeader(mission);
  missionDeptFilter = 'all';
  missionTypeFilter = 'all';
  missionSortFilter = 'distance';
  missionSearchFilter = '';

  const patientHtml = renderPatientInfo(mission);
  const prisonerHtml = renderPrisonerInfo(mission);
  const meta = document.getElementById('missionMeta');
  if (meta) {
    meta.innerHTML = `
      <div><strong>Status:</strong> ${mission.status}</div>
      ${patientHtml ? `<div class="mission-meta-section"><strong>Patients:</strong>${patientHtml}</div>` : ''}
      ${prisonerHtml ? `<div class="mission-meta-section"><strong>Prisoners:</strong>${prisonerHtml}</div>` : ''}
    `;
  }

  renderMissionDistanceFilter(mission);
  await refreshRunCardList(mission);
  await refreshMissionUnitRoster(mission);
  missionUnitTab = 'available';
  document.querySelectorAll('.mission-units-tab').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === 'available');
  });
  renderMissionUnitList(mission);

  document.getElementById('nextMissionBtnFooter').onclick = showNextMission;
  document.getElementById('prevMissionBtnFooter').onclick = showPrevMission;
  document.getElementById('autoDispatchBtn').onclick = () => autoDispatch(mission);
  document.getElementById('dispatchSelectedBtn').onclick = () => dispatchSelectedFromList(mission, false);
  document.getElementById('dispatchNextBtn').onclick = () => dispatchSelectedFromList(mission, true);
  const openDispatchBtn = document.getElementById('openDispatchPanelBtn');
  if (openDispatchBtn) {
    openDispatchBtn.onclick = () => openDispatchPanel();
  }
  const closeDispatchBtn = document.getElementById('closeDispatchPanelBtn');
  if (closeDispatchBtn) {
    closeDispatchBtn.onclick = () => closeDispatchPanel();
  }

  document.querySelectorAll('.mission-units-tab').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.mission-units-tab').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      missionUnitTab = btn.dataset.tab;
      renderMissionUnitList(mission);
    };
  });

  document.getElementById('missionDetails').classList.remove('hidden');
}

function closeMissionDetails() {
  document.getElementById('missionDetails').classList.add('hidden');
  openMissionId = null;
}

// ===== Station details =====
async function showStationDetails(station) {
  station = await fetchNoCache(`/api/stations/${station.id}`).then(r=>r.json());
  const detail = document.getElementById('stationDetails');
  window.currentStation = station;
  if (station.type === 'hospital' || station.type === 'jail') {
    const isHospital = station.type === 'hospital';
    const unitLabel = isHospital ? 'Beds' : 'Cells';
    const unitLabelLower = unitLabel.toLowerCase();
    const unitSingular = isHospital ? 'bed' : 'cell';
    const entityLabel = isHospital ? 'Patients' : 'Prisoners';
    detail.innerHTML = `
      <div style="text-align:right;">
        <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
      </div>
      <h2>${station.name}</h2>
          <button id="change-station-icon">Change Icon</button>
      <p>Type: ${station.type}</p>

      <p>Department: <span id="station-dept">${station.department || ''}</span> <button id="change-station-dept">Change Department</button></p>
      <div id="facility-summary">
        <div id="facility-capacity"></div>
        <div id="facility-processing"></div>
        <div id="facility-waiting"></div>
        <div id="facility-total"></div>
        <div id="facility-next"></div>
      </div>
      <div class="facility-purchase" style="margin-top:10px;">
        <label>Add ${unitLabelLower}:
          <input id="facility-add-count" type="number" min="1" value="1">
        </label>
        <button id="facility-add-btn">${isHospital ? 'Buy Beds' : 'Buy Cells'}</button>
      </div>
    `;
          const iconBtn = detail.querySelector('#change-station-icon');
      iconBtn?.addEventListener('click', async () => {
      const url = prompt('Enter icon URL:');
      if (!url) return;
      const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
      const data = await res.json();
      if (!res.ok || !data.success) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
      station.icon = url;
      _stationById.set(station.id, station);
      try {
        const marker = stationMarkerById.get(station.id);
        if (!marker) throw new Error('Marker not found');
        marker.setIcon(makeIcon(url, 30));
      } catch (err) {
        console.error(err);
        await fetchStations();
      }
      showStationDetails(station);
    });
    const deptBtn = detail.querySelector('#change-station-dept');
    deptBtn?.addEventListener('click', async () => {
      const dept = prompt('Enter department:');
      if (dept === null) return;
      const res = await fetch(`/api/stations/${station.id}/department`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ department: dept }) });
      const data = await res.json();
      if (!res.ok || !data.success) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
      station.department = dept;
      _stationById.set(station.id, station);
      fetchStations();
      showStationDetails(station);
    });
    function updateFacilitySummary(data) {
      const capacity = Math.max(0, Number(isHospital ? data.bed_capacity : data.holding_cells) || 0);
      const active = Math.min(capacity, Math.max(0, Number(isHospital ? data.occupied_beds : data.occupied_cells) || 0));
      const waiting = Math.max(0, Number(isHospital ? data.staged_patients : data.staged_prisoners) || 0);
      const totalCandidate = Number(isHospital ? data.total_patient_transports : data.total_prisoner_transports);
      const total = Math.max(0, Number.isFinite(totalCandidate) ? totalCandidate : active + waiting);
      const free = Math.max(0, capacity - active);
      const rawNext = Number(isHospital ? data.next_free_bed_at : data.next_free_cell_at);
      const nextAt = Number.isFinite(rawNext) && rawNext > 0 ? rawNext : 0;
      const capacityEl = detail.querySelector('#facility-capacity');
      if (capacityEl) capacityEl.textContent = `${unitLabel} Capacity: ${capacity}`;
      const processingEl = detail.querySelector('#facility-processing');
      if (processingEl) processingEl.textContent = `${entityLabel} in process: ${active}/${capacity} (Free: ${free})`;
      const waitingEl = detail.querySelector('#facility-waiting');
      if (waitingEl) waitingEl.textContent = `${entityLabel} waiting: ${waiting}`;
      const totalEl = detail.querySelector('#facility-total');
      if (totalEl) totalEl.textContent = `Total queued: ${total}`;
      const nextEl = detail.querySelector('#facility-next');
      if (nextEl) {
        if (waiting > 0 && nextAt > Date.now()) {
          const seconds = Math.ceil(Math.max(0, nextAt - Date.now()) / 1000);
          nextEl.textContent = `Next ${unitSingular} frees in: ${formatEta(seconds)}`;
        } else if (waiting > 0) {
          nextEl.textContent = `Next ${unitSingular} frees momentarily`;
        } else {
          nextEl.textContent = `Next ${unitSingular}: Available now`;
        }
      }
    }

    updateFacilitySummary(station);

    detail.querySelector('#facility-add-btn')?.addEventListener('click', async () => {
      const input = detail.querySelector('#facility-add-count');
      const add = Math.max(1, Number(input?.value || 0));
      const endpoint = isHospital ? 'beds' : 'holding-cells';
      const res = await fetch(`/api/stations/${station.id}/${endpoint}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ add })
      });
      const data = await res.json();
      if (!res.ok || !data.success) {
        notifyError(`Failed: ${data.error || res.statusText}`);
        return;
      }
      notifySuccess(`Added ${data.added} ${unitSingular}${data.added === 1 ? '' : 's'}. Cost: ${data.cost}`);
      if (input) input.value = '1';
      refreshWallet();
      station = await fetchNoCache(`/api/stations/${station.id}`).then(r=>r.json());
      window.currentStation = station;
      _stationById.set(station.id, station);
      updateFacilitySummary(station);
      fetchStations();
    });
    return;
  }
  const res = await fetchNoCache(`/api/units?station_id=${station.id}`);
  const units = (await res.json()).map(normalizeUnitRecord);
  units.forEach(u => _unitById.set(u.id, u));
  const unitClassOptions = stationUnitClasses(station.type);
  const allowMultipleUnitClasses = unitClassOptions.length > 1;
  const unitOptions = stationUnitTypes(
    station.type,
    allowMultipleUnitClasses ? unitClassOptions[0] : station.type
  ).map(u=>`<option value="${u.type}">${u.type}</option>`).join('');
  const usedBays = units.length;
  const freeBays = (station.bay_count || 0) - usedBays;
  const equipOptions = (equipment[station.type] || []).map(e=>{
    const name = typeof e === 'string' ? e : e.name;
    const cost = typeof e === 'object' && e.cost ? e.cost : 0;
    return `<option value="${name}" data-cost="${cost}">${name}${cost?` ($${cost})`:''}</option>`;
  }).join('');
  const stationEquip = Array.isArray(station.equipment) ? station.equipment : [];
  const holdingInfo = (station.type === 'police' && Number(station.holding_cells) > 0)
    ? (() => {
        const total = Math.max(0, Number(station.holding_cells || 0));
        const active = Math.min(total, Math.max(0, Number(station.occupied_cells || 0)));
        const waiting = Math.max(0, Number(station.staged_prisoners || 0));
        const freeCells = Math.max(0, total - active);
        return `<div id="holding-info">Holding Cells: ${active}/${total} (Waiting: ${waiting}, Free: ${freeCells})</div>`;
      })()
    : '';
  detail.innerHTML = `
    <div style="text-align:right;">
      <button onclick="document.getElementById('stationDetails').innerHTML = ''" style="background: darkred; color: white;">Close</button>
    </div>
    <h2>${station.name}</h2>
        <button id="change-station-icon">Change Icon</button>
    <p>Type: ${formatStationTypeLabel(station.type)}</p>
    <p>Department: <span id="station-dept">${station.department || ''}</span> <button id="change-station-dept">Change Department</button> <button id="manage-station-ranks">Manage Ranks</button></p>
    <div id="station-upgrade-section"></div>
    <h3>Create Unit</h3>
    ${
      allowMultipleUnitClasses
        ? `<select id="unit-class">${unitClassOptions.map(c=>`<option value="${c}">${formatStationTypeLabel(c)}</option>`).join('')}</select>`
        : ''
    }
    <select id="unit-type">${unitOptions}</select>
    <input id="unit-name" placeholder="Unit name (e.g., Ladder 1)" />
    <input id="unit-tag" placeholder="Tag" />
    <input id="unit-priority" type="number" min="1" max="5" value="1" style="width:60px;" />
    <input id="unit-seats" type="number" min="1" style="width:80px;" placeholder="Seats" />
    <button id="create-unit">Create Unit</button>
    <h3>Add Personnel</h3>
    <input id="personnel-name" placeholder="Name (e.g., John Doe)" />
    <select id="personnel-rank"></select>
    <div id="personnel-training">
      ${
        (getTrainingsForClass(station.type).length
          ? getTrainingsForClass(station.type)
          : [{ name: 'general', cost: 0 }]
        ).map((t,idx)=>{
          const name = typeof t === 'string' ? t : t.name;
          const cost = typeof t === 'object' && t.cost ? t.cost : 0;
          return `<label><input type="checkbox" value="${name}" data-cost="${cost}" ${idx===0?"checked":""}/> ${name}${cost?` ($${cost})`:''}</label><br>`;
        }).join('')
      }
    </div>
    <div id="personnel-cost"></div>
    <div id="bay-info">Bays: ${usedBays}/${station.bay_count || 0} (Free: ${freeBays})</div>
    ${holdingInfo}
    <div>
      <label>Add bays:
        <input id="add-bays-count" type="number" min="1" value="1">
      </label>
      <button id="add-bays-btn">Add Bays</button>
    </div>
    <h3>Station Equipment</h3>
    <div id="station-equipment-display">
      ${stationEquip.length ? `<ul>${stationEquip.map(e=>`<li>${e}</li>`).join('')}</ul>` : '<em>No equipment</em>'}
    </div>
    <div>
      <select id="equipment-buy">${equipOptions}</select>
      <button id="buy-equipment-btn">Buy</button>
    </div>
    <button id="create-personnel">Add Personnel</button>
    <h3>Personnel</h3>
    <ul id="personnel-list"></ul>
    <h3>Assigned Units</h3>
    <ul id="unit-list">
      ${units.map(u=>`
        <li>
          <strong style="cursor:pointer; color:blue;" onclick="showUnitDetails(${u.id})">${u.name}</strong> (${u.type}) [P${u.priority}] - ${formatStatus(u.status, u.responding)}
          <button onclick="openAssignModal(${u.id}, ${station.id})">Assign</button>
          ${u.status !== 'available' ? `<button onclick="cancelUnit(${u.id}, ${station.id})">Cancel</button>` : ''}
          <button class="edit-unit-btn" data-unitid="${u.id}">Edit</button>
        </li>`).join('')}
    </ul>`;
  // Prepopulate personnel input with a random name
  try {
    const rnd = await fetch('/api/random-name').then(r => r.json());
    const input = document.getElementById('personnel-name');
    if (input && rnd.first && rnd.last) {
      input.value = `${rnd.first} ${rnd.last}`;
    }
  } catch {}
  const rankSelectEl = document.getElementById('personnel-rank');
  const unitClassSelect = document.getElementById('unit-class');
  const unitTypeSelect = document.getElementById('unit-type');
  const unitSeatInput = document.getElementById('unit-seats');

  function refreshUnitTypeOptions(classValue) {
    if (!unitTypeSelect) return;
    const types = stationUnitTypes(station.type, classValue || station.type);
    unitTypeSelect.innerHTML = types.map(u => `<option value="${u.type}">${u.type}</option>`).join('');
  }

  function updateSeatFieldForUnit(forceDefault = false) {
    if (!unitSeatInput || !unitTypeSelect) return;
    const selectedClass = unitClassSelect ? unitClassSelect.value : station.type;
    const def = findUnitDefinitionByType(selectedClass, unitTypeSelect.value);
    const defaultSeats = Number(def?.capacity || 0) || 0;
    if (!defaultSeats) {
      unitSeatInput.value = '';
      unitSeatInput.placeholder = 'N/A';
      unitSeatInput.disabled = true;
      unitSeatInput.title = 'This unit type cannot carry personnel.';
      return;
    }
    unitSeatInput.disabled = false;
    unitSeatInput.min = '1';
    unitSeatInput.max = String(defaultSeats);
    unitSeatInput.placeholder = String(defaultSeats);
    unitSeatInput.title = `Enter between 1 and ${defaultSeats}. Leave blank to use default (${defaultSeats}).`;
    const raw = unitSeatInput.value.trim();
    if (!raw) {
      if (forceDefault) {
        unitSeatInput.value = String(defaultSeats);
      } else {
        unitSeatInput.value = '';
      }
      return;
    }
    let value = Math.floor(Number(raw));
    if (!Number.isFinite(value)) {
      unitSeatInput.value = String(defaultSeats);
      return;
    }
    value = Math.max(1, Math.min(defaultSeats, value));
    unitSeatInput.value = String(value);
  }

  if (unitClassSelect) {
    refreshUnitTypeOptions(unitClassSelect.value);
    unitClassSelect.addEventListener('change', () => {
      refreshUnitTypeOptions(unitClassSelect.value);
      updateSeatFieldForUnit(true);
    });
  }
  if (unitTypeSelect && unitSeatInput) {
    updateSeatFieldForUnit(true);
    unitTypeSelect.addEventListener('change', () => updateSeatFieldForUnit(true));
    unitSeatInput.addEventListener('blur', () => updateSeatFieldForUnit(false));
  }

  function populateRankSelect(selectEl, ranks, currentValue = '') {
    if (!selectEl) return;
    const safeRanks = Array.isArray(ranks) ? ranks : [];
    const seen = new Set();
    const options = ['<option value=""></option>'];
    safeRanks.forEach(raw => {
      const value = cleanRankValue(raw);
      if (!value) return;
      const key = value.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      options.push(`<option value="${value.replace(/"/g, '&quot;')}">${value}</option>`);
    });
    const current = cleanRankValue(currentValue);
    if (current && !seen.has(current.toLowerCase())) {
      options.push(`<option value="${current.replace(/"/g, '&quot;')}">${current}</option>`);
    }
    selectEl.innerHTML = options.join('');
    selectEl.value = current || '';
  }

  populateRankSelect(rankSelectEl, [], '');

  async function refreshRankOptionsForStation() {
    if (!rankSelectEl) return;
    const dept = cleanRankValue(station.department);
    const ranks = await fetchDepartmentRanks(dept);
    populateRankSelect(rankSelectEl, ranks, rankSelectEl.value);
  }

  refreshRankOptionsForStation();
          const iconBtn = detail.querySelector('#change-station-icon');
          iconBtn?.addEventListener('click', async () => {
                const url = prompt('Enter icon URL:');
                if (!url) return;
                const res = await fetch(`/api/stations/${station.id}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ icon: url }) });
                const data = await res.json();
                if (!res.ok || !data.success) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
                station.icon = url;
                _stationById.set(station.id, station);
                try {
                  const marker = stationMarkerById.get(station.id);
                  if (!marker) throw new Error('Marker not found');
                  marker.setIcon(makeIcon(url, 30));
                } catch (err) {
                  console.error(err);
                  await fetchStations();
                }
                showStationDetails(station);
          });
          const deptBtn = detail.querySelector('#change-station-dept');
          deptBtn?.addEventListener('click', async () => {
                const dept = prompt('Enter department:');
                if (dept === null) return;
                const res = await fetch(`/api/stations/${station.id}/department`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ department: dept }) });
                const data = await res.json();
                if (!res.ok || !data.success) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
                station.department = dept;
                _stationById.set(station.id, station);
                fetchStations();
                showStationDetails(station);
          });
          const manageRanksBtn = detail.querySelector('#manage-station-ranks');
          manageRanksBtn?.addEventListener('click', async () => {
                const result = await promptManageDepartmentRanks(station.department);
                if (!result) return;
                const configured = cleanRankValue(result.department);
                if (!configured) return;
                cacheDepartmentRanks(configured, result.ranks || []);
                const currentDept = cleanRankValue(station.department);
                if (currentDept && configured.toLowerCase() === currentDept.toLowerCase()) {
                  await refreshRankOptionsForStation();
                }
          });
        async function loadStationUpgrades() {
          const upgradeSection = detail.querySelector('#station-upgrade-section');
          if (!upgradeSection) return;
          try {
            const res = await fetch(`/api/stations/${station.id}/upgrades`, { cache: 'no-store' });
            const data = await res.json();
            const options = Array.isArray(data?.options) ? data.options : [];
            if (!res.ok || !options.length) {
              upgradeSection.innerHTML = '';
              return;
            }
            upgradeSection.innerHTML = `
              <h3>Station Upgrades</h3>
              <label>
                Upgrade to:
                <select id="station-upgrade-select">
                  ${options.map((opt) => `
                    <option value="${opt.to}" data-cost="${opt.cost}">
                      ${opt.label || formatStationTypeLabel(opt.to)}
                    </option>
                  `).join('')}
                </select>
              </label>
              <button id="station-upgrade-btn">Upgrade</button>
              <div id="station-upgrade-cost"></div>
            `;
            const select = upgradeSection.querySelector('#station-upgrade-select');
            const costEl = upgradeSection.querySelector('#station-upgrade-cost');
            const updateCost = () => {
              const selected = options.find((opt) => opt.to === select.value);
              if (costEl) {
                costEl.textContent = selected ? `Cost: $${selected.cost}` : '';
              }
            };
            updateCost();
            select?.addEventListener('change', updateCost);
            upgradeSection.querySelector('#station-upgrade-btn')?.addEventListener('click', async () => {
              const targetType = select?.value;
              if (!targetType) return;
              const resUpgrade = await fetch(`/api/stations/${station.id}/upgrade`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: targetType })
              });
              const upgradeData = await resUpgrade.json();
              if (!resUpgrade.ok || !upgradeData.success) {
                notifyError(`Failed: ${upgradeData.error || resUpgrade.statusText}`);
                return;
              }
              notifySuccess(`Station upgraded to ${formatStationTypeLabel(upgradeData.type)}. Cost: ${upgradeData.cost}`);
              refreshWallet();
              await fetchStations();
              await refreshStationPanelNoCache(station.id);
            });
          } catch (err) {
            console.error(err);
          }
        }
        loadStationUpgrades();
        async function refreshBayInfo(stationId) {
          const [s, us] = await Promise.all([
            fetch(`/api/stations/${stationId}`, { cache: 'no-store' }).then(r=>r.json()),
            fetch(`/api/units?station_id=${stationId}`, { cache: 'no-store' }).then(r=>r.json())
          ]);
          const used = Array.isArray(us) ? us.length : 0;
          const el = document.getElementById('bay-info');
          el.textContent = `Bays: ${used}/${s.bay_count} (Free: ${s.bay_count - used})`;
          if (s.type === 'police' && Number(s.holding_cells) > 0) {
            const hc = document.getElementById('holding-info');
            if (hc) {
              const total = Math.max(0, Number(s.holding_cells || 0));
              const active = Math.min(total, Math.max(0, Number(s.occupied_cells || 0)));
              const waiting = Math.max(0, Number(s.staged_prisoners || 0));
              const freeCells = Math.max(0, total - active);
              hc.textContent = `Holding Cells: ${active}/${total} (Waiting: ${waiting}, Free: ${freeCells})`;
            }
          }
        }

        const BASE_PERSON_COST = 100;
        function updatePersonnelCost() {
          const selected = Array.from(detail.querySelectorAll('#personnel-training input[type=checkbox]:checked'));
          const cost = selected.reduce((sum, cb) => sum + Number(cb.dataset.cost || 0), BASE_PERSON_COST);
          const el = detail.querySelector('#personnel-cost');
          if (el) el.textContent = `Cost: $${cost}`;
          return cost;
        }
        detail.querySelectorAll('#personnel-training input[type=checkbox]').forEach(cb => cb.addEventListener('change', updatePersonnelCost));
        updatePersonnelCost();

        document.getElementById('add-bays-btn')?.addEventListener('click', async () => {
          const n = Number(document.getElementById('add-bays-count').value || 1);
          const stationId = station.id;
          const res = await fetch(`/api/stations/${stationId}/bays`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ add: n })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
                notifyError(`Failed: ${data.error || res.statusText}`);
                return;
          }
          notifySuccess(`Added ${data.added} bay(s). Cost: ${data.cost}`);
          refreshBayInfo(stationId);
          refreshWallet();
        });
        document.getElementById('buy-equipment-btn')?.addEventListener('click', async () => {
          const sel = document.getElementById('equipment-buy');
          const name = sel.value;
          const res = await fetch(`/api/stations/${station.id}/equipment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name })
          });
          const data = await res.json();
          if (!res.ok || !data.success) {
            notifyError(`Failed: ${data.error || res.statusText}`);
            return;
          }
          notifySuccess(`Purchased ${name} for ${data.cost}`);
          refreshWallet();
          refreshStationPanelNoCache(station.id);
        });
  // Replace inline openAssignModal with safe listeners
        detail.querySelectorAll('button').forEach(btn => {
          const m = btn.getAttribute('onclick');
          if (m && m.startsWith('openAssignModal(')) {
                btn.removeAttribute('onclick');
                const args = m.match(/openAssignModal\((\d+),\s*(\d+)\)/);
                if (args) {
                  const [_, unitId, stationId] = args.map(Number);
                  btn.addEventListener('click', () => openAssignModal(unitId, stationId));
                }
          }
        });

        // Hook up unit edit buttons
        detail.querySelectorAll('.edit-unit-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = parseInt(btn.dataset.unitid, 10);
            const u = _unitById.get(id);
            if (u) openUnitModal(u);
          });
        });

        // Replace inline editPersonnel with safe listener
        detail.querySelectorAll('#personnel-list button').forEach(btn => {
          const m = btn.getAttribute('onclick');
          if (m && m.startsWith('editPersonnel(')) {
                btn.removeAttribute('onclick');
                const id = parseInt(m.match(/editPersonnel\((\d+)\)/)[1], 10);
                btn.addEventListener('click', () => window.editPersonnel(id));
          }
        });
  document.getElementById('create-unit').addEventListener('click', async ()=>{
    const type = document.getElementById('unit-type').value;
    const unitClass = document.getElementById('unit-class')?.value || station.type;
    const name = document.getElementById('unit-name').value;
    const tag = document.getElementById('unit-tag').value;
    const priority = Number(document.getElementById('unit-priority').value) || 1;
    const seatField = document.getElementById('unit-seats');
    const seatRaw = seatField ? seatField.value.trim() : '';
    const defaultSeats = defaultSeatCapacity(unitClass, type);
    let seats = null;
    if (seatRaw) {
      let value = Math.floor(Number(seatRaw));
      if (Number.isFinite(value)) {
        if (defaultSeats > 0) {
          value = Math.max(1, Math.min(defaultSeats, value));
          if (value !== defaultSeats) seats = value;
        } else {
          seats = Math.max(0, value);
        }
      }
    }
    if (!type || !name) return notifyError("Missing name or type");
    await fetch('/api/units',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({station_id:station.id,class:unitClass,type,name,tag,priority,seats})});
    showStationDetails(station);
  });
  document.getElementById('create-personnel').addEventListener('click', async ()=>{
    const name = document.getElementById('personnel-name').value;
    const rankValue = cleanRankValue(document.getElementById('personnel-rank')?.value);
    const training = Array.from(document.querySelectorAll('#personnel-training input[type=checkbox]:checked')).map(cb=>cb.value);
    if (!name) return notifyError("Missing name");
    const res = await fetch('/api/personnel',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({ name, rank: rankValue || null, station_id: station.id, training })});
    const data = await res.json();
    if (!res.ok) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
    notifySuccess(`Personnel added. Cost: ${data.charged}`);
    refreshWallet();
    showStationDetails(station);
  });

  // Load personnel (no-cache so edits show immediately)
  const personnel = await fetchNoCache(`/api/personnel?station_id=${station.id}`).then(r=>r.json());
  const personnelList = document.getElementById("personnel-list");
  personnelList.innerHTML = '';
  personnel.forEach(p=>{
    const li = document.createElement("li");
    const trainings = (p.training || []).map(t => typeof t === 'string' ? t : t.name).join(', ');
    const trainingText = trainings || 'No training';
    const rankLabel = cleanRankValue(p.rank);
    const name = p.name || '';
    const displayName = rankLabel ? `${rankLabel} ${name}`.trim() : name;
    li.innerHTML = `<strong>${displayName}</strong> (${trainingText}) <button onclick="editPersonnel(${p.id})" style="margin-left:10px;">Edit</button>`;
    personnelList.appendChild(li);
  });

  refreshBayInfo(station.id);
}

function openStationBuilderModal(initial = {}) {
  const allowedTypes = ['fire', 'police', 'ambulance', 'sar', 'hospital', 'jail', 'fire_rescue'];
  return new Promise((resolve) => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.style.zIndex = '20000';

    const modal = document.createElement('div');
    modal.className = 'modal-content station-builder-modal';

    const title = document.createElement('h2');
    title.textContent = 'Create Station';
    modal.appendChild(title);

    const errorBox = document.createElement('div');
    errorBox.className = 'station-builder-error';
    errorBox.style.display = 'none';
    modal.appendChild(errorBox);

    const state = {
      name: typeof initial.name === 'string' ? initial.name : '',
      department: typeof initial.department === 'string' ? initial.department : '',
      type: allowedTypes.includes(String(initial.type || '').toLowerCase())
        ? String(initial.type).toLowerCase()
        : 'fire',
      bays: Math.max(1, Number(initial.bays ?? 1) || 1),
      equipment_slots: Math.max(0, Number(initial.equipment_slots ?? 0) || 0),
      holding_cells: Math.max(0, Number(initial.holding_cells ?? 0) || 0),
      bed_capacity: Math.max(0, Number(initial.bed_capacity ?? 0) || 0),
      storageEquipment: Array.isArray(initial.equipment) ? initial.equipment.slice() : [],
      units: Array.isArray(initial.units) ? initial.units.slice() : [],
    };
    state.units = state.units.map(u => {
      const classOptions = stationUnitClasses(state.type);
      const unitClass = classOptions.includes(String(u?.class || '').toLowerCase())
        ? String(u.class).toLowerCase()
        : classOptions[0];
      const unitPersonnel = Array.isArray(u?.personnel) ? u.personnel : [];
      return {
        name: typeof u?.name === 'string' ? u.name : '',
        type: typeof u?.type === 'string' ? u.type : '',
        class: unitClass,
        tag: typeof u?.tag === 'string' ? u.tag : '',
        priority: Math.min(5, Math.max(1, Number(u?.priority ?? 1) || 1)),
        equipment: Array.isArray(u?.equipment) ? u.equipment.slice() : [],
        patrol: Boolean(u?.patrol),
        personnel: unitPersonnel.map((person) => ({
          name: typeof person?.name === 'string' ? person.name : '',
          rank: cleanRankValue(person?.rank) || '',
          training: Array.isArray(person?.training) ? person.training.slice() : [],
        })),
        personnelAddCount: Math.max(1, Number(u?.personnel_add_count ?? 1) || 1),
        seats: (() => {
          const def = (unitTypes || []).find((d) => String(d.class || '').toLowerCase() === unitClass && d.type === u?.type);
          const defaultCap = Number(def?.capacity || 0) || 0;
          const raw = u?.seat_override ?? u?.seats ?? u?.seat_capacity;
          if (!Number.isFinite(Number(raw))) return null;
          let value = Math.floor(Number(raw));
          if (defaultCap > 0) {
            value = Math.max(1, Math.min(defaultCap, value));
            return value === defaultCap ? null : value;
          }
          return Math.max(0, value);
        })(),
      };
    });

    const BUILD_COST = 50000;
    const BAY_COST = 5000;
    const EQUIP_SLOT_COST = 1000;
    const HOLDING_COST = 2500;
    const BASE_PERSON_COST = 100;

    let currentRankOptions = [];
    let rankOptionsVersion = 0;

    async function refreshCurrentRankOptions() {
      const version = ++rankOptionsVersion;
      const dept = cleanRankValue(state.department);
      const ranks = await fetchDepartmentRanks(dept);
      if (version !== rankOptionsVersion) return;
      currentRankOptions = ranks;
      renderUnits();
    }

    const basicSection = document.createElement('div');
    basicSection.className = 'station-builder-section';
    const basicTitle = document.createElement('h3');
    basicTitle.textContent = 'Station Details';
    basicSection.appendChild(basicTitle);
    const basicGrid = document.createElement('div');
    basicGrid.className = 'station-builder-grid';
    basicSection.appendChild(basicGrid);

    const equipmentSection = document.createElement('div');
    equipmentSection.className = 'station-builder-section';
    const equipmentTitle = document.createElement('h3');
    equipmentTitle.textContent = 'Station Equipment';
    equipmentSection.appendChild(equipmentTitle);
    const equipmentContainer = document.createElement('div');
    equipmentContainer.className = 'station-builder-checkboxes';
    equipmentSection.appendChild(equipmentContainer);

    const unitsSection = document.createElement('div');
    unitsSection.className = 'station-builder-section';
    const unitsHeader = document.createElement('div');
    unitsHeader.className = 'station-builder-row';
    const unitsTitle = document.createElement('h3');
    unitsTitle.textContent = 'Units';
    const addUnitBtn = document.createElement('button');
    addUnitBtn.textContent = 'Add Unit';
    const addUnitCountInput = document.createElement('input');
    addUnitCountInput.type = 'number';
    addUnitCountInput.min = '1';
    addUnitCountInput.value = '1';
    addUnitCountInput.className = 'station-builder-input';
    addUnitCountInput.style.width = '70px';
    const addUnitBatchBtn = document.createElement('button');
    addUnitBatchBtn.textContent = 'Add Units';
    unitsHeader.append(unitsTitle, addUnitBtn, addUnitCountInput, addUnitBatchBtn);
    unitsSection.appendChild(unitsHeader);
    const unitsContainer = document.createElement('div');
    unitsContainer.className = 'station-builder-list';
    unitsSection.appendChild(unitsContainer);

    const summarySection = document.createElement('div');
    summarySection.className = 'station-builder-section station-builder-summary';
    const summaryTitle = document.createElement('h3');
    summaryTitle.textContent = 'Cost Summary';
    const summaryContent = document.createElement('div');
    summaryContent.className = 'station-builder-cost';
    summarySection.append(summaryTitle, summaryContent);

    modal.appendChild(basicSection);
    modal.appendChild(equipmentSection);
    modal.appendChild(unitsSection);
    modal.appendChild(summarySection);

    const actions = document.createElement('div');
    actions.className = 'station-builder-actions';
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    const createBtn = document.createElement('button');
    createBtn.textContent = 'Create Station';
    createBtn.style.background = '#0b5';
    createBtn.style.color = '#fff';
    actions.append(cancelBtn, createBtn);
    modal.appendChild(actions);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    const nameInput = document.createElement('input');
    nameInput.className = 'station-builder-input';
    nameInput.placeholder = 'Station Name';
    nameInput.value = state.name;
    nameInput.addEventListener('input', () => { state.name = nameInput.value; hideError(); });

    const deptInput = document.createElement('input');
    deptInput.className = 'station-builder-input';
    deptInput.placeholder = 'Department';
    deptInput.value = state.department;
    deptInput.addEventListener('input', () => {
      state.department = deptInput.value;
      hideError();
      refreshCurrentRankOptions();
    });
    const deptRankBtn = document.createElement('button');
    deptRankBtn.type = 'button';
    deptRankBtn.textContent = 'Manage Ranks';
    deptRankBtn.style.whiteSpace = 'nowrap';
    deptRankBtn.addEventListener('click', async () => {
      const result = await promptManageDepartmentRanks(state.department);
      if (!result) return;
      const configured = cleanRankValue(result.department);
      if (!configured) return;
      cacheDepartmentRanks(configured, result.ranks || []);
      const currentDept = cleanRankValue(state.department);
      if (!currentDept) {
        state.department = configured;
        deptInput.value = configured;
      }
      if (currentDept && configured.toLowerCase() !== currentDept.toLowerCase()) return;
      refreshCurrentRankOptions();
    });
    const deptWrapper = document.createElement('div');
    deptWrapper.style.display = 'flex';
    deptWrapper.style.gap = '0.5em';
    deptWrapper.append(deptInput, deptRankBtn);

    const typeSelect = document.createElement('select');
    typeSelect.className = 'station-builder-select';
    allowedTypes.forEach((t) => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = formatStationTypeLabel(t);
      typeSelect.appendChild(opt);
    });
    typeSelect.value = state.type;

    const baysInput = document.createElement('input');
    baysInput.type = 'number';
    baysInput.min = '0';
    baysInput.value = state.bays;
    baysInput.className = 'station-builder-input';
    baysInput.addEventListener('input', () => {
      state.bays = Math.max(Number(baysInput.value) || 0, 0);
      hideError();
      updateCostSummary();
    });

    const slotsInput = document.createElement('input');
    slotsInput.type = 'number';
    slotsInput.min = '0';
    slotsInput.value = state.equipment_slots;
    slotsInput.className = 'station-builder-input';
    slotsInput.addEventListener('input', () => {
      state.equipment_slots = Math.max(Number(slotsInput.value) || 0, 0);
      hideError();
      updateCostSummary();
    });

    const holdingInput = document.createElement('input');
    holdingInput.type = 'number';
    holdingInput.min = '0';
    holdingInput.value = state.holding_cells;
    holdingInput.className = 'station-builder-input';
    holdingInput.addEventListener('input', () => {
      state.holding_cells = Math.max(Number(holdingInput.value) || 0, 0);
      hideError();
      updateCostSummary();
    });

    const bedsInput = document.createElement('input');
    bedsInput.type = 'number';
    bedsInput.min = '0';
    bedsInput.value = state.bed_capacity;
    bedsInput.className = 'station-builder-input';
    bedsInput.addEventListener('input', () => {
      state.bed_capacity = Math.max(Number(bedsInput.value) || 0, 0);
      hideError();
      updateCostSummary();
    });

    function makeInputGroup(labelText, input) {
      const wrapper = document.createElement('label');
      wrapper.className = 'station-builder-field';
      const span = document.createElement('span');
      span.textContent = labelText;
      wrapper.append(span, input);
      return wrapper;
    }

    basicGrid.append(
      makeInputGroup('Station Name', nameInput),
      makeInputGroup('Department', deptWrapper),
      makeInputGroup('Station Class', typeSelect),
      makeInputGroup('Bays', baysInput),
      makeInputGroup('Equipment Slots', slotsInput)
    );

    const holdingGroup = makeInputGroup('Holding Cells', holdingInput);
    const bedsGroup = makeInputGroup('Beds', bedsInput);
    basicGrid.append(holdingGroup, bedsGroup);

    function hideError() {
      errorBox.textContent = '';
      errorBox.style.display = 'none';
    }
    function showError(msg) {
      errorBox.textContent = msg;
      errorBox.style.display = msg ? 'block' : 'none';
    }

    function equipmentOptions() {
      const list = (equipment && equipment[state.type]) || [];
      return list.map((item) => {
        if (typeof item === 'string') return { name: item, cost: 0 };
        return { name: item?.name || '', cost: Number(item?.cost) || 0 };
      }).filter(opt => opt.name);
    }

    function trainingOptions() {
      const list = typeof getTrainingsForClass === 'function' ? getTrainingsForClass(state.type) || [] : [];
      return list.map((item) => {
        if (typeof item === 'string') return { name: item, cost: 0 };
        return { name: item?.name || '', cost: Number(item?.cost) || 0 };
      }).filter(opt => opt.name);
    }

    function expandTrainingListForState(list) {
      if (typeof trainingHelpers !== 'undefined' && trainingHelpers && typeof trainingHelpers.expandTrainingList === 'function') {
        return trainingHelpers.expandTrainingList(list, state.type) || [];
      }
      const seen = new Set();
      const result = [];
      (Array.isArray(list) ? list : []).forEach((value) => {
        const trimmed = String(value || '').trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        result.push(trimmed);
      });
      return result;
    }

    function collapseTrainingListForState(list) {
      if (typeof trainingHelpers !== 'undefined' && trainingHelpers && typeof trainingHelpers.collapseTrainingList === 'function') {
        return trainingHelpers.collapseTrainingList(list, state.type) || [];
      }
      const seen = new Set();
      const result = [];
      (Array.isArray(list) ? list : []).forEach((value) => {
        const trimmed = String(value || '').trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        result.push(trimmed);
      });
      return result;
    }

    function getDefaultTrainingsForState(options) {
      const opts = Array.isArray(options) ? options : [];
      const validNames = new Set(opts.map((opt) => String(opt?.name || '').toLowerCase()).filter(Boolean));
      if (typeof trainingHelpers !== 'undefined' && trainingHelpers && typeof trainingHelpers.getTrainingDefaults === 'function') {
        const defaults = trainingHelpers.getTrainingDefaults(state.type) || [];
        return defaults.filter((name) => validNames.has(String(name || '').toLowerCase()));
      }
      const key = String(state.type || '').toLowerCase();
      const defaults = (typeof trainingDefaults !== 'undefined' && trainingDefaults && trainingDefaults[key]) || [];
      const arr = Array.isArray(defaults) ? defaults : [defaults];
      return arr
        .map((name) => String(name || '').trim())
        .filter((name) => name && validNames.has(name.toLowerCase()));
    }

    function allowedUnitTypes(unitClass = null) {
      const classes = unitClass ? [unitClass] : stationUnitClasses(state.type);
      return (unitTypes || []).filter((u) => classes.includes(String(u.class || '').toLowerCase()));
    }

    function findEquipmentCost(name) {
      const key = String(name || '').toLowerCase();
      const lists = Object.values(equipment || {});
      for (const arr of lists) {
        for (const item of arr || []) {
          if (typeof item === 'string' && item.toLowerCase() === key) return 0;
          if (item?.name && String(item.name).toLowerCase() === key) return Number(item.cost) || 0;
        }
      }
      return 0;
    }

    function findTrainingCost(name) {
      const key = String(name || '').trim().toLowerCase();
      const lists = Object.values(trainingsByClass || {});
      for (const arr of lists) {
        for (const item of arr || []) {
          if (typeof item === 'string' && item.trim().toLowerCase() === key) return 0;
          if (item?.name && String(item.name).trim().toLowerCase() === key) return Number(item.cost) || 0;
        }
      }
      return 0;
    }

    function sanitizeByType() {
      hideError();
      holdingGroup.style.display = ['police', 'jail'].includes(state.type) ? 'flex' : 'none';
      bedsGroup.style.display = state.type === 'hospital' ? 'flex' : 'none';
      const eqNames = new Set(equipmentOptions().map((e) => e.name));
      state.storageEquipment = state.storageEquipment.filter((name) => eqNames.has(name));

      const classOptions = stationUnitClasses(state.type);
      const baseDefs = allowedUnitTypes();
      if (!baseDefs.length) {
        state.units = [];
      } else {
        state.units.forEach((unit) => {
          if (!classOptions.includes(unit.class)) {
            unit.class = classOptions[0] || state.type;
          }
          const unitDefs = allowedUnitTypes(unit.class);
          if (!unitDefs.find((def) => def.type === unit.type)) {
            unit.type = unitDefs[0]?.type || '';
          }
          const def = unitDefs.find((d) => d.type === unit.type);
          const slots = Number(def?.equipmentSlots || 0);
          unit.equipment = unit.equipment.filter((name) => eqNames.has(name));
          if (slots && unit.equipment.length > slots) {
            unit.equipment = unit.equipment.slice(0, slots);
          }
          if (!slots) unit.equipment = [];
        });
      }

      const availableTrainings = trainingOptions();
      const trainingNames = new Set(availableTrainings.map((t) => t.name));
      state.units.forEach((unit) => {
        unit.personnel.forEach((person) => {
          const filtered = (Array.isArray(person.training) ? person.training : []).filter((name) => trainingNames.has(name));
          person.training = expandTrainingListForState(filtered);
        });
      });

      if (!['police', 'jail'].includes(state.type)) {
        state.holding_cells = 0;
        holdingInput.value = '0';
      }
      if (state.type !== 'hospital') {
        state.bed_capacity = 0;
        bedsInput.value = '0';
      }
    }

    function renderStationEquipment() {
      equipmentContainer.innerHTML = '';
      const options = equipmentOptions();
      state.storageEquipment = state.storageEquipment.filter((name) => options.some((opt) => opt.name === name));
      if (!options.length) {
        const empty = document.createElement('div');
        empty.className = 'station-builder-empty';
        empty.textContent = 'No purchasable equipment for this class.';
        equipmentContainer.appendChild(empty);
        return;
      }
      options.forEach((opt) => {
        const id = `station-equip-${opt.name.replace(/\s+/g, '-')}`;
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = id;
        checkbox.checked = state.storageEquipment.includes(opt.name);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            if (!state.storageEquipment.includes(opt.name)) state.storageEquipment.push(opt.name);
          } else {
            state.storageEquipment = state.storageEquipment.filter((n) => n !== opt.name);
          }
          hideError();
          updateCostSummary();
        });
        const span = document.createElement('span');
        span.textContent = opt.cost ? `${opt.name} ($${opt.cost})` : opt.name;
        label.append(checkbox, span);
        equipmentContainer.appendChild(label);
      });
    }

    function preserveFocusAndScroll(container, renderFn) {
      const active = document.activeElement;
      const focusKey = active?.dataset?.focusKey;
      const selectionStart = active?.selectionStart;
      const selectionEnd = active?.selectionEnd;
      const scrollTop = container.scrollTop;
      renderFn();
      container.scrollTop = scrollTop;
      if (focusKey) {
        const next = container.querySelector(`[data-focus-key="${focusKey}"]`);
        if (next) {
          next.focus();
          if (typeof selectionStart === 'number' && typeof next.setSelectionRange === 'function') {
            next.setSelectionRange(selectionStart, selectionEnd ?? selectionStart);
          }
        }
      }
    }

    function renderUnits() {
      preserveFocusAndScroll(unitsContainer, () => {
        unitsContainer.innerHTML = '';
        if (!state.units.length) {
          const empty = document.createElement('div');
          empty.className = 'station-builder-empty';
          empty.textContent = 'No units selected.';
          unitsContainer.appendChild(empty);
          baysInput.min = '0';
          return;
        }
        const classOptions = stationUnitClasses(state.type);
        const showClass = classOptions.length > 1;
        baysInput.min = String(state.units.length);
        state.units.forEach((unit, idx) => {
          const unitDefs = allowedUnitTypes(unit.class);
          const wrapper = document.createElement('div');
          wrapper.className = 'station-builder-unit';
          const header = document.createElement('div');
          header.className = 'station-builder-header';
          header.textContent = `Unit ${idx + 1}`;
          const removeBtn = document.createElement('button');
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', () => {
            state.units.splice(idx, 1);
            renderUnits();
            updateCostSummary();
          });
          header.appendChild(removeBtn);
          wrapper.appendChild(header);

          const nameField = makeInputGroup('Name', (() => {
            const input = document.createElement('input');
            input.className = 'station-builder-input';
            input.value = unit.name;
            input.dataset.focusKey = `unit-${idx}-name`;
            input.addEventListener('input', () => { unit.name = input.value; hideError(); });
            return input;
          })());

          const classField = showClass
            ? makeInputGroup('Class', (() => {
                const select = document.createElement('select');
                select.className = 'station-builder-select';
                select.dataset.focusKey = `unit-${idx}-class`;
                classOptions.forEach((cls) => {
                  const opt = document.createElement('option');
                  opt.value = cls;
                  opt.textContent = formatStationTypeLabel(cls);
                  select.appendChild(opt);
                });
                if (!classOptions.includes(unit.class)) {
                  unit.class = classOptions[0] || state.type;
                }
                select.value = unit.class;
                select.addEventListener('change', () => {
                  unit.class = select.value;
                  const defs = allowedUnitTypes(unit.class);
                  unit.type = defs[0]?.type || '';
                  unit.equipment = [];
                  unit.seats = null;
                  hideError();
                  renderUnits();
                  updateCostSummary();
                });
                return select;
              })())
            : null;

          const typeField = makeInputGroup('Type', (() => {
            const select = document.createElement('select');
            select.className = 'station-builder-select';
            select.dataset.focusKey = `unit-${idx}-type`;
            unitDefs.forEach((def) => {
              const opt = document.createElement('option');
              opt.value = def.type;
              opt.textContent = def.type;
              select.appendChild(opt);
            });
            if (!unitDefs.find((def) => def.type === unit.type)) {
              unit.type = unitDefs[0]?.type || '';
            }
            select.value = unit.type;
            select.addEventListener('change', () => {
              unit.type = select.value;
              const def = unitDefs.find((d) => d.type === unit.type);
              const slots = Number(def?.equipmentSlots || 0);
              if (!slots) unit.equipment = [];
              if (slots && unit.equipment.length > slots) {
                unit.equipment = unit.equipment.slice(0, slots);
              }
              unit.seats = null;
              hideError();
              renderUnits();
              updateCostSummary();
            });
            return select;
          })());

          const tagField = makeInputGroup('Tag', (() => {
            const input = document.createElement('input');
            input.className = 'station-builder-input';
            input.value = unit.tag;
            input.dataset.focusKey = `unit-${idx}-tag`;
            input.addEventListener('input', () => { unit.tag = input.value; });
            return input;
          })());

          const priorityField = makeInputGroup('Priority', (() => {
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '1';
            input.max = '5';
            input.value = unit.priority;
            input.className = 'station-builder-input';
            input.dataset.focusKey = `unit-${idx}-priority`;
            input.addEventListener('input', () => {
              unit.priority = Math.min(5, Math.max(1, Number(input.value) || 1));
            });
            return input;
          })());

          const patrolField = makeInputGroup('Patrol', (() => {
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = Boolean(unit.patrol);
            input.dataset.focusKey = `unit-${idx}-patrol`;
            input.addEventListener('change', () => {
              unit.patrol = input.checked;
            });
            return input;
          })());

          const seatField = makeInputGroup('Seats', (() => {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = 'station-builder-input';
            input.dataset.focusKey = `unit-${idx}-seats`;
            const seatDef = unitDefs.find((d) => d.type === unit.type);
            const defCap = Number(seatDef?.capacity || 0) || 0;
            if (defCap > 0) {
              input.min = '1';
              input.max = String(defCap);
              const current = unit.seats != null ? unit.seats : defCap;
              input.value = String(current);
              input.placeholder = String(defCap);
              input.title = `Enter between 1 and ${defCap}. Leave blank to use default (${defCap}).`;
              input.addEventListener('input', () => {
                const raw = input.value.trim();
                if (!raw) {
                  unit.seats = null;
                  return;
                }
                let value = Math.floor(Number(raw));
                if (!Number.isFinite(value)) {
                  unit.seats = null;
                  input.value = '';
                  return;
                }
                value = Math.max(1, Math.min(defCap, value));
                unit.seats = value === defCap ? null : value;
                input.value = String(value);
              });
              input.addEventListener('blur', () => {
                const raw = input.value.trim();
                if (!raw) {
                  unit.seats = null;
                  input.value = '';
                  return;
                }
                let value = Math.floor(Number(raw));
                if (!Number.isFinite(value)) {
                  unit.seats = null;
                  input.value = '';
                  return;
                }
                value = Math.max(1, Math.min(defCap, value));
                unit.seats = value === defCap ? null : value;
                input.value = String(value);
              });
            } else {
              input.value = '';
              input.placeholder = 'N/A';
              input.disabled = true;
            }
            return input;
          })());

          const equipField = document.createElement('div');
          equipField.className = 'station-builder-checkboxes';
          const equipLabel = document.createElement('div');
          const def = unitDefs.find((d) => d.type === unit.type);
          const slots = Number(def?.equipmentSlots || 0);
          equipLabel.textContent = slots ? `Equipment (${slots} slots)` : 'Equipment';
          equipLabel.style.fontWeight = 'bold';
          wrapper.append(
            nameField,
            ...(classField ? [classField] : []),
            typeField,
            tagField,
            priorityField,
            patrolField,
            seatField,
            equipLabel
          );
          const opts = equipmentOptions();
          unit.equipment = unit.equipment.filter((name) => opts.some((opt) => opt.name === name));
          opts.forEach((opt) => {
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = unit.equipment.includes(opt.name);
            checkbox.dataset.focusKey = `unit-${idx}-equipment-${opt.name}`;
            checkbox.addEventListener('change', () => {
              if (checkbox.checked) {
                if (slots && unit.equipment.length >= slots) {
                  checkbox.checked = false;
                  showError(`Unit ${idx + 1} has no free equipment slots.`);
                  return;
                }
                if (!unit.equipment.includes(opt.name)) unit.equipment.push(opt.name);
              } else {
                unit.equipment = unit.equipment.filter((name) => name !== opt.name);
              }
              hideError();
              updateCostSummary();
            });
            const span = document.createElement('span');
            span.textContent = opt.cost ? `${opt.name} ($${opt.cost})` : opt.name;
            label.append(checkbox, span);
            equipField.appendChild(label);
          });
          if (!opts.length) {
            const emptyEquip = document.createElement('div');
            emptyEquip.className = 'station-builder-empty';
            emptyEquip.textContent = 'No equipment available for this class.';
            equipField.appendChild(emptyEquip);
          }
          wrapper.appendChild(equipField);

          if (!Array.isArray(unit.personnel)) unit.personnel = [];
          const personnelHeader = document.createElement('div');
          personnelHeader.className = 'station-builder-row';
          const personnelTitle = document.createElement('h4');
          personnelTitle.textContent = 'Personnel';
          const addPersonBtn = document.createElement('button');
          addPersonBtn.textContent = 'Add Personnel';
          const addPersonCountInput = document.createElement('input');
          addPersonCountInput.type = 'number';
          addPersonCountInput.min = '1';
          addPersonCountInput.value = String(unit.personnelAddCount || 1);
          addPersonCountInput.className = 'station-builder-input';
          addPersonCountInput.style.width = '70px';
          addPersonCountInput.dataset.focusKey = `unit-${idx}-person-count`;
          addPersonCountInput.addEventListener('input', () => {
            unit.personnelAddCount = Math.max(1, Math.floor(Number(addPersonCountInput.value) || 1));
          });
          addPersonBtn.addEventListener('click', async () => {
            await addPersonnelToUnit(unit, idx, unit.personnelAddCount || 1);
          });
          personnelHeader.append(personnelTitle, addPersonBtn, addPersonCountInput);
          wrapper.appendChild(personnelHeader);

          const personnelList = document.createElement('div');
          personnelList.className = 'station-builder-list';
          const trainings = trainingOptions();
          if (!unit.personnel.length) {
            const empty = document.createElement('div');
            empty.className = 'station-builder-empty';
            empty.textContent = 'No personnel assigned.';
            personnelList.appendChild(empty);
          } else {
            unit.personnel.forEach((person, personIdx) => {
              if (!Array.isArray(person.training)) person.training = [];
              const personCard = document.createElement('div');
              personCard.className = 'station-builder-person';
              const personHeader = document.createElement('div');
              personHeader.className = 'station-builder-header';
              personHeader.textContent = `Personnel ${personIdx + 1}`;
              const removePersonBtn = document.createElement('button');
              removePersonBtn.textContent = 'Remove';
              removePersonBtn.addEventListener('click', () => {
                unit.personnel.splice(personIdx, 1);
                renderUnits();
                updateCostSummary();
              });
              personHeader.appendChild(removePersonBtn);
              personCard.appendChild(personHeader);

              const nameField = makeInputGroup('Name', (() => {
                const input = document.createElement('input');
                input.className = 'station-builder-input';
                input.value = person.name;
                input.dataset.focusKey = `unit-${idx}-person-${personIdx}-name`;
                input.addEventListener('input', () => { person.name = input.value; hideError(); });
                return input;
              })());

              const rankField = makeInputGroup('Rank', (() => {
                const select = document.createElement('select');
                select.className = 'station-builder-select';
                select.dataset.focusKey = `unit-${idx}-person-${personIdx}-rank`;
                const applyOptions = (selectedValue = '') => {
                  const safe = Array.isArray(currentRankOptions) ? currentRankOptions : [];
                  const seen = new Set();
                  select.innerHTML = '';
                  const blank = document.createElement('option');
                  blank.value = '';
                  blank.textContent = '';
                  select.appendChild(blank);
                  safe.forEach((opt) => {
                    const value = cleanRankValue(opt);
                    if (!value) return;
                    const key = value.toLowerCase();
                    if (seen.has(key)) return;
                    seen.add(key);
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                  });
                  const current = cleanRankValue(selectedValue || person.rank);
                  if (current && !seen.has(current.toLowerCase())) {
                    const option = document.createElement('option');
                    option.value = current;
                    option.textContent = current;
                    select.appendChild(option);
                  }
                  select.value = current || '';
                };
                applyOptions(person.rank || '');
                select.addEventListener('change', () => {
                  const val = cleanRankValue(select.value);
                  person.rank = val || '';
                  hideError();
                });
                return select;
              })());

              const trainingField = document.createElement('div');
              trainingField.className = 'station-builder-checkboxes';
              const label = document.createElement('div');
              label.textContent = 'Training';
              label.style.fontWeight = 'bold';
              personCard.append(nameField, rankField, label);
              const trainingSet = new Set((person.training || []).map((name) => String(name || '').toLowerCase()));
              trainings.forEach((opt) => {
                const tLabel = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = trainingSet.has(opt.name.toLowerCase());
                checkbox.dataset.focusKey = `unit-${idx}-person-${personIdx}-training-${opt.name}`;
                checkbox.addEventListener('change', () => {
                  const name = opt.name;
                  const targetKey = name.toLowerCase();
                  if (checkbox.checked) {
                    const combined = Array.isArray(person.training) ? person.training.slice() : [];
                    if (!combined.some((item) => String(item || '').toLowerCase() === targetKey)) {
                      combined.push(name);
                    }
                    const collapsed = collapseTrainingListForState(combined);
                    person.training = expandTrainingListForState(collapsed);
                  } else {
                    let current = Array.isArray(person.training) ? person.training.slice() : [];
                    current = current.filter((item) => String(item || '').toLowerCase() !== targetKey);
                    let collapsed = collapseTrainingListForState(current);
                    collapsed = collapsed.filter((item) => String(item || '').toLowerCase() !== targetKey);
                    const toRemove = new Set();
                    collapsed.forEach((item) => {
                      const expandedSingle = expandTrainingListForState([item]);
                      if (expandedSingle.some((t) => String(t || '').toLowerCase() === targetKey)) {
                        toRemove.add(String(item || '').toLowerCase());
                      }
                    });
                    if (toRemove.size) {
                      collapsed = collapsed.filter((item) => !toRemove.has(String(item || '').toLowerCase()));
                    }
                    person.training = expandTrainingListForState(collapsed);
                  }
                  hideError();
                  renderUnits();
                  updateCostSummary();
                });
                const span = document.createElement('span');
                span.textContent = opt.cost ? `${opt.name} ($${opt.cost})` : opt.name;
                tLabel.append(checkbox, span);
                trainingField.appendChild(tLabel);
              });
              if (!trainings.length) {
                const emptyTrain = document.createElement('div');
                emptyTrain.className = 'station-builder-empty';
                emptyTrain.textContent = 'No training available for this class.';
                trainingField.appendChild(emptyTrain);
              }
              personCard.appendChild(trainingField);
              personnelList.appendChild(personCard);
            });
          }
          wrapper.appendChild(personnelList);
          unitsContainer.appendChild(wrapper);
        });
      });
    }

    function calculateCostBreakdown() {
      const baseStationCost =
        BUILD_COST +
        BAY_COST * (Number(state.bays) || 0) +
        EQUIP_SLOT_COST * (Number(state.equipment_slots) || 0) +
        (['police', 'jail'].includes(state.type) ? HOLDING_COST * (Number(state.holding_cells) || 0) : 0);
      const stationMultiplier = state.type === 'fire_rescue' ? 1.5 : 1;
      const stationCost = Math.round(baseStationCost * stationMultiplier);
      const unitCost = state.units.reduce((sum, unit) => {
        const def = findUnitDefinitionByType(unit.class, unit.type);
        return sum + (Number(def?.cost) || 0);
      }, 0);
      const stationEquipCost = state.storageEquipment.reduce((sum, item) => sum + findEquipmentCost(item), 0);
      const unitEquipCost = state.units.reduce(
        (sum, unit) => sum + unit.equipment.reduce((s, item) => s + findEquipmentCost(item), 0),
        0
      );
      const personnelCost = state.units.reduce((sum, unit) => {
        const unitPersonnel = Array.isArray(unit.personnel) ? unit.personnel : [];
        const unitSum = unitPersonnel.reduce((innerSum, person) => {
          if (!person.name?.trim()) return innerSum;
          const collapsedTraining = collapseTrainingListForState(person.training);
          const trainingCost = collapsedTraining.reduce((s, t) => s + findTrainingCost(t), 0);
          return innerSum + BASE_PERSON_COST + trainingCost;
        }, 0);
        return sum + unitSum;
      }, 0);
      const total = stationCost + unitCost + stationEquipCost + unitEquipCost + personnelCost;
      return { stationCost, unitCost, stationEquipCost, unitEquipCost, personnelCost, total };
    }

    function updateCostSummary() {
      const costs = calculateCostBreakdown();
      summaryContent.innerHTML = `
        <div>Station build: $${costs.stationCost.toLocaleString()}</div>
        <div>Units: $${costs.unitCost.toLocaleString()}</div>
        <div>Equipment: $${(costs.stationEquipCost + costs.unitEquipCost).toLocaleString()} (Station $${costs.stationEquipCost.toLocaleString()}, Units $${costs.unitEquipCost.toLocaleString()})</div>
        <div>Personnel: $${costs.personnelCost.toLocaleString()}</div>
        <div>Total: $${costs.total.toLocaleString()}</div>
      `;
    }

    function buildPayload() {
      hideError();
      try {
        const trimmedName = state.name.trim();
        if (!trimmedName) throw new Error('Station name is required.');
        if (!allowedTypes.includes(state.type)) throw new Error('Select a valid station class.');
        const bays = Math.max(0, Number(state.bays) || 0);
        if (state.units.length && bays < state.units.length) {
          throw new Error(`Bays must be at least ${state.units.length} for the selected units.`);
        }
        const equipmentSlots = Math.max(0, Number(state.equipment_slots) || 0);
        if (state.storageEquipment.length > equipmentSlots) {
          throw new Error('Not enough equipment slots for station storage.');
        }
        const units = state.units.map((unit, idx) => {
          const name = unit.name.trim();
          if (!name) throw new Error(`Unit ${idx + 1} requires a name.`);
          if (!unit.type) throw new Error(`Unit ${idx + 1} requires a type.`);
          const def = allowedUnitTypes(unit.class).find((d) => d.type === unit.type);
          if (!def) throw new Error(`Unit ${idx + 1} type is invalid.`);
          const slots = Number(def?.equipmentSlots || 0);
          if (slots && unit.equipment.length > slots) {
            throw new Error(`Unit ${idx + 1} exceeds equipment slots (${unit.equipment.length}/${slots}).`);
          }
          if (!slots && unit.equipment.length) {
            throw new Error(`Unit ${idx + 1} cannot carry equipment.`);
          }
          const unitPersonnel = Array.isArray(unit.personnel) ? unit.personnel : [];
          const seatCapacity = Number(def?.capacity || 0) || 0;
          if (seatCapacity && unitPersonnel.length > seatCapacity) {
            throw new Error(`Unit ${idx + 1} exceeds seat capacity (${unitPersonnel.length}/${seatCapacity}).`);
          }
          let seats = null;
          const defaultCap = Number(def?.capacity || 0) || 0;
          if (defaultCap > 0) {
            if (unit.seats != null) {
              let value = Math.floor(Number(unit.seats));
              if (Number.isFinite(value)) {
                value = Math.max(1, Math.min(defaultCap, value));
                seats = value === defaultCap ? null : value;
              }
            }
          } else if (unit.seats != null) {
            let value = Math.floor(Number(unit.seats));
            if (Number.isFinite(value)) {
              seats = Math.max(0, value);
            }
          }
          const personnel = unitPersonnel
            .map((person, personIdx) => {
              const pname = person.name.trim();
              if (!pname) return null;
              const uniqueTraining = collapseTrainingListForState(person.training);
              const rank = cleanRankValue(person.rank);
              return { name: pname, rank: rank || null, training: uniqueTraining };
            })
            .filter(Boolean);

          return {
            name,
            type: def.type,
            class: def.class,
            tag: unit.tag ? unit.tag.trim() : '',
            priority: Math.min(5, Math.max(1, Number(unit.priority) || 1)),
            equipment: unit.equipment.slice(),
            patrol: Boolean(unit.patrol),
            seats,
            personnel,
          };
        });

        return {
          name: trimmedName,
          department: state.department,
          type: state.type,
          bays,
          equipment_slots: equipmentSlots,
          holding_cells: ['police', 'jail'].includes(state.type) ? Math.max(0, Number(state.holding_cells) || 0) : 0,
          bed_capacity: state.type === 'hospital' ? Math.max(0, Number(state.bed_capacity) || 0) : 0,
          equipment: state.storageEquipment.slice(),
          units,
        };
      } catch (err) {
        showError(err.message || 'Invalid input.');
        return null;
      }
    }

    function close(result) {
      document.removeEventListener('keydown', keyHandler);
      overlay.remove();
      resolve(result);
    }

    const keyHandler = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        close(null);
      }
    };
    document.addEventListener('keydown', keyHandler);

    cancelBtn.addEventListener('click', () => close(null));
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(null); });
    createBtn.addEventListener('click', () => {
      const payload = buildPayload();
      if (!payload) return;
      close(payload);
    });

    function addUnits(count = 1) {
      const total = Math.max(1, Math.floor(Number(count) || 1));
      for (let i = 0; i < total; i += 1) {
        const classOptions = stationUnitClasses(state.type);
        const unitClass = classOptions[0] || state.type;
        const defs = allowedUnitTypes(unitClass);
        state.units.push({
          name: '',
          type: defs[0]?.type || '',
          class: unitClass,
          tag: '',
          priority: 1,
          equipment: [],
          patrol: false,
          personnel: [],
          personnelAddCount: 1,
          seats: null,
        });
      }
      renderUnits();
      updateCostSummary();
    }

    addUnitBtn.addEventListener('click', () => addUnits(1));
    addUnitBatchBtn.addEventListener('click', () => {
      addUnits(addUnitCountInput.value);
    });

    async function fetchRandomPersonName() {
      try {
        const rnd = await fetch('/api/random-name').then(r => r.json());
        if (rnd?.first && rnd?.last) {
          return `${rnd.first} ${rnd.last}`;
        }
      } catch {
        // ignore failures and fall back to empty string
      }
      return '';
    }

    async function addPersonnelToUnit(unit, unitIndex, count = 1) {
      if (!unit) return;
      if (!Array.isArray(unit.personnel)) unit.personnel = [];
      const total = Math.max(1, Math.floor(Number(count) || 1));
      const options = trainingOptions();
      const defaults = getDefaultTrainingsForState(options);
      const expandedDefaults = expandTrainingListForState(defaults);
      const def = allowedUnitTypes(unit.class).find((entry) => entry.type === unit.type);
      const seatCap = Number(def?.capacity || 0) || 0;
      for (let i = 0; i < total; i += 1) {
        if (seatCap && unit.personnel.length >= seatCap) {
          showError(`Unit ${unitIndex + 1} is at seat capacity (${seatCap}).`);
          break;
        }
        const person = { name: '', rank: '', training: expandedDefaults.slice() };
        const randomName = await fetchRandomPersonName();
        if (randomName) person.name = randomName;
        unit.personnel.push(person);
      }
      renderUnits();
      updateCostSummary();
    }

    typeSelect.addEventListener('change', () => {
      state.type = typeSelect.value;
      sanitizeByType();
      renderStationEquipment();
      renderUnits();
      updateCostSummary();
    });

    sanitizeByType();
    renderStationEquipment();
    renderUnits();
    refreshCurrentRankOptions();
    updateCostSummary();
    nameInput.focus();
  });
}

// Build station
document.getElementById('buildStation').addEventListener('click', () => {
  buildStationMode = true;
  alert('Click the map to place your new station');
});

map.on('click', async (e) => {
  if (!buildStationMode) return;
  buildStationMode = false;
  pendingStationCoords = null;
  const result = await openStationBuilderModal();
  if (!result) return;
  const payload = {
    ...result,
    lat: e.latlng.lat,
    lon: e.latlng.lng,
  };
  try {
    const res = await fetch('/api/stations', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    if (!res.ok) {
      notifyError(`Failed to create station: ${data.error || res.statusText}`);
      return;
    }
    const totalCost = Number(data?.cost_breakdown?.total) || 0;
    notifySuccess(`Station created. Total cost: $${totalCost.toLocaleString()}`);
    if (typeof refreshWallet === 'function') refreshWallet();
    fetchStations();
  } catch (err) {
    notifyError(`Failed to create station: ${err.message}`);
  }
});

function randomCount({min=0, max=0, chance=1}) {
  min = Math.floor(min); max = Math.floor(max);
  if (max <= min) return min;
  if (Math.random() < chance) return max;
  return min + Math.floor(Math.random() * (max - min));
}

function instantiatePatients(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    return { count, codes: p.codes };
  }).filter(p => p.count > 0);
}

function instantiatePrisoners(arr) {
  return (arr || []).map(p => {
    const count = randomCount(p);
    const transportChance = Number(p.transportChance) || 0;
    let transport = 0;
    for (let i = 0; i < count; i++) {
      if (Math.random() < transportChance) transport++;
    }
    return { count, transport };
  }).filter(p => p.count > 0);
}

// Generate Mission
async function generateMission(retry = false, excludeIndex = null) {
  if (missionTemplates.length === 0) { notifyError("No mission templates loaded."); return; }
  const stations = await fetch('/api/stations').then(r => r.json()).catch(() => []);
  if (!stations.length) { notifyError("No stations available."); return; }
  const st = stations[Math.floor(Math.random() * stations.length)];
  const radius = 5000; // meters

  let availableTemplates = missionTemplates;
  if (excludeIndex !== null) {
    availableTemplates = missionTemplates.filter((_, idx) => idx !== excludeIndex);
    if (!availableTemplates.length) return;
  }
  const weights = availableTemplates.map(t => Math.max(1, 6 - (Number(t.frequency) || 3)));
  const totalWeight = weights.reduce((a, b) => a + b, 0);
  let pick = Math.random() * totalWeight;
  let template = availableTemplates[0];
  for (let i = 0; i < availableTemplates.length; i++) {
    if ((pick -= weights[i]) < 0) { template = availableTemplates[i]; break; }
  }
  const templateIndex = missionTemplates.indexOf(template);

  let lat, lon;
  if (template.trigger_type === 'poi' && template.trigger_filter) {
    try {
      const pois = await fetch(`/api/pois?lat=${st.lat}&lon=${st.lon}&radius=${radius}`)
        .then(r => r.json()).catch(() => []);
      const matches = pois.filter(p => {
        if (!p.tags) return false;
        if ((template.trigger_filter || "").includes("=")) {
          const [key, val] = template.trigger_filter.split("=");
          return p.tags[key] === val;
        }
        return p.tags.amenity === template.trigger_filter;
      });
      if (matches.length) {
        const poi = matches[Math.floor(Math.random() * matches.length)];
        // `poi` may be an area (way/relation) from Overpass which stores its
        // coordinates under `center`.  Use those center coordinates if direct
        // lat/lon are not provided so the mission spawns at the POI itself.
        lat = poi.lat ?? poi.center?.lat;
        lon = poi.lon ?? poi.center?.lon;
      } else {
        console.warn(`No matching POI found for mission template "${template?.name || template?.id}" (ID: ${template?.id})`, template);
        if (!retry) return generateMission(true, templateIndex);
        return;
      }
    } catch (e) {
      console.error('POI lookup failed', e);
      notifyError('POI lookup failed.');
      return;
    }
  } else if (template.trigger_type === 'intersection' && template.trigger_filter) {
    const [r1Raw, r2Raw] = String(template.trigger_filter).split('|');
    const road1 = r1Raw?.trim();
    const road2 = r2Raw?.trim();
    if (road1 && road2) {
      try {
        const query = `[out:json];(
          way["name"="${road1}"](around:${radius},${st.lat},${st.lon});
        )->.r1;(
          way["name"="${road2}"](around:${radius},${st.lat},${st.lon});
        )->.r2;
        node(w.r1)(w.r2);
        out;`;
        const resp = await fetch('https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(query));
        const data = await resp.json();
        if (Array.isArray(data.elements) && data.elements.length) {
          const inter = data.elements[0];
          lat = inter.lat; lon = inter.lon;
        } else {
          console.warn(`No intersection found for roads "${road1}" and "${road2}"`);
        }
      } catch (e) {
        console.error('Intersection lookup failed', e);
      }
    }
  }
  if (lat === undefined || lon === undefined) {
    try {
      const roadQuery = `[out:json];way["highway"](around:${radius},${st.lat},${st.lon});out geom;`;
      const roadResp = await fetch('https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(roadQuery));
      const roadData = await roadResp.json();
      if (Array.isArray(roadData.elements) && roadData.elements.length) {
        const way = roadData.elements[Math.floor(Math.random() * roadData.elements.length)];
        const geom = Array.isArray(way.geometry) ? way.geometry : [];
        if (geom.length) {
          const pt = geom[Math.floor(Math.random() * geom.length)];
          lat = pt.lat;
          lon = pt.lon;
        }
      }
    } catch (e) { console.error('Road lookup failed', e); }
  }
  if (lat === undefined || lon === undefined) {
    lat = st.lat;
    lon = st.lon;
  }

  const missionData = {
    type: template.name, lat, lon,
    required_units: template.required_units,
    required_training: template.required_training || [],
    equipment_required: template.equipment_required || [],
    patients: instantiatePatients(template.patients),
    prisoners: instantiatePrisoners(template.prisoners),
    modifiers: template.modifiers || [],
    penalty_options: template.penalty_options || [],
    penalties: [],
    timing: template.timing ?? 10
  };
  try {
    const res = await fetch('/api/missions', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(missionData) });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    playSound('/audio/newalert.mp3');
    await fetchMissions();
  } catch (err) { console.error("Failed to create mission:", err); notifyError("Failed to create mission."); }
}

document.getElementById('generateMission').addEventListener('click', () => generateMission());

// Start patrols for all units flagged
document.getElementById('startPatrols').addEventListener('click', async () => {
  const units = await fetch('/api/units').then(r => r.json()).catch(()=>[]);
  cacheUnits(units);
  units.filter(u => u.patrol).forEach(u => startUnitPatrol(u));
});

// Clear Missions
document.getElementById("clearMissions").addEventListener("click", async ()=>{
  if (!await showConfirmModal("Clear ALL missions?")) return;
  await fetch("/api/missions", { method:"DELETE" });
  fetchMissions();
});

// Mission generation speed controls
let missionGenTimer = null;
let missionGenRange = null;

function scheduleMissionGeneration() {
  if (!missionGenRange) return;
  const [min, max] = missionGenRange;
  const delay = (Math.floor(Math.random() * (max - min + 1)) + min) * 1000;
  missionGenTimer = setTimeout(() => {
    const btn = document.getElementById('generateMission');
    if (btn) btn.click();
    scheduleMissionGeneration();
  }, delay);
}

function setMissionGenerationSpeed(range) {
  if (missionGenTimer) clearTimeout(missionGenTimer);
  missionGenRange = range;
  if (range) scheduleMissionGeneration();
}

document.querySelectorAll('.mission-speed').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mission-speed').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    switch (btn.dataset.speed) {
      case 'pause':
        setMissionGenerationSpeed(null);
        break;
      case 'slow':
        setMissionGenerationSpeed([90,150]);
        break;
      case 'medium':
        setMissionGenerationSpeed([30,90]);
        break;
      case 'fast':
        setMissionGenerationSpeed([10,30]);
        break;
    }
  });
});

// Focus
document.addEventListener("click", (e)=>{
  if (e.target.classList.contains("focus-mission") || e.target.classList.contains("focus-station")) {
    const lat = parseFloat(e.target.dataset.lat);
    const lon = parseFloat(e.target.dataset.lon);
    map.setView([lat, lon], 16);
  }
});

// Assign personnel modal
async function openAssignModal(unitId, stationId) {
  const modal = document.getElementById("assignPersonnelModal");
  const content = document.getElementById("assignModalContent");

  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();

  const unassigned = personnel.filter(p => !p.unit_id);

  if (!unassigned.length) {
    content.innerHTML = "<p>No available personnel to assign.</p>";
    modal.style.display = "block";
    return;
  }

  content.innerHTML = `
    <select id="assign-personnel-select" style="width:100%;">
      ${unassigned.map(p => `
        <option value="${p.id}">${p.name || '(no name)'}${Array.isArray(p.training) && p.training.length ? ` (${p.training.join(', ')})` : ''}</option>
      `).join('')}
    </select>
    <br><br>
    <button id="assignPersonnelConfirm">Assign</button>
  `;
  const unitTypeSelect = detail.querySelector('#unit-type');
  const unitClassSelect = detail.querySelector('#unit-class');
  const unitSeatInput = detail.querySelector('#unit-seats');
  const updateSeatField = (forceDefault = false) => {
    if (!unitSeatInput || !unitTypeSelect) return;
    const selectedClass = unitClassSelect ? unitClassSelect.value : station.type;
    const def = findUnitDefinitionByType(selectedClass, unitTypeSelect.value);
    const defaultSeats = Number(def?.capacity || 0) || 0;
    if (!defaultSeats) {
      unitSeatInput.value = '';
      unitSeatInput.placeholder = 'N/A';
      unitSeatInput.disabled = true;
      unitSeatInput.title = 'This unit type cannot carry personnel.';
      return;
    }
    unitSeatInput.disabled = false;
    unitSeatInput.min = '1';
    unitSeatInput.max = String(defaultSeats);
    unitSeatInput.placeholder = String(defaultSeats);
    unitSeatInput.title = `Enter between 1 and ${defaultSeats}. Leave blank to use default (${defaultSeats}).`;
    const raw = unitSeatInput.value.trim();
    if (!raw) {
      if (forceDefault) {
        unitSeatInput.value = String(defaultSeats);
      } else {
        unitSeatInput.value = '';
      }
      return;
    }
    let value = Math.floor(Number(raw));
    if (!Number.isFinite(value)) {
      unitSeatInput.value = String(defaultSeats);
      return;
    }
    value = Math.max(1, Math.min(defaultSeats, value));
    unitSeatInput.value = String(value);
  };
  if (unitSeatInput && unitTypeSelect) {
    updateSeatField(true);
    unitClassSelect?.addEventListener('change', () => updateSeatField(true));
    unitTypeSelect.addEventListener('change', () => updateSeatField(true));
    unitSeatInput.addEventListener('blur', () => updateSeatField(false));
  }

  document.getElementById("assignPersonnelConfirm").onclick = async () => {
    const select = document.getElementById("assign-personnel-select");
    const pid = parseInt(select.value, 10);
    if (!pid) return;
    await assignPersonnel(pid, unitId, stationId);
  };

  modal.style.display = "block";
}

async function cancelUnit(unitId, stationId) {
  if (!await showConfirmModal('Cancel this unit?')) return;

  let mission = null;
  try {
    mission = await fetchNoCache(`/api/units/${unitId}/mission`).then(r => r.ok ? r.json() : null);
  } catch {}

  if (mission && mission.id) {
    await clearAssignedUnit(mission.id, unitId);
    await checkMissionCompletion(mission);
  } else {
    const unit = _unitById.get(unitId);
    const st = unit ? _stationById.get(unit.station_id) : null;
    if (unit && st) {
      unit.responding = false;
      _unitById.set(unitId, unit);
      ensureUnitMarker(unit);
      const entry = unitMarkers.get(unit.id);
      const current = entry?.marker.getLatLng() || L.latLng(st.lat, st.lon);
      routeAndAnimateUnit(
        unit.id,
        [current.lat, current.lng],
        [st.lat, st.lon],
          TRAVEL_SPEED[unit.type] || CLASS_SPEED[unit.class] || 56,
        () => {
          const rp = unitRoutes.get(unit.id);
          if (rp) { try { map.removeLayer(rp); } catch {} unitRoutes.delete(unit.id); }
          fetch(`/api/unit-travel/${unit.id}`, { method:'DELETE' }).catch(()=>{});
        },
        { phase: 'return' }
      );
      await fetch(`/api/units/${unitId}/status`, {
        method:'PATCH',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ status:'available' })
      });
    }
  }

  refreshStationPanelNoCache(stationId);
  if (document.getElementById('tab-units')?.classList.contains('active')) {
    renderUnitList();
  }
}

async function showUnitDetails(unitId) {
  const modal = document.getElementById("unitDetailModal");
  const content = document.getElementById("unitDetailContent");

  const unit = _unitById.get(unitId);
  const station = unit ? _stationById.get(unit.station_id) : null;
  let mission = null;
  try {
    mission = await fetchNoCache(`/api/units/${unitId}/mission`).then(r => r.ok ? r.json() : null);
  } catch {}

  const res = await fetch(`/api/personnel?station_id=${unit?.station_id ?? ''}`);
  const personnel = await res.json();
  const assigned = personnel.filter(p => p.unit_id === unitId);

  const eqNames = Array.isArray(unit?.equipment)
    ? unit.equipment.map(e => typeof e === 'string' ? e : e?.name).filter(Boolean)
    : [];

  const equipmentHtml = eqNames.length
    ? `<ul>${eqNames.map(n => `<li>${n} <button class="remove-equip-btn" data-name="${n}">Remove</button></li>`).join('')}</ul>`
    : '<em>No equipment</em>';
  const availableEq = Array.isArray(station?.equipment) ? station.equipment : [];
  const assignHtml = availableEq.length
    ? `<select id="unit-equip-select">${availableEq.map(n=>`<option value="${n}">${n}</option>`).join('')}</select>
       <button id="assign-equip-btn">Assign</button>`
    : '<p><em>No equipment in station storage.</em></p>';
  const defaultSeats = Number(unit?.default_capacity ?? defaultSeatCapacity(unit?.class, unit?.type)) || 0;
  const activeSeats = Number(unit?.seat_capacity ?? (defaultSeats || 0)) || 0;
  const seatDetails = defaultSeats
    ? `${Math.max(1, Math.min(defaultSeats, activeSeats || defaultSeats))}${activeSeats !== defaultSeats ? ` (Max ${defaultSeats})` : ''}`
    : 'N/A';

  const personnelHtml = assigned.length
    ? `<ul>${assigned.map(p => `
          <li>
            ${p.name || '(no name)'} ${Array.isArray(p.training) && p.training.length ? `(${p.training.join(', ')})` : ''}
            <button class="unassign-btn" data-person-id="${p.id}" data-station-id="${p.station_id}">Unassign</button>
          </li>
        `).join('')}</ul>`
    : '<p>No personnel assigned to this unit.</p>';

  const missionHtml = mission && mission.id
    ? `<p><strong>Current Mission:</strong> <span class="mission-link" data-missionid="${mission.id}" style="cursor:pointer; color:blue;">#${mission.id} ${mission.type}</span> <button id="cancel-mission-btn" data-missionid="${mission.id}">Cancel</button></p>`
    : '<p><strong>Current Mission:</strong> None</p>';
  const patrolHtml = `<p><label><input type="checkbox" id="patrol-toggle" ${unit?.patrol ? 'checked' : ''}/> Patrol</label></p>`;
  const cancelUnitHtml = unit?.status !== 'available'
    ? '<p><button id="cancel-unit-btn">Cancel Unit</button></p>'
    : '';

  content.innerHTML = `
    <p><strong>Name:</strong> ${unit?.name || 'Unknown'} <button id="edit-unit-btn">Edit</button></p>
    <p><strong>Priority:</strong> ${unit?.priority ?? 1}</p>
    <p><strong>Seats:</strong> ${seatDetails}</p>
    <p><strong>Station:</strong> ${station?.name || 'Unknown'}</p>
    <p><strong>Vehicle Class:</strong> ${unit?.class || 'Unknown'} (${unit?.type || ''})</p>
    ${missionHtml}
    ${patrolHtml}
    ${cancelUnitHtml}
    <button id="change-unit-icon">Change Icon</button>
    <h4>Equipment Aboard</h4>
    ${equipmentHtml}
    <h4>Assign Equipment from Station</h4>
    ${assignHtml}
    <h4>Assigned Personnel</h4>
    ${personnelHtml}
  `;

  const patrolToggle = content.querySelector('#patrol-toggle');
  patrolToggle?.addEventListener('change', async () => {
    const val = patrolToggle.checked;
    await fetch(`/api/units/${unitId}/patrol`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ patrol: val })
    });
    const updated = { ...unit, patrol: val };
    _unitById.set(unitId, updated);
    if (val) startUnitPatrol(updated);
    else {
      patrolStates.delete(unitId);
      fetch(`/api/unit-travel/${unitId}`, { method: 'DELETE' }).catch(() => {});
    }
  });

  const cancelBtn = content.querySelector('#cancel-mission-btn');
  cancelBtn?.addEventListener('click', async () => {
    const mid = parseInt(cancelBtn.dataset.missionid,10);
    await clearAssignedUnit(mid, unitId);
    modal.style.display = 'none';
  });

  const cancelUnitBtn = content.querySelector('#cancel-unit-btn');
  cancelUnitBtn?.addEventListener('click', async () => {
    await cancelUnit(unitId, unit?.station_id);
    modal.style.display = 'none';
  });

  content.querySelectorAll('.unassign-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const pid = parseInt(btn.dataset.personId, 10);
      const sid = parseInt(btn.dataset.stationId, 10);
      await fetch(`/api/personnel/${pid}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ unit_id: null })
      });
      modal.style.display = "none";
      showStationDetails({ id: sid });
    });
  });
  content.querySelectorAll('.remove-equip-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const name = btn.dataset.name;
      const res = await fetch(`/api/units/${unitId}/equipment`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ station_id: unit.station_id, name })
      });
      const data = await res.json();
      if (!res.ok || !data.success) {
        notifyError(`Failed: ${data.error || res.statusText}`);
        return;
      }
      _unitById.set(unitId, { ...unit, equipment: data.equipment });
      modal.style.display = 'none';
      refreshStationPanelNoCache(unit.station_id);
    });
  });
  content.querySelector('#change-unit-icon')?.addEventListener('click', async () => {
    const url = prompt('Enter icon URL:', unit.icon || '');
    if (url === null) return;
    const resp = prompt('Enter responding icon URL (optional):', unit.responding_icon || '');
    const body = { icon: url };
    if (resp !== null) body.responding_icon = resp;
    const res = await fetch(`/api/units/${unitId}/icon`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    const data = await res.json();
    if (!res.ok || !data.success) { notifyError(`Failed: ${data.error || res.statusText}`); return; }
    _unitById.set(unitId, { ...unit, icon: url, responding_icon: resp });
    const entry = unitMarkers.get(unitId);
    if (entry) entry.marker.setIcon(unitIconFor({ ...unit, icon: url, responding_icon: resp }));
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });
  const assignBtn = content.querySelector('#assign-equip-btn');
  assignBtn?.addEventListener('click', async () => {
    const name = content.querySelector('#unit-equip-select').value;
    const res = await fetch(`/api/units/${unitId}/equipment`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ station_id: unit.station_id, name })
    });
    const data = await res.json();
    if (!res.ok || !data.success) {
      notifyError(`Failed: ${data.error || res.statusText}`);
      return;
    }
    _unitById.set(unitId, { ...unit, equipment: data.equipment });
    modal.style.display = 'none';
    refreshStationPanelNoCache(unit.station_id);
  });

  content.querySelector('#edit-unit-btn')?.addEventListener('click', () => openUnitModal(unit));

  content.querySelector('.mission-link')?.addEventListener('click', async (e) => {
    const mid = parseInt(e.target.dataset.missionid, 10);
    try {
      const m = await fetch(`/api/missions/${mid}`).then(r => r.json());
      showMissionDetails(m);
    } catch {}
  });

  modal.style.display = "block";
}

async function unassignPersonnel(personnelId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ unit_id: null }) });
  document.getElementById("unitDetailModal").style.display = "none";
  showStationDetails({ id: stationId });
}

async function assignPersonnel(personnelId, unitId, stationId) {
  await fetch(`/api/personnel/${personnelId}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ unit_id: unitId })
  });
  await showStationDetails({ id: stationId });
  const m = document.getElementById("assignPersonnelModal");
  if (m) m.style.display = "none";
}

function openUnitCreationForm(station) {
  const allowedTypes = unitTypes.filter(u => u.class === station.type);
  const unitName = prompt("Enter unit name (e.g., Engine 1):");
  if (!unitName) return;
  const unitTag = prompt("Enter unit tag (optional):") || '';
  const typeOptions = allowedTypes.map(u => u.type).join(', ');
  const selectedType = prompt(`Choose unit type (${typeOptions}):`);
  if (!allowedTypes.find(u => u.type === selectedType)) { notifyError("Invalid type for this station."); return; }
  fetch("/api/units", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ station_id: station.id, class: station.type, type: selectedType, name: unitName, tag: unitTag })
  }).then(res => res.json()).then(() => showStationDetails(station))
    .catch(err => { console.error("Failed to add unit:", err); notifyError("Error adding unit."); });
}

async function assignPersonnelToUnit(unitId, stationId) {
  const modal = document.getElementById('assignPersonnelModal');
  const content = document.getElementById('assignPersonnelContent');
  modal.style.display = 'block';
  const res = await fetch(`/api/personnel?station_id=${stationId}`);
  const personnel = await res.json();
  const available = personnel.filter(p => !p.unit_id);
  if (!available.length) { content.innerHTML = "<p>No unassigned personnel at this station.</p>"; return; }
  content.innerHTML = available.map(p => `
    <div><label><input type="checkbox" value="${p.id}" /> ${p.name} (${(p.training||[]).join(', ')})</label></div>`).join('');
  const assignBtn = document.createElement("button");
  assignBtn.textContent = "Assign Selected";
  assignBtn.onclick = async () => {
    const selected = Array.from(content.querySelectorAll("input[type=checkbox]:checked")).map(c => parseInt(c.value));
    for (const id of selected) {
      await fetch(`/api/personnel/${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ unit_id: unitId }) });
    }
    modal.style.display = 'none';
    showStationDetails({ id: stationId });
  };
  content.appendChild(assignBtn);
}

// ===== manual dispatch with busy lockout + sort/filter =====
async function getBusyUnitIds() {
  const units = await (await fetch('/api/units')).json();
  return new Set(units.filter(u => u.status && u.status !== 'available').map(u => u.id));
}

function renderManualList(stations, unitsByStation, busyIds, mission) {
  const selectSort = document.getElementById('md-sort');
  const selectClass = document.getElementById('md-class');
  const inputType = document.getElementById('md-type');
  const sortVal = selectSort ? selectSort.value : 'distance';
  const classVal = selectClass ? selectClass.value : '';
  const typeFilter = (inputType ? inputType.value : '').toLowerCase();

  const flat = [];
  for (const st of stations) {
    const units = unitsByStation[st.id] || [];
    for (const u of units) flat.push({ st, u });
  }

  const filtered = flat.filter(({u}) => {
    if (classVal && u.class !== classVal) return false;
    if (typeFilter && !u.type?.toLowerCase().includes(typeFilter)) return false;
    return true;
  });

  const mLL = [mission.lat, mission.lon];
  filtered.sort((a,b)=>{
    if (sortVal==='distance') {
      const da = haversineKm(a.st.lat, a.st.lon, mLL[0], mLL[1]);
      const db = haversineKm(b.st.lat, b.st.lon, mLL[0], mLL[1]);
      return da-db;
    } else if (sortVal==='type') {
      return (a.u.type||'').localeCompare(b.u.type||'') || (a.u.name||'').localeCompare(b.u.name||'');
    }
    return (a.u.name||'').localeCompare(b.u.name||'');
  });

  const byStation = new Map();
  for (const row of filtered) {
    if (!byStation.has(row.st.id)) byStation.set(row.st.id, []);
    byStation.get(row.st.id).push(row.u);
  }

  const html = Array.from(byStation.entries()).map(([sid, units])=>{
    const st = stations.find(s=>s.id===sid);
    return `
      <div style="margin:8px 0; padding:8px; border:1px solid #ddd; border-radius:8px;">
        <strong>${st.name} (${st.type})</strong>
        <div style="display:grid; grid-template-columns: repeat(auto-fill,minmax(220px,1fr)); gap:6px; margin-top:6px;">
          ${units.map(u=>{
            const isBusy = busyIds.has(u.id);
            const disabled = isBusy ? 'disabled' : '';
            const note = isBusy ? ' <em>(busy)</em>' : '';
            return `<label style="display:block; border:1px solid #eee; padding:6px; border-radius:6px;">
                <input type="checkbox" value="${u.id}" ${disabled}>
                <span class="unit-link" data-unitid="${u.id}" style="cursor:pointer; color:blue;">${u.name}</span> — ${u.type}${note}
              </label>`;
          }).join('')}
        </div>
      </div>`;
  }).join('');

  return html || '<em>No units match your filters.</em>';
}

async function openManualDispatch(mission) {
  const { area } = ensureDispatchArea();
  area.style.display = 'block';
  area.innerHTML = 'Loading units…';

  try {
    const stations = await fetch('/api/stations').then(r=>r.json());

    // Try the all-units endpoint first
    let allUnits = [];
    try {
      const r = await fetch('/api/units');
      if (r.ok) allUnits = await r.json();
    } catch {}

    // Fallback: pull per-station if the all-units call is empty or failed
    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      const perStation = await Promise.all(
        stations.map(st => fetch(`/api/units?station_id=${st.id}`).then(r=>r.ok ? r.json() : []))
      );
      allUnits = perStation.flat();
    }

    if (!Array.isArray(allUnits) || allUnits.length === 0) {
      area.innerHTML = '<span style="color:#b00;">No units found. (Backend returned no units.)</span>';
      return;
    }

    cacheUnits(allUnits);

    const busyIds = new Set(
      allUnits.filter(u => u.status && u.status !== 'available').map(u => u.id)
    );

    const unitsByStation = allUnits.reduce((acc,u)=>{
      const sid = u.station_id;
      if (!acc[sid]) acc[sid] = [];
      acc[sid].push(u);
      return acc;
    },{});

    area.innerHTML = `
      <div style="display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap: wrap;">
        <label>Sort:
          <select id="md-sort">
            <option value="distance" selected>Distance to call</option>
            <option value="name">Name (A–Z)</option>
            <option value="type">Type</option>
          </select>
        </label>
        <label>Filter class:
          <select id="md-class">
            <option value="">All</option>
            <option value="fire">Fire</option>
            <option value="police">Police</option>
            <option value="ambulance">Ambulance</option>
            <option value="sar">SAR</option>
          </select>
        </label>
        <label>Filter type:
          <input id="md-type" placeholder="e.g. Engine" style="width:120px;">
        </label>
        <button id="md-reset" type="button">Reset Filters</button>
      </div>
      <div style="margin:8px 0;">
        <button id="dispatchSelectedBtn">Dispatch Selected Units</button>
      </div>
      <div id="md-list">Building list…</div>`;

    const mdList = document.getElementById('md-list');
    const attach = ()=>{
      mdList.querySelectorAll('.unit-link').forEach(span=>{
        span.addEventListener('click',()=>showUnitDetails(parseInt(span.dataset.unitid,10)));
      });
    };
    const redraw = ()=>{ mdList.innerHTML = renderManualList(stations, unitsByStation, busyIds, mission); attach(); };
    document.getElementById('md-sort').onchange = redraw;
    document.getElementById('md-class').onchange = redraw;
    document.getElementById('md-type').oninput = redraw;
    document.getElementById('md-reset').onclick = ()=>{
      document.getElementById('md-sort').value = 'distance';
      document.getElementById('md-class').value = '';
      document.getElementById('md-type').value = '';
      redraw();
    };
    redraw();

    document.getElementById('dispatchSelectedBtn').onclick = () => dispatchSelectedUnits(mission.id);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Failed to load units.</span>';
  }
}

  async function sendUnitsToMission(mission, ids, area, force=false) {
    await Promise.all(ids.map(id => fetch('/api/mission-units',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ mission_id: mission.id, unit_id: id, ...(force ? { force: true } : {}) }) })));
  if (ids.length) playSound('/audio/dispatch.mp3');
  if (area) area.innerHTML = `<strong>Dispatched ${ids.length} unit(s) to mission #${mission.id}.</strong>`;
  const assigned = await refreshAssignedUnitsUI(mission.id);
  const reqDiv = document.getElementById('reqDynamic');
  if (reqDiv) { reqDiv.innerHTML = renderRequirementsDynamic(mission, assigned); attachPenaltyHandlers(mission); }

  const allUnits = await (await fetch('/api/units')).json();
  cacheUnits(allUnits);

  for (const uid of ids) {
    const u = _unitById.get(uid);
    if (!u) continue;
    const st = _stationById.get(u.station_id);
    if (!st) continue;
    u.responding = true;
    u.status = 'enroute';
    _unitById.set(uid, u);
    const marker = ensureUnitMarker(u);
    if (!marker) continue;

    fetch(`/api/units/${uid}/status`, { method:'PATCH', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ status: 'enroute' }) });

    const current = marker.getLatLng ? marker.getLatLng() : L.latLng(st.lat, st.lon);
    const from = [current.lat, current.lng];
    const to   = [mission.lat, mission.lon];
      const spd  = TRAVEL_SPEED[u.type] || CLASS_SPEED[u.class] || 56;

    routeAndAnimateUnit(
      uid, from, to, spd,
      async () => {
        await fetch(`/api/units/${uid}/status`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: 'on_scene' })
        });

        const entry = unitMarkers.get(uid);
        if (entry) { try { map.removeLayer(entry.marker); } catch {} unitMarkers.delete(uid); }

        if (window.unitRoutes && unitRoutes.has(uid)) {
          try { map.removeLayer(unitRoutes.get(uid)); } catch {}
          unitRoutes.delete(uid);
        }
        if (typeof clearUnitEta === 'function') clearUnitEta(uid);

        const assignedAfter = await refreshAssignedUnitsUI(mission.id);
        const reqDiv2 = document.getElementById('reqDynamic');
        if (reqDiv2) { reqDiv2.innerHTML = renderRequirementsDynamic(mission, assignedAfter); attachPenaltyHandlers(mission); }
        checkMissionCompletion(mission);
      },
      { mission_id: mission.id, phase: 'to_scene' }
    );
  }
}

async function dispatchSelectedUnits(missionId) {
  const area = document.getElementById('manualDispatchArea');
  if (!area) { notifyError('No dispatch list available.'); return; }
  const ids = Array.from(area.querySelectorAll('input[type="checkbox"]:checked')).map(cb=>parseInt(cb.value,10));
  if (!ids.length){ notifyError('Select at least one unit to dispatch.'); return; }
  try {
    const missions = await (await fetch('/api/missions')).json();
    const mission = missions.find(m=>m.id===missionId);
    if (!mission) { notifyError('Mission not found.'); return; }
    await sendUnitsToMission(mission, ids, area, true);
    openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  } catch (e) {
    console.error(e);
    notifyError('Failed to dispatch one or more units.');
  }
}

async function openUnitTypeDispatch(mission) {
  const area = document.getElementById('unitTypeDispatchArea');
  area.innerHTML = 'Loading units…';
  try {
    const [stations, units] = await Promise.all([
      fetch('/api/stations').then(r=>r.json()),
      fetch('/api/units?status=available').then(r=>r.json())
    ]);
    const stMap = new Map(stations.map(s=>[s.id,s]));
    const groups = new Map();
    units.forEach(u=>{
      const st = stMap.get(u.station_id);
      const dist = st ? haversineKm(mission.lat, mission.lon, st.lat, st.lon) : Infinity;
      const arr = groups.get(u.type) || [];
      arr.push({ ...u, distance: dist });
      groups.set(u.type, arr);
    });
    let html = '<div style="margin-bottom:6px;"><button id="closeUnitTypeDispatch">Close</button></div>';
    for (const [type, list] of groups.entries()) {
      const arr = list.sort((a,b)=>a.distance-b.distance);
      html += `<div><strong>${type}</strong> (${arr.length}) <button data-type="${type}" class="utd-send">Send 1</button></div>`;
    }
    area.innerHTML = html;
    document.getElementById('closeUnitTypeDispatch').onclick = () => { area.innerHTML = ''; };
    area.querySelectorAll('.utd-send').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const type = btn.dataset.type;
        const list = groups.get(type) || [];
        if (!list.length) { notifyError('No available units'); return; }
        const unit = list.shift();
        await sendUnitsToMission(mission, [unit.id], undefined, true);
        openUnitTypeDispatch(mission);
      });
    });
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Failed to load units.</span>';
  }
}

async function missionDepartmentsFor(mission) {
  if (Array.isArray(mission.departments) && mission.departments.length) return mission.departments;
  try {
    const zones = await fetch('/api/response-zones').then(r => r.json());
    const matches = [];
    for (const z of zones) {
      if (pointInPolygon(mission.lat, mission.lon, z.polygon)) {
        const prio = z.priority != null ? Number(z.priority) : Infinity;
        const depts = Array.isArray(z.departments) ? z.departments : [];
        matches.push({ priority: prio, departments: depts });
      }
    }
    matches.sort((a, b) => a.priority - b.priority);
    const seen = new Set();
    const departments = [];
    for (const m of matches) {
      m.departments.forEach(d => {
        if (!seen.has(d)) {
          seen.add(d);
          departments.push(d);
        }
      });
    }
    return departments;
  } catch {
    return [];
  }
}

function pointInPolygon(lat, lon, poly) {
  const pts = Array.isArray(poly?.coordinates) ? poly.coordinates : [];
  let inside = false;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    const xi = pts[i][1], yi = pts[i][0];
    const xj = pts[j][1], yj = pts[j][0];
    const intersect = ((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function ensureDispatchArea() {
  let area = document.getElementById('manualDispatchArea');
  let tempArea = false;
  if (!area) {
    area = document.createElement('div');
    area.id = 'manualDispatchArea';
    area.style.display = 'none';
    document.body.appendChild(area);
    tempArea = true;
  }
  return { area, tempArea };
}

async function autoDispatch(mission) {
  const { area, tempArea } = ensureDispatchArea();
  area.innerHTML = 'Selecting units…';
  try {
    const [stations, allUnitsRaw] = await Promise.all([
    fetch('/api/stations').then(r=>r.json()),
    fetch('/api/units?status=available').then(r=>r.json())
  ]);
  cacheStations(stations);
  const stMap = new Map(stations.map(s=>[s.id,s]));
  const missionDepts = await missionDepartmentsFor(mission);
  const allUnits = allUnitsRaw
    .filter(u=>{
      const st = stMap.get(u.station_id);
      return missionDepts.length === 0 || (st && missionDepts.includes(st.department));
    })
    .map(u=>{
      const st = stMap.get(u.station_id);
      const dist = st ? haversineKm(st.lat, st.lon, mission.lat, mission.lon) : Infinity;
      const priority = Number(u.priority) || 1;
      return { ...u, priority, _dist: dist };
      });

    const sortUnits = (a,b)=>{
      if (a.station_id === b.station_id) return a.priority - b.priority;
      return a._dist - b._dist;
    };

    function trainingCount(u, name) {
      let c = 0;
      for (const p of Array.isArray(u.personnel)?u.personnel:[]) {
        for (const t of Array.isArray(p.training)?p.training:[]) {
          if (String(t).toLowerCase() === String(name).toLowerCase()) c++;
        }
      }
      return c;
    }
    function equipmentCount(u, name) {
      const key = equipmentKey(name);
      if (!key) return 0;
      const counts = gatherUnitEquipment(u);
      return counts.get(key) || 0;
    }

    const selected = [];
    const selectedIds = new Set();

    const trainingNeeds = (Array.isArray(mission.required_training)?mission.required_training:[])
      .map(r=>({ name: r.training || r.name || r, qty: r.qty ?? r.quantity ?? r.count ?? 1 }));
    const equipmentNeeds = (Array.isArray(mission.equipment_required)?mission.equipment_required:[])
      .map(r=>({ name: r.name || r.type || r, qty: r.qty ?? r.quantity ?? r.count ?? 1 }));

    function applyNeeds(u) {
      for (const n of trainingNeeds) {
        n.qty -= trainingCount(u, n.name);
      }
      for (const n of equipmentNeeds) {
        n.qty -= equipmentCount(u, n.name);
      }
    }

    // subtract already assigned units (enroute/on_scene)
    const assigned = await fetchNoCache(`/api/missions/${mission.id}/units`).then(r=>r.json()).catch(()=>[]);
    const assignedCounts = {};
    for (const a of assigned) {
      if (!['enroute','on_scene'].includes(a.status)) continue;
      assignedCounts[a.type] = (assignedCounts[a.type] || 0) + 1;
      applyNeeds(a);
    }

    function unitMatchesNeed(u) {
      return trainingNeeds.some(n=>n.qty>0 && trainingCount(u,n.name)>0) ||
             equipmentNeeds.some(n=>n.qty>0 && equipmentCount(u,n.name)>0);
    }

    function unitMatchesAllNeeds(u) {
      return trainingNeeds.every(n=>n.qty<=0 || trainingCount(u,n.name)>0) &&
             equipmentNeeds.every(n=>n.qty<=0 || equipmentCount(u,n.name)>0);
    }

    function selectUnit(u) {
      selectedIds.add(u.id);
      selected.push(u);
      applyNeeds(u);
    }

    const reqUnits = Array.isArray(mission.required_units) ? mission.required_units : [];
    for (const r of reqUnits) {
      const types = Array.isArray(r.types) ? r.types : [r.type];
      let need = (r.quantity ?? r.count ?? r.qty ?? 1) - types.reduce((s,t)=>s+(assignedCounts[t]||0),0);
      for (let i=0; i<need; i++) {
        let candidates = allUnits.filter(u=>!selectedIds.has(u.id) && types.includes(u.type))
                                 .sort(sortUnits);
        if (!candidates.length) break;
        const chosen = candidates.find(unitMatchesAllNeeds) ||
                       candidates.find(unitMatchesNeed) ||
                       candidates[0];
        selectUnit(chosen);
      }
    }

    for (const n of trainingNeeds) {
      while (n.qty > 0) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && trainingCount(u,n.name)>0)
                                   .sort(sortUnits);
        if (!candidates.length) break;
        selectUnit(candidates[0]);
      }
    }

    for (const n of equipmentNeeds) {
      while (n.qty > 0) {
        const candidates = allUnits.filter(u=>!selectedIds.has(u.id) && equipmentCount(u,n.name)>0)
                                   .sort(sortUnits);
        if (!candidates.length) break;
        selectUnit(candidates[0]);
      }
    }

    if (!selected.length) { area.innerHTML = '<em>No additional units available.</em>'; return; }
    const ids = selected.map(u=>u.id);
    await sendUnitsToMission(mission, ids, area);
  } catch (e) {
    console.error(e);
    area.innerHTML = '<span style="color:#b00;">Auto dispatch failed.</span>';
  } finally {
    if (tempArea) area.remove();
  }
}

async function runCardDispatch(mission, card = null) {
  const { area, tempArea } = ensureDispatchArea();
  try {
    const query = card?.id ? `?id=${encodeURIComponent(card.id)}` : '';
    const res = await fetch(`/api/run-cards/${encodeURIComponent(mission.type)}${query}`);
    if (!res.ok) { notifyError('No run card for this mission.'); return; }
    const rc = await res.json();
    const rcMission = {
      ...mission,
      departments: mission.departments || [],
      required_units: rc.units || [],
      required_training: rc.training || [],
      equipment_required: rc.equipment || []
    };
    await autoDispatch(rcMission);
  } catch (e) {
    console.error(e);
    notifyError('Run card dispatch failed.');
  } finally {
    if (tempArea) area.remove();
  }
}

async function dispatchRunCard() {
  if (window.currentMission) {
    await runCardDispatch(window.currentMission);
  }
}

async function clearAssignedUnit(missionId, unitId) {
  const res = await fetch('/api/mission-units',{ method:'DELETE', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ mission_id: missionId, unit_id: unitId }) });
  if (!res.ok) { const t = await res.text().catch(()=> ''); console.error('Unassign failed:', res.status, t); notifyError('Failed to clear unit from mission.'); return; }

  const [units, missions] = await Promise.all([
    fetchNoCache('/api/units').then(r=>r.json()),
    fetchNoCache('/api/missions').then(r=>r.json())
  ]);
  cacheUnits(units);
  const u = _unitById.get(unitId);
  const mission = missions.find(m=>m.id===missionId);
  const st = u && _stationById.get(u.station_id);
  if (u && mission && st) {
    ensureUnitMarker(u);
    const entry = unitMarkers.get(u.id);
    const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
    const from = [current.lat, current.lng];
    const to   = [st.lat, st.lon];
    routeAndAnimateUnit(
        u.id, from, to, TRAVEL_SPEED[u.type] || CLASS_SPEED[u.class] || 56,
      () => { const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); } fetch(`/api/unit-travel/${u.id}`,{method:'DELETE'}).catch(()=>{}); },
      { phase: 'return' }
    );
  }
  const assigned = await refreshAssignedUnitsUI(missionId);
  if (document.getElementById('manualDispatchArea')) openManualDispatch({ id: missionId, lat: mission.lat, lon: mission.lon });
  const missionSnap = missions.find(m=>m.id===missionId);
  if (missionSnap) {
    const reqDiv = document.getElementById('reqDynamic');
    if (reqDiv) { reqDiv.innerHTML = renderRequirementsDynamic(missionSnap, assigned); attachPenaltyHandlers(missionSnap); }
  }
}

// Work timer / resolve
const activeWorkTimers = new Map();

function persistWorkTimers() {
  const arr = Array.from(activeWorkTimers.entries()).map(([id, obj]) => ({ id, endTime: obj.endTime }));
  try { localStorage.setItem('activeWorkTimers', JSON.stringify(arr)); }
  catch { /* ignore */ }
}

(function restoreWorkTimers(){
  try {
    const data = JSON.parse(localStorage.getItem('activeWorkTimers') || '[]');
    const now = Date.now();
    for (const { id, endTime } of data) {
      if (endTime > now) activeWorkTimers.set(id, { endTime });
    }
    persistWorkTimers();
  } catch {
    /* ignore */
  }
})();

function startMissionCountdown(missionId, endTime) {
  const existing = activeWorkTimers.get(missionId);
  if (existing && existing.intervalId) clearInterval(existing.intervalId);
  let iid;
  const update = () => {
    const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
    if (openMissionId === missionId) {
      const tDiv = document.getElementById('missionTimerArea');
      if (remaining <= 0) {
        if (tDiv) tDiv.textContent = 'Resolving…';
      } else if (tDiv) {
        const mins = Math.floor(remaining / 60);
        const secs = remaining % 60;
        tDiv.textContent = `Time remaining: ${mins}:${secs.toString().padStart(2, '0')}`;
      }
    }
    if (remaining <= 0 && iid) clearInterval(iid);
  };
  update();
  iid = setInterval(update, 1000);
  if (existing) {
    existing.intervalId = iid;
    existing.endTime = endTime;
  } else {
    activeWorkTimers.set(missionId, { endTime, intervalId: iid });
  }
  persistWorkTimers();
}

function setupTimerForMission(mission, endTime) {
  const existing = activeWorkTimers.get(mission.id);
  if (existing) {
    if (existing.timeoutId) clearTimeout(existing.timeoutId);
    if (existing.intervalId) clearInterval(existing.intervalId);
  }
  const ms = Math.max(0, endTime - Date.now());
  const tid = setTimeout(async ()=>{
    const cur = activeWorkTimers.get(mission.id);
    if (cur && cur.intervalId) clearInterval(cur.intervalId);
    activeWorkTimers.delete(mission.id);
    persistWorkTimers();
    const assignedBefore = await (await fetch(`/api/missions/${mission.id}/units`)).json();
    let resolutionResult = null;
    try {
      const resp = await fetch(`/api/missions/${mission.id}`, { method:'PUT' });
      if (!resp.ok) throw new Error(`Mission resolve failed: ${resp.status}`);
      resolutionResult = await resp.json();
      if (resolutionResult && typeof resolutionResult.balance !== 'undefined') {
        setWalletBalanceDisplay(resolutionResult.balance);
      }
    } catch (err) {
      console.error(err);
    }
    if (!_stationById || _stationById.size===0) {
      const stations = await (await fetch('/api/stations')).json();
      cacheStations(stations);
    }
    for (const u of assignedBefore) {
      const st = _stationById.get(u.station_id);
      if (!st) continue;
      u.responding = false;
      u.status = 'available';
      _unitById.set(u.id, u);
      ensureUnitMarker(u);
      const entry = unitMarkers.get(u.id);
      const current = entry?.marker.getLatLng() || L.latLng(mission.lat, mission.lon);
      routeAndAnimateUnit(
        u.id,
        [current.lat, current.lng],
        [st.lat, st.lon],
          TRAVEL_SPEED[u.type] || CLASS_SPEED[u.class] || 56,
        () => {
          const rp = unitRoutes.get(u.id);
          if (rp) { try { map.removeLayer(rp); } catch {} unitRoutes.delete(u.id); }
          fetch(`/api/unit-travel/${u.id}`, { method:'DELETE' }).catch(()=>{});
        },
        { phase: 'return' }
      );
    }
    await refreshAssignedUnitsUI(mission.id);
    await fetchMissions();
    const area = document.getElementById('manualDispatchArea');
    const parts = [];
    if (resolutionResult) {
      const reward = Number(resolutionResult.reward);
      const freed = Number(resolutionResult.freed);
      if (Number.isFinite(reward) && reward !== 0) {
        const rewardPrefix = reward > 0 ? '+' : '-';
        const rewardLabel = reward > 0 ? 'transport payout' : 'penalty';
        parts.push(`${rewardPrefix}$${Math.abs(reward).toLocaleString()} ${rewardLabel}`);
      }
      if (Number.isFinite(freed) && freed > 0) {
        parts.push(`${freed} unit${freed === 1 ? '' : 's'} freed`);
      }
      if (parts.length && typeof window.notifySuccess === 'function') {
        window.notifySuccess(parts.join(', '));
      }
    }
    const message = parts.length ? `Mission resolved. ${parts.join(', ')}` : 'Mission resolved.';
    if (area) {
      area.textContent = message;
    }
  }, ms);
  activeWorkTimers.set(mission.id, { timeoutId: tid, endTime });
  startMissionCountdown(mission.id, endTime);
  persistWorkTimers();
}

for (const [id, obj] of Array.from(activeWorkTimers.entries())) {
  startMissionCountdown(id, obj.endTime);
}

// Mission completion is now handled entirely by the server.
async function checkMissionCompletion() {
  return;
}

// Rebuild en-route after reload (using backend unit-travel)
async function rebuildEnrouteMarkers() {
  const [stations, allUnits] = await Promise.all([ fetch('/api/stations').then(r=>r.json()), fetch('/api/units').then(r=>r.json()) ]);
  cacheStations(stations);
  cacheUnits(allUnits);

  let travels = [];
  try { travels = await (await fetch('/api/unit-travel/active')).json(); }
  catch(e){ console.warn('No /api/unit-travel/active; fallback to old behavior.'); }

  if (Array.isArray(travels) && travels.length) {
    for (const t of travels) {
      const u = _unitById.get(t.unit_id);
      if (!u) continue;
      if (t.phase === 'patrol') {
        startUnitPatrol(u);
        continue;
      }
      ensureUnitMarker(u);
      routeAndAnimateUnit(
          t.unit_id, t.from, t.to, TRAVEL_SPEED[u.type] || CLASS_SPEED[u.class] || 56,
        async () => {
          if (t.phase === 'to_scene') {
            await fetch(`/api/units/${t.unit_id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'on_scene' }) });
          }
          const entry = unitMarkers.get(t.unit_id);
          if (t.phase === 'to_scene' && entry) { try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(t.unit_id); }
          const rp = unitRoutes.get(t.unit_id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(t.unit_id); }
          clearUnitEta(t.unit_id);
          fetch(`/api/unit-travel/${t.unit_id}`, { method:'DELETE' }).catch(()=>{});
          if (t.mission_id) {
            let mission = null;
            try {
              mission = await fetch(`/api/missions/${t.mission_id}`).then(r => r.json());
            } catch {}
            if (mission) checkMissionCompletion(mission);
          }
        },
        { saved: t }
      );
    }
    return;
  }

  // Fallback: naive restart-from-station if travel store is empty
  try {
    const missions = await (await fetch('/api/missions')).json();
    const active = missions.filter(m => m.status !== 'resolved');
    for (const m of active) {
      const assigned = await (await fetch(`/api/missions/${m.id}/units`)).json();
      for (const u of assigned) {
        if (u.status === 'enroute') {
          const st = _stationById.get(u.station_id);
          if (!st) continue;
          ensureUnitMarker(u);
            routeAndAnimateUnit(u.id, [st.lat, st.lon], [m.lat, m.lon], TRAVEL_SPEED[u.type] || CLASS_SPEED[u.class] || 56, async ()=>{
            await fetch(`/api/units/${u.id}/status`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ status: 'on_scene' }) });
            const entry = unitMarkers.get(u.id); if (entry){ try{ map.removeLayer(entry.marker); }catch{} unitMarkers.delete(u.id); }
            const rp = unitRoutes.get(u.id); if (rp){ try{ map.removeLayer(rp); }catch{} unitRoutes.delete(u.id); }
            clearUnitEta(u.id);
            await refreshAssignedUnitsUI(m.id);
            checkMissionCompletion(m);
          });
        }
      }
    }
  } catch(e){ console.warn('Fallback rebuild failed:', e); }
}

// Init
(async () => {
  await fetchStations();
  await fetchMissions();
  setInterval(fetchMissions, 5000);
  await fetchZones();
  rebuildEnrouteMarkers();
})();
</script>

</body>
</html>
