 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/server.js b/server.js
index 84d8723deb6c466fff6c7d42efb11351ea054c81..0f25f5f9e76fffa55ad2df38ea848f7a1a470269 100644
--- a/server.js
+++ b/server.js
@@ -2,190 +2,230 @@ const express = require('express');
 const bodyParser = require('body-parser');
 const axios = require('axios');
 const cors = require('cors');
 const path = require('path');
 const { getRandomName } = require('./names');
 const { getBalance, adjustBalance, requireFunds } = require('./wallet');
 
 const db = require('./db');             // your sqlite3 instance
 const unitTypes = require('./unitTypes');
 let trainingsByClass = {};
 let equipment = {};
 try { trainingsByClass = require('./trainings'); } catch { /* falls back to {} */ }
 try { equipment = require('./equipment'); } catch { /* falls back to {} */ }
 
 // Normalize legacy status values missing the underscore.
 // Older clients used "onscene" while the server expects "on_scene".
 // This ensures any existing records are standardized on startup.
 db.serialize(() => {
   db.run("UPDATE units SET status='on_scene' WHERE status='onscene'");
   db.run("UPDATE missions SET status='on_scene' WHERE status='onscene'");
 });
 
 const { parseArrayField, reverseGeocode, pointInPolygon } = require('./utils');
 
 const CLASS_SPEED = { fire: 63, police: 94, ambulance: 75, sar: 70 }; // km/h (25% faster)
+const ROUTE_CACHE_TTL = 60 * 60 * 1000; // 1 hour
 function haversine(aLat, aLon, bLat, bLon) {
   const R = 6371;
   const dLat = (bLat - aLat) * Math.PI / 180;
   const dLon = (bLon - aLon) * Math.PI / 180;
   const la1 = aLat * Math.PI / 180, la2 = bLat * Math.PI / 180;
   const h = Math.sin(dLat / 2) ** 2 + Math.cos(la1) * Math.cos(la2) * Math.sin(dLon / 2) ** 2;
   return 2 * R * Math.asin(Math.sqrt(h));
 }
 
 const app = express();
 const PORT = 911;
 
 app.use(bodyParser.json());
 app.use(cors());
 app.use(express.static('public'));
 app.get('/config/unitTypes.js', (req,res)=>res.sendFile(path.join(__dirname,'unitTypes.js')));
 app.get('/config/trainings.js', (req,res)=>res.sendFile(path.join(__dirname,'trainings.js')));
 app.get('/config/equipment.js', (req,res)=>res.sendFile(path.join(__dirname,'equipment.js')));
 app.get('/config/osmPoiTypes.js', (req,res)=>res.sendFile(path.join(__dirname,'osmPoiTypes.js')));
 
 // Modular routes
 const missionsRoutes = require('./routes/missions');
 const stationsRoutes = require('./routes/stations');
 const unitsRoutes = require('./routes/units');
 
 app.use('/api/missions', missionsRoutes);
 app.use('/api/stations', stationsRoutes);
 app.use('/api/units', unitsRoutes);
 
 // Route proxy endpoint to avoid client-side CORS issues.  Attempts OSRM first
 // (with snapped coordinates), then falls back to GraphHopper/OpenRouteService.
 // If all providers fail, an error is returned instead of a straight-line route.
 app.get('/api/route', async (req, res) => {
   const { from, to } = req.query;
   if (!from || !to) return res.status(400).json({ error: 'missing from/to' });
   const [fromLat, fromLon] = from.split(',').map(Number);
   const [toLat, toLon] = to.split(',').map(Number);
 
+  const now = Date.now();
+  const cacheKey = [fromLat, fromLon, toLat, toLon];
+  try {
+    const row = await new Promise((resolve, reject) => {
+      db.get(
+        `SELECT payload, updated_at FROM route_cache WHERE from_lat=? AND from_lon=? AND to_lat=? AND to_lon=?`,
+        cacheKey,
+        (err, r) => (err ? reject(err) : resolve(r))
+      );
+    });
+    if (row && now - row.updated_at < ROUTE_CACHE_TTL) {
+      return res.json(JSON.parse(row.payload));
+    }
+  } catch {
+    /* ignore cache errors */
+  }
+
+  function cacheAndReturn(payload) {
+    db.run(
+      `INSERT OR REPLACE INTO route_cache (from_lat, from_lon, to_lat, to_lon, payload, updated_at) VALUES (?,?,?,?,?,?)`,
+      [...cacheKey, JSON.stringify(payload), now]
+    );
+    db.run(`DELETE FROM route_cache WHERE updated_at < ?`, now - ROUTE_CACHE_TTL);
+    return res.json(payload);
+  }
+
   // Snap start/end to the nearest road using OSRM's `nearest` service.
   let snappedFrom = [fromLat, fromLon];
   let snappedTo = [toLat, toLon];
   try {
     const nf = await axios.get(
       `https://router.project-osrm.org/nearest/v1/driving/${fromLon},${fromLat}?number=1`,
       { timeout: 5000 }
     );
     if (nf.data?.waypoints?.length) {
       const [lon, lat] = nf.data.waypoints[0].location;
       snappedFrom = [lat, lon];
     }
     const nt = await axios.get(
       `https://router.project-osrm.org/nearest/v1/driving/${toLon},${toLat}?number=1`,
       { timeout: 5000 }
     );
     if (nt.data?.waypoints?.length) {
       const [lon, lat] = nt.data.waypoints[0].location;
       snappedTo = [lat, lon];
     }
   } catch {
     // Ignore snapping errors; we'll fall back to original coordinates.
   }
 
   // Try OSRM routing first.
   try {
     const url = `https://router.project-osrm.org/route/v1/driving/${snappedFrom[1]},${snappedFrom[0]};${snappedTo[1]},${snappedTo[0]}?overview=full&geometries=geojson&annotations=duration,distance&steps=false`;
     const { data } = await axios.get(url, { timeout: 5000 });
     if (!data.routes?.length) throw new Error('No route');
     const route = data.routes[0];
     const coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
     const duration = route.duration;
     const annotations = route.legs?.[0]?.annotation || null;
-    return res.json({
+    return cacheAndReturn({
       coords,
       duration,
       annotations,
       from: snappedFrom,
       to: snappedTo,
       provider: 'osrm'
     });
   } catch (err) {
     // Secondary provider: GraphHopper
     try {
       const ghKey = process.env.GRAPHHOPPER_KEY;
       if (ghKey) {
         const ghUrl = `https://graphhopper.com/api/1/route?point=${snappedFrom[0]},${snappedFrom[1]}&point=${snappedTo[0]},${snappedTo[1]}&profile=car&calc_points=true&points_encoded=false&key=${ghKey}`;
         const { data } = await axios.get(ghUrl, { timeout: 5000 });
         const path = data.paths?.[0];
         if (path?.points?.coordinates) {
           const coords = path.points.coordinates.map(([lon, lat]) => [lat, lon]);
           const duration = path.time / 1000; // ms â†’ s
-          return res.json({
+          return cacheAndReturn({
             coords,
             duration,
             annotations: null,
             from: snappedFrom,
             to: snappedTo,
             provider: 'graphhopper'
           });
         }
       }
     } catch {
       /* ignore and try next provider */
     }
 
     // Secondary provider: OpenRouteService
     try {
       const orsKey = process.env.ORS_KEY || process.env.OPENROUTESERVICE_KEY;
       if (orsKey) {
         const orsUrl = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${orsKey}&start=${snappedFrom[1]},${snappedFrom[0]}&end=${snappedTo[1]},${snappedTo[0]}`;
         const { data } = await axios.get(orsUrl, { timeout: 5000 });
         const route = data.features?.[0];
         if (route) {
           const coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
           const duration = route.properties?.summary?.duration || 0;
-          return res.json({
+          return cacheAndReturn({
             coords,
             duration,
             annotations: null,
             from: snappedFrom,
             to: snappedTo,
             provider: 'openrouteservice'
           });
         }
       }
     } catch {
       /* ignore and let final error handler run */
     }
 
     // All routing providers failed; return an error so callers can decide how to handle it.
     return res.status(502).json({ error: 'No routing provider available' });
   }
 });
 
-db.serialize(() => {
-  // Stations
-  db.run(`
-    CREATE TABLE IF NOT EXISTS stations (
-      id INTEGER PRIMARY KEY AUTOINCREMENT,
-      name TEXT,
-      type TEXT,
+db.serialize(() => {
+  // Route cache
+  db.run(`
+    CREATE TABLE IF NOT EXISTS route_cache (
+      from_lat REAL,
+      from_lon REAL,
+      to_lat REAL,
+      to_lon REAL,
+      payload TEXT,
+      updated_at INTEGER,
+      PRIMARY KEY (from_lat, from_lon, to_lat, to_lon)
+    )
+  `);
+
+  // Stations
+  db.run(`
+    CREATE TABLE IF NOT EXISTS stations (
+      id INTEGER PRIMARY KEY AUTOINCREMENT,
+      name TEXT,
+      type TEXT,
       lat REAL,
       lon REAL,
       department TEXT
     )
   `);
 
   // Missions
   db.run(`
     CREATE TABLE IF NOT EXISTS missions (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       type TEXT,
       lat REAL,
       lon REAL,
       address TEXT,
       departments TEXT,
       required_units TEXT,
       required_training TEXT DEFAULT '[]',
       equipment_required TEXT DEFAULT '[]',
       patients TEXT DEFAULT '[]',
       prisoners TEXT DEFAULT '[]',
       modifiers TEXT DEFAULT '[]',
       penalty_options TEXT DEFAULT '[]',
       penalties TEXT DEFAULT '[]',
       non_emergency INTEGER,
       status TEXT,
 
EOF
)